var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/pizzip/js/base64.js
var require_base64 = __commonJS({
  "node_modules/pizzip/js/base64.js"(exports) {
    "use strict";
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports.encode = function(input) {
      var output = "";
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
      }
      return output;
    };
    exports.decode = function(input) {
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i2 < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i2++));
        enc2 = _keyStr.indexOf(input.charAt(i2++));
        enc3 = _keyStr.indexOf(input.charAt(i2++));
        enc4 = _keyStr.indexOf(input.charAt(i2++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output += String.fromCharCode(chr3);
        }
      }
      return output;
    };
  }
});

// node_modules/pizzip/js/support.js
var require_support = __commonJS({
  "node_modules/pizzip/js/support.js"(exports) {
    "use strict";
    exports.base64 = true;
    exports.array = true;
    exports.string = true;
    exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports.nodebuffer = typeof Buffer !== "undefined";
    exports.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports.blob = false;
    } else {
      buffer2 = new ArrayBuffer(0);
      try {
        exports.blob = new Blob([buffer2], {
          type: "application/zip"
        }).size === 0;
      } catch (_unused) {
        try {
          Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer2);
          exports.blob = builder.getBlob("application/zip").size === 0;
        } catch (_unused2) {
          exports.blob = false;
        }
      }
    }
    var buffer2;
    var Builder;
    var builder;
  }
});

// node_modules/pizzip/node_modules/pako/dist/pako.es5.min.js
var require_pako_es5_min = __commonJS({
  "node_modules/pizzip/node_modules/pako/dist/pako.es5.min.js"(exports, module) {
    !(function(t2, e2) {
      "object" == typeof exports && "undefined" != typeof module ? e2(exports) : "function" == typeof define && define.amd ? define(["exports"], e2) : e2((t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).pako = {});
    })(exports, (function(t2) {
      "use strict";
      function e2(t3) {
        for (var e3 = t3.length; --e3 >= 0; ) t3[e3] = 0;
      }
      var a = 256, n = 286, i2 = 30, r2 = 15, s2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), o = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), l = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), h2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), d = new Array(576);
      e2(d);
      var _ = new Array(60);
      e2(_);
      var f3 = new Array(512);
      e2(f3);
      var u = new Array(256);
      e2(u);
      var c = new Array(29);
      e2(c);
      var w, m2, b, g = new Array(i2);
      function p(t3, e3, a2, n2, i3) {
        this.static_tree = t3, this.extra_bits = e3, this.extra_base = a2, this.elems = n2, this.max_length = i3, this.has_stree = t3 && t3.length;
      }
      function v(t3, e3) {
        this.dyn_tree = t3, this.max_code = 0, this.stat_desc = e3;
      }
      e2(g);
      var k = function(t3) {
        return t3 < 256 ? f3[t3] : f3[256 + (t3 >>> 7)];
      }, y = function(t3, e3) {
        t3.pending_buf[t3.pending++] = 255 & e3, t3.pending_buf[t3.pending++] = e3 >>> 8 & 255;
      }, x2 = function(t3, e3, a2) {
        t3.bi_valid > 16 - a2 ? (t3.bi_buf |= e3 << t3.bi_valid & 65535, y(t3, t3.bi_buf), t3.bi_buf = e3 >> 16 - t3.bi_valid, t3.bi_valid += a2 - 16) : (t3.bi_buf |= e3 << t3.bi_valid & 65535, t3.bi_valid += a2);
      }, z = function(t3, e3, a2) {
        x2(t3, a2[2 * e3], a2[2 * e3 + 1]);
      }, A2 = function(t3, e3) {
        var a2 = 0;
        do {
          a2 |= 1 & t3, t3 >>>= 1, a2 <<= 1;
        } while (--e3 > 0);
        return a2 >>> 1;
      }, E = function(t3, e3, a2) {
        var n2, i3, s3 = new Array(16), o2 = 0;
        for (n2 = 1; n2 <= r2; n2++) o2 = o2 + a2[n2 - 1] << 1, s3[n2] = o2;
        for (i3 = 0; i3 <= e3; i3++) {
          var l2 = t3[2 * i3 + 1];
          0 !== l2 && (t3[2 * i3] = A2(s3[l2]++, l2));
        }
      }, R = function(t3) {
        var e3;
        for (e3 = 0; e3 < n; e3++) t3.dyn_ltree[2 * e3] = 0;
        for (e3 = 0; e3 < i2; e3++) t3.dyn_dtree[2 * e3] = 0;
        for (e3 = 0; e3 < 19; e3++) t3.bl_tree[2 * e3] = 0;
        t3.dyn_ltree[512] = 1, t3.opt_len = t3.static_len = 0, t3.sym_next = t3.matches = 0;
      }, Z2 = function(t3) {
        t3.bi_valid > 8 ? y(t3, t3.bi_buf) : t3.bi_valid > 0 && (t3.pending_buf[t3.pending++] = t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0;
      }, S2 = function(t3, e3, a2, n2) {
        var i3 = 2 * e3, r3 = 2 * a2;
        return t3[i3] < t3[r3] || t3[i3] === t3[r3] && n2[e3] <= n2[a2];
      }, U = function(t3, e3, a2) {
        for (var n2 = t3.heap[a2], i3 = a2 << 1; i3 <= t3.heap_len && (i3 < t3.heap_len && S2(e3, t3.heap[i3 + 1], t3.heap[i3], t3.depth) && i3++, !S2(e3, n2, t3.heap[i3], t3.depth)); ) t3.heap[a2] = t3.heap[i3], a2 = i3, i3 <<= 1;
        t3.heap[a2] = n2;
      }, D = function(t3, e3, n2) {
        var i3, r3, l2, h3, d2 = 0;
        if (0 !== t3.sym_next) do {
          i3 = 255 & t3.pending_buf[t3.sym_buf + d2++], i3 += (255 & t3.pending_buf[t3.sym_buf + d2++]) << 8, r3 = t3.pending_buf[t3.sym_buf + d2++], 0 === i3 ? z(t3, r3, e3) : (l2 = u[r3], z(t3, l2 + a + 1, e3), 0 !== (h3 = s2[l2]) && (r3 -= c[l2], x2(t3, r3, h3)), i3--, l2 = k(i3), z(t3, l2, n2), 0 !== (h3 = o[l2]) && (i3 -= g[l2], x2(t3, i3, h3)));
        } while (d2 < t3.sym_next);
        z(t3, 256, e3);
      }, T = function(t3, e3) {
        var a2, n2, i3, s3 = e3.dyn_tree, o2 = e3.stat_desc.static_tree, l2 = e3.stat_desc.has_stree, h3 = e3.stat_desc.elems, d2 = -1;
        for (t3.heap_len = 0, t3.heap_max = 573, a2 = 0; a2 < h3; a2++) 0 !== s3[2 * a2] ? (t3.heap[++t3.heap_len] = d2 = a2, t3.depth[a2] = 0) : s3[2 * a2 + 1] = 0;
        for (; t3.heap_len < 2; ) s3[2 * (i3 = t3.heap[++t3.heap_len] = d2 < 2 ? ++d2 : 0)] = 1, t3.depth[i3] = 0, t3.opt_len--, l2 && (t3.static_len -= o2[2 * i3 + 1]);
        for (e3.max_code = d2, a2 = t3.heap_len >> 1; a2 >= 1; a2--) U(t3, s3, a2);
        i3 = h3;
        do {
          a2 = t3.heap[1], t3.heap[1] = t3.heap[t3.heap_len--], U(t3, s3, 1), n2 = t3.heap[1], t3.heap[--t3.heap_max] = a2, t3.heap[--t3.heap_max] = n2, s3[2 * i3] = s3[2 * a2] + s3[2 * n2], t3.depth[i3] = (t3.depth[a2] >= t3.depth[n2] ? t3.depth[a2] : t3.depth[n2]) + 1, s3[2 * a2 + 1] = s3[2 * n2 + 1] = i3, t3.heap[1] = i3++, U(t3, s3, 1);
        } while (t3.heap_len >= 2);
        t3.heap[--t3.heap_max] = t3.heap[1], (function(t4, e4) {
          var a3, n3, i4, s4, o3, l3, h4 = e4.dyn_tree, d3 = e4.max_code, _2 = e4.stat_desc.static_tree, f4 = e4.stat_desc.has_stree, u2 = e4.stat_desc.extra_bits, c2 = e4.stat_desc.extra_base, w2 = e4.stat_desc.max_length, m3 = 0;
          for (s4 = 0; s4 <= r2; s4++) t4.bl_count[s4] = 0;
          for (h4[2 * t4.heap[t4.heap_max] + 1] = 0, a3 = t4.heap_max + 1; a3 < 573; a3++) (s4 = h4[2 * h4[2 * (n3 = t4.heap[a3]) + 1] + 1] + 1) > w2 && (s4 = w2, m3++), h4[2 * n3 + 1] = s4, n3 > d3 || (t4.bl_count[s4]++, o3 = 0, n3 >= c2 && (o3 = u2[n3 - c2]), l3 = h4[2 * n3], t4.opt_len += l3 * (s4 + o3), f4 && (t4.static_len += l3 * (_2[2 * n3 + 1] + o3)));
          if (0 !== m3) {
            do {
              for (s4 = w2 - 1; 0 === t4.bl_count[s4]; ) s4--;
              t4.bl_count[s4]--, t4.bl_count[s4 + 1] += 2, t4.bl_count[w2]--, m3 -= 2;
            } while (m3 > 0);
            for (s4 = w2; 0 !== s4; s4--) for (n3 = t4.bl_count[s4]; 0 !== n3; ) (i4 = t4.heap[--a3]) > d3 || (h4[2 * i4 + 1] !== s4 && (t4.opt_len += (s4 - h4[2 * i4 + 1]) * h4[2 * i4], h4[2 * i4 + 1] = s4), n3--);
          }
        })(t3, e3), E(s3, d2, t3.bl_count);
      }, O = function(t3, e3, a2) {
        var n2, i3, r3 = -1, s3 = e3[1], o2 = 0, l2 = 7, h3 = 4;
        for (0 === s3 && (l2 = 138, h3 = 3), e3[2 * (a2 + 1) + 1] = 65535, n2 = 0; n2 <= a2; n2++) i3 = s3, s3 = e3[2 * (n2 + 1) + 1], ++o2 < l2 && i3 === s3 || (o2 < h3 ? t3.bl_tree[2 * i3] += o2 : 0 !== i3 ? (i3 !== r3 && t3.bl_tree[2 * i3]++, t3.bl_tree[32]++) : o2 <= 10 ? t3.bl_tree[34]++ : t3.bl_tree[36]++, o2 = 0, r3 = i3, 0 === s3 ? (l2 = 138, h3 = 3) : i3 === s3 ? (l2 = 6, h3 = 3) : (l2 = 7, h3 = 4));
      }, I = function(t3, e3, a2) {
        var n2, i3, r3 = -1, s3 = e3[1], o2 = 0, l2 = 7, h3 = 4;
        for (0 === s3 && (l2 = 138, h3 = 3), n2 = 0; n2 <= a2; n2++) if (i3 = s3, s3 = e3[2 * (n2 + 1) + 1], !(++o2 < l2 && i3 === s3)) {
          if (o2 < h3) do {
            z(t3, i3, t3.bl_tree);
          } while (0 != --o2);
          else 0 !== i3 ? (i3 !== r3 && (z(t3, i3, t3.bl_tree), o2--), z(t3, 16, t3.bl_tree), x2(t3, o2 - 3, 2)) : o2 <= 10 ? (z(t3, 17, t3.bl_tree), x2(t3, o2 - 3, 3)) : (z(t3, 18, t3.bl_tree), x2(t3, o2 - 11, 7));
          o2 = 0, r3 = i3, 0 === s3 ? (l2 = 138, h3 = 3) : i3 === s3 ? (l2 = 6, h3 = 3) : (l2 = 7, h3 = 4);
        }
      }, F2 = false, L = function(t3, e3, a2, n2) {
        x2(t3, 0 + (n2 ? 1 : 0), 3), Z2(t3), y(t3, a2), y(t3, ~a2), a2 && t3.pending_buf.set(t3.window.subarray(e3, e3 + a2), t3.pending), t3.pending += a2;
      }, N = function(t3, e3, n2, i3) {
        var r3, s3, o2 = 0;
        t3.level > 0 ? (2 === t3.strm.data_type && (t3.strm.data_type = (function(t4) {
          var e4, n3 = 4093624447;
          for (e4 = 0; e4 <= 31; e4++, n3 >>>= 1) if (1 & n3 && 0 !== t4.dyn_ltree[2 * e4]) return 0;
          if (0 !== t4.dyn_ltree[18] || 0 !== t4.dyn_ltree[20] || 0 !== t4.dyn_ltree[26]) return 1;
          for (e4 = 32; e4 < a; e4++) if (0 !== t4.dyn_ltree[2 * e4]) return 1;
          return 0;
        })(t3)), T(t3, t3.l_desc), T(t3, t3.d_desc), o2 = (function(t4) {
          var e4;
          for (O(t4, t4.dyn_ltree, t4.l_desc.max_code), O(t4, t4.dyn_dtree, t4.d_desc.max_code), T(t4, t4.bl_desc), e4 = 18; e4 >= 3 && 0 === t4.bl_tree[2 * h2[e4] + 1]; e4--) ;
          return t4.opt_len += 3 * (e4 + 1) + 5 + 5 + 4, e4;
        })(t3), r3 = t3.opt_len + 3 + 7 >>> 3, (s3 = t3.static_len + 3 + 7 >>> 3) <= r3 && (r3 = s3)) : r3 = s3 = n2 + 5, n2 + 4 <= r3 && -1 !== e3 ? L(t3, e3, n2, i3) : 4 === t3.strategy || s3 === r3 ? (x2(t3, 2 + (i3 ? 1 : 0), 3), D(t3, d, _)) : (x2(t3, 4 + (i3 ? 1 : 0), 3), (function(t4, e4, a2, n3) {
          var i4;
          for (x2(t4, e4 - 257, 5), x2(t4, a2 - 1, 5), x2(t4, n3 - 4, 4), i4 = 0; i4 < n3; i4++) x2(t4, t4.bl_tree[2 * h2[i4] + 1], 3);
          I(t4, t4.dyn_ltree, e4 - 1), I(t4, t4.dyn_dtree, a2 - 1);
        })(t3, t3.l_desc.max_code + 1, t3.d_desc.max_code + 1, o2 + 1), D(t3, t3.dyn_ltree, t3.dyn_dtree)), R(t3), i3 && Z2(t3);
      }, B = { _tr_init: function(t3) {
        F2 || (!(function() {
          var t4, e3, a2, h3, v2, k2 = new Array(16);
          for (a2 = 0, h3 = 0; h3 < 28; h3++) for (c[h3] = a2, t4 = 0; t4 < 1 << s2[h3]; t4++) u[a2++] = h3;
          for (u[a2 - 1] = h3, v2 = 0, h3 = 0; h3 < 16; h3++) for (g[h3] = v2, t4 = 0; t4 < 1 << o[h3]; t4++) f3[v2++] = h3;
          for (v2 >>= 7; h3 < i2; h3++) for (g[h3] = v2 << 7, t4 = 0; t4 < 1 << o[h3] - 7; t4++) f3[256 + v2++] = h3;
          for (e3 = 0; e3 <= r2; e3++) k2[e3] = 0;
          for (t4 = 0; t4 <= 143; ) d[2 * t4 + 1] = 8, t4++, k2[8]++;
          for (; t4 <= 255; ) d[2 * t4 + 1] = 9, t4++, k2[9]++;
          for (; t4 <= 279; ) d[2 * t4 + 1] = 7, t4++, k2[7]++;
          for (; t4 <= 287; ) d[2 * t4 + 1] = 8, t4++, k2[8]++;
          for (E(d, 287, k2), t4 = 0; t4 < i2; t4++) _[2 * t4 + 1] = 5, _[2 * t4] = A2(t4, 5);
          w = new p(d, s2, 257, n, r2), m2 = new p(_, o, 0, i2, r2), b = new p(new Array(0), l, 0, 19, 7);
        })(), F2 = true), t3.l_desc = new v(t3.dyn_ltree, w), t3.d_desc = new v(t3.dyn_dtree, m2), t3.bl_desc = new v(t3.bl_tree, b), t3.bi_buf = 0, t3.bi_valid = 0, R(t3);
      }, _tr_stored_block: L, _tr_flush_block: N, _tr_tally: function(t3, e3, n2) {
        return t3.pending_buf[t3.sym_buf + t3.sym_next++] = e3, t3.pending_buf[t3.sym_buf + t3.sym_next++] = e3 >> 8, t3.pending_buf[t3.sym_buf + t3.sym_next++] = n2, 0 === e3 ? t3.dyn_ltree[2 * n2]++ : (t3.matches++, e3--, t3.dyn_ltree[2 * (u[n2] + a + 1)]++, t3.dyn_dtree[2 * k(e3)]++), t3.sym_next === t3.sym_end;
      }, _tr_align: function(t3) {
        x2(t3, 2, 3), z(t3, 256, d), (function(t4) {
          16 === t4.bi_valid ? (y(t4, t4.bi_buf), t4.bi_buf = 0, t4.bi_valid = 0) : t4.bi_valid >= 8 && (t4.pending_buf[t4.pending++] = 255 & t4.bi_buf, t4.bi_buf >>= 8, t4.bi_valid -= 8);
        })(t3);
      } }, C = function(t3, e3, a2, n2) {
        for (var i3 = 65535 & t3 | 0, r3 = t3 >>> 16 & 65535 | 0, s3 = 0; 0 !== a2; ) {
          a2 -= s3 = a2 > 2e3 ? 2e3 : a2;
          do {
            r3 = r3 + (i3 = i3 + e3[n2++] | 0) | 0;
          } while (--s3);
          i3 %= 65521, r3 %= 65521;
        }
        return i3 | r3 << 16 | 0;
      }, M = new Uint32Array((function() {
        for (var t3, e3 = [], a2 = 0; a2 < 256; a2++) {
          t3 = a2;
          for (var n2 = 0; n2 < 8; n2++) t3 = 1 & t3 ? 3988292384 ^ t3 >>> 1 : t3 >>> 1;
          e3[a2] = t3;
        }
        return e3;
      })()), H = function(t3, e3, a2, n2) {
        var i3 = M, r3 = n2 + a2;
        t3 ^= -1;
        for (var s3 = n2; s3 < r3; s3++) t3 = t3 >>> 8 ^ i3[255 & (t3 ^ e3[s3])];
        return -1 ^ t3;
      }, j = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, K = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }, P = B._tr_init, Y = B._tr_stored_block, G = B._tr_flush_block, X = B._tr_tally, W = B._tr_align, q = K.Z_NO_FLUSH, J = K.Z_PARTIAL_FLUSH, Q = K.Z_FULL_FLUSH, V = K.Z_FINISH, $ = K.Z_BLOCK, tt = K.Z_OK, et = K.Z_STREAM_END, at = K.Z_STREAM_ERROR, nt = K.Z_DATA_ERROR, it = K.Z_BUF_ERROR, rt = K.Z_DEFAULT_COMPRESSION, st = K.Z_FILTERED, ot = K.Z_HUFFMAN_ONLY, lt = K.Z_RLE, ht = K.Z_FIXED, dt = K.Z_DEFAULT_STRATEGY, _t = K.Z_UNKNOWN, ft = K.Z_DEFLATED, ut = 258, ct = 262, wt = 42, mt = 113, bt = 666, gt = function(t3, e3) {
        return t3.msg = j[e3], e3;
      }, pt = function(t3) {
        return 2 * t3 - (t3 > 4 ? 9 : 0);
      }, vt = function(t3) {
        for (var e3 = t3.length; --e3 >= 0; ) t3[e3] = 0;
      }, kt = function(t3) {
        var e3, a2, n2, i3 = t3.w_size;
        n2 = e3 = t3.hash_size;
        do {
          a2 = t3.head[--n2], t3.head[n2] = a2 >= i3 ? a2 - i3 : 0;
        } while (--e3);
        n2 = e3 = i3;
        do {
          a2 = t3.prev[--n2], t3.prev[n2] = a2 >= i3 ? a2 - i3 : 0;
        } while (--e3);
      }, yt = function(t3, e3, a2) {
        return (e3 << t3.hash_shift ^ a2) & t3.hash_mask;
      }, xt = function(t3) {
        var e3 = t3.state, a2 = e3.pending;
        a2 > t3.avail_out && (a2 = t3.avail_out), 0 !== a2 && (t3.output.set(e3.pending_buf.subarray(e3.pending_out, e3.pending_out + a2), t3.next_out), t3.next_out += a2, e3.pending_out += a2, t3.total_out += a2, t3.avail_out -= a2, e3.pending -= a2, 0 === e3.pending && (e3.pending_out = 0));
      }, zt = function(t3, e3) {
        G(t3, t3.block_start >= 0 ? t3.block_start : -1, t3.strstart - t3.block_start, e3), t3.block_start = t3.strstart, xt(t3.strm);
      }, At = function(t3, e3) {
        t3.pending_buf[t3.pending++] = e3;
      }, Et = function(t3, e3) {
        t3.pending_buf[t3.pending++] = e3 >>> 8 & 255, t3.pending_buf[t3.pending++] = 255 & e3;
      }, Rt = function(t3, e3, a2, n2) {
        var i3 = t3.avail_in;
        return i3 > n2 && (i3 = n2), 0 === i3 ? 0 : (t3.avail_in -= i3, e3.set(t3.input.subarray(t3.next_in, t3.next_in + i3), a2), 1 === t3.state.wrap ? t3.adler = C(t3.adler, e3, i3, a2) : 2 === t3.state.wrap && (t3.adler = H(t3.adler, e3, i3, a2)), t3.next_in += i3, t3.total_in += i3, i3);
      }, Zt = function(t3, e3) {
        var a2, n2, i3 = t3.max_chain_length, r3 = t3.strstart, s3 = t3.prev_length, o2 = t3.nice_match, l2 = t3.strstart > t3.w_size - ct ? t3.strstart - (t3.w_size - ct) : 0, h3 = t3.window, d2 = t3.w_mask, _2 = t3.prev, f4 = t3.strstart + ut, u2 = h3[r3 + s3 - 1], c2 = h3[r3 + s3];
        t3.prev_length >= t3.good_match && (i3 >>= 2), o2 > t3.lookahead && (o2 = t3.lookahead);
        do {
          if (h3[(a2 = e3) + s3] === c2 && h3[a2 + s3 - 1] === u2 && h3[a2] === h3[r3] && h3[++a2] === h3[r3 + 1]) {
            r3 += 2, a2++;
            do {
            } while (h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && h3[++r3] === h3[++a2] && r3 < f4);
            if (n2 = ut - (f4 - r3), r3 = f4 - ut, n2 > s3) {
              if (t3.match_start = e3, s3 = n2, n2 >= o2) break;
              u2 = h3[r3 + s3 - 1], c2 = h3[r3 + s3];
            }
          }
        } while ((e3 = _2[e3 & d2]) > l2 && 0 != --i3);
        return s3 <= t3.lookahead ? s3 : t3.lookahead;
      }, St = function(t3) {
        var e3, a2, n2, i3 = t3.w_size;
        do {
          if (a2 = t3.window_size - t3.lookahead - t3.strstart, t3.strstart >= i3 + (i3 - ct) && (t3.window.set(t3.window.subarray(i3, i3 + i3 - a2), 0), t3.match_start -= i3, t3.strstart -= i3, t3.block_start -= i3, t3.insert > t3.strstart && (t3.insert = t3.strstart), kt(t3), a2 += i3), 0 === t3.strm.avail_in) break;
          if (e3 = Rt(t3.strm, t3.window, t3.strstart + t3.lookahead, a2), t3.lookahead += e3, t3.lookahead + t3.insert >= 3) for (n2 = t3.strstart - t3.insert, t3.ins_h = t3.window[n2], t3.ins_h = yt(t3, t3.ins_h, t3.window[n2 + 1]); t3.insert && (t3.ins_h = yt(t3, t3.ins_h, t3.window[n2 + 3 - 1]), t3.prev[n2 & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = n2, n2++, t3.insert--, !(t3.lookahead + t3.insert < 3)); ) ;
        } while (t3.lookahead < ct && 0 !== t3.strm.avail_in);
      }, Ut = function(t3, e3) {
        var a2, n2, i3, r3 = t3.pending_buf_size - 5 > t3.w_size ? t3.w_size : t3.pending_buf_size - 5, s3 = 0, o2 = t3.strm.avail_in;
        do {
          if (a2 = 65535, i3 = t3.bi_valid + 42 >> 3, t3.strm.avail_out < i3) break;
          if (i3 = t3.strm.avail_out - i3, a2 > (n2 = t3.strstart - t3.block_start) + t3.strm.avail_in && (a2 = n2 + t3.strm.avail_in), a2 > i3 && (a2 = i3), a2 < r3 && (0 === a2 && e3 !== V || e3 === q || a2 !== n2 + t3.strm.avail_in)) break;
          s3 = e3 === V && a2 === n2 + t3.strm.avail_in ? 1 : 0, Y(t3, 0, 0, s3), t3.pending_buf[t3.pending - 4] = a2, t3.pending_buf[t3.pending - 3] = a2 >> 8, t3.pending_buf[t3.pending - 2] = ~a2, t3.pending_buf[t3.pending - 1] = ~a2 >> 8, xt(t3.strm), n2 && (n2 > a2 && (n2 = a2), t3.strm.output.set(t3.window.subarray(t3.block_start, t3.block_start + n2), t3.strm.next_out), t3.strm.next_out += n2, t3.strm.avail_out -= n2, t3.strm.total_out += n2, t3.block_start += n2, a2 -= n2), a2 && (Rt(t3.strm, t3.strm.output, t3.strm.next_out, a2), t3.strm.next_out += a2, t3.strm.avail_out -= a2, t3.strm.total_out += a2);
        } while (0 === s3);
        return (o2 -= t3.strm.avail_in) && (o2 >= t3.w_size ? (t3.matches = 2, t3.window.set(t3.strm.input.subarray(t3.strm.next_in - t3.w_size, t3.strm.next_in), 0), t3.strstart = t3.w_size, t3.insert = t3.strstart) : (t3.window_size - t3.strstart <= o2 && (t3.strstart -= t3.w_size, t3.window.set(t3.window.subarray(t3.w_size, t3.w_size + t3.strstart), 0), t3.matches < 2 && t3.matches++, t3.insert > t3.strstart && (t3.insert = t3.strstart)), t3.window.set(t3.strm.input.subarray(t3.strm.next_in - o2, t3.strm.next_in), t3.strstart), t3.strstart += o2, t3.insert += o2 > t3.w_size - t3.insert ? t3.w_size - t3.insert : o2), t3.block_start = t3.strstart), t3.high_water < t3.strstart && (t3.high_water = t3.strstart), s3 ? 4 : e3 !== q && e3 !== V && 0 === t3.strm.avail_in && t3.strstart === t3.block_start ? 2 : (i3 = t3.window_size - t3.strstart, t3.strm.avail_in > i3 && t3.block_start >= t3.w_size && (t3.block_start -= t3.w_size, t3.strstart -= t3.w_size, t3.window.set(t3.window.subarray(t3.w_size, t3.w_size + t3.strstart), 0), t3.matches < 2 && t3.matches++, i3 += t3.w_size, t3.insert > t3.strstart && (t3.insert = t3.strstart)), i3 > t3.strm.avail_in && (i3 = t3.strm.avail_in), i3 && (Rt(t3.strm, t3.window, t3.strstart, i3), t3.strstart += i3, t3.insert += i3 > t3.w_size - t3.insert ? t3.w_size - t3.insert : i3), t3.high_water < t3.strstart && (t3.high_water = t3.strstart), i3 = t3.bi_valid + 42 >> 3, r3 = (i3 = t3.pending_buf_size - i3 > 65535 ? 65535 : t3.pending_buf_size - i3) > t3.w_size ? t3.w_size : i3, ((n2 = t3.strstart - t3.block_start) >= r3 || (n2 || e3 === V) && e3 !== q && 0 === t3.strm.avail_in && n2 <= i3) && (a2 = n2 > i3 ? i3 : n2, s3 = e3 === V && 0 === t3.strm.avail_in && a2 === n2 ? 1 : 0, Y(t3, t3.block_start, a2, s3), t3.block_start += a2, xt(t3.strm)), s3 ? 3 : 1);
      }, Dt = function(t3, e3) {
        for (var a2, n2; ; ) {
          if (t3.lookahead < ct) {
            if (St(t3), t3.lookahead < ct && e3 === q) return 1;
            if (0 === t3.lookahead) break;
          }
          if (a2 = 0, t3.lookahead >= 3 && (t3.ins_h = yt(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), a2 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), 0 !== a2 && t3.strstart - a2 <= t3.w_size - ct && (t3.match_length = Zt(t3, a2)), t3.match_length >= 3) if (n2 = X(t3, t3.strstart - t3.match_start, t3.match_length - 3), t3.lookahead -= t3.match_length, t3.match_length <= t3.max_lazy_match && t3.lookahead >= 3) {
            t3.match_length--;
            do {
              t3.strstart++, t3.ins_h = yt(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), a2 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart;
            } while (0 != --t3.match_length);
            t3.strstart++;
          } else t3.strstart += t3.match_length, t3.match_length = 0, t3.ins_h = t3.window[t3.strstart], t3.ins_h = yt(t3, t3.ins_h, t3.window[t3.strstart + 1]);
          else n2 = X(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++;
          if (n2 && (zt(t3, false), 0 === t3.strm.avail_out)) return 1;
        }
        return t3.insert = t3.strstart < 2 ? t3.strstart : 2, e3 === V ? (zt(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.sym_next && (zt(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
      }, Tt = function(t3, e3) {
        for (var a2, n2, i3; ; ) {
          if (t3.lookahead < ct) {
            if (St(t3), t3.lookahead < ct && e3 === q) return 1;
            if (0 === t3.lookahead) break;
          }
          if (a2 = 0, t3.lookahead >= 3 && (t3.ins_h = yt(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), a2 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), t3.prev_length = t3.match_length, t3.prev_match = t3.match_start, t3.match_length = 2, 0 !== a2 && t3.prev_length < t3.max_lazy_match && t3.strstart - a2 <= t3.w_size - ct && (t3.match_length = Zt(t3, a2), t3.match_length <= 5 && (t3.strategy === st || 3 === t3.match_length && t3.strstart - t3.match_start > 4096) && (t3.match_length = 2)), t3.prev_length >= 3 && t3.match_length <= t3.prev_length) {
            i3 = t3.strstart + t3.lookahead - 3, n2 = X(t3, t3.strstart - 1 - t3.prev_match, t3.prev_length - 3), t3.lookahead -= t3.prev_length - 1, t3.prev_length -= 2;
            do {
              ++t3.strstart <= i3 && (t3.ins_h = yt(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), a2 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart);
            } while (0 != --t3.prev_length);
            if (t3.match_available = 0, t3.match_length = 2, t3.strstart++, n2 && (zt(t3, false), 0 === t3.strm.avail_out)) return 1;
          } else if (t3.match_available) {
            if ((n2 = X(t3, 0, t3.window[t3.strstart - 1])) && zt(t3, false), t3.strstart++, t3.lookahead--, 0 === t3.strm.avail_out) return 1;
          } else t3.match_available = 1, t3.strstart++, t3.lookahead--;
        }
        return t3.match_available && (n2 = X(t3, 0, t3.window[t3.strstart - 1]), t3.match_available = 0), t3.insert = t3.strstart < 2 ? t3.strstart : 2, e3 === V ? (zt(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.sym_next && (zt(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
      };
      function Ot(t3, e3, a2, n2, i3) {
        this.good_length = t3, this.max_lazy = e3, this.nice_length = a2, this.max_chain = n2, this.func = i3;
      }
      var It = [new Ot(0, 0, 0, 0, Ut), new Ot(4, 4, 8, 4, Dt), new Ot(4, 5, 16, 8, Dt), new Ot(4, 6, 32, 32, Dt), new Ot(4, 4, 16, 16, Tt), new Ot(8, 16, 32, 32, Tt), new Ot(8, 16, 128, 128, Tt), new Ot(8, 32, 128, 256, Tt), new Ot(32, 128, 258, 1024, Tt), new Ot(32, 258, 258, 4096, Tt)];
      function Ft() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ft, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), vt(this.dyn_ltree), vt(this.dyn_dtree), vt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), vt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), vt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      var Lt = function(t3) {
        if (!t3) return 1;
        var e3 = t3.state;
        return !e3 || e3.strm !== t3 || e3.status !== wt && 57 !== e3.status && 69 !== e3.status && 73 !== e3.status && 91 !== e3.status && 103 !== e3.status && e3.status !== mt && e3.status !== bt ? 1 : 0;
      }, Nt = function(t3) {
        if (Lt(t3)) return gt(t3, at);
        t3.total_in = t3.total_out = 0, t3.data_type = _t;
        var e3 = t3.state;
        return e3.pending = 0, e3.pending_out = 0, e3.wrap < 0 && (e3.wrap = -e3.wrap), e3.status = 2 === e3.wrap ? 57 : e3.wrap ? wt : mt, t3.adler = 2 === e3.wrap ? 0 : 1, e3.last_flush = -2, P(e3), tt;
      }, Bt = function(t3) {
        var e3, a2 = Nt(t3);
        return a2 === tt && ((e3 = t3.state).window_size = 2 * e3.w_size, vt(e3.head), e3.max_lazy_match = It[e3.level].max_lazy, e3.good_match = It[e3.level].good_length, e3.nice_match = It[e3.level].nice_length, e3.max_chain_length = It[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = 2, e3.match_available = 0, e3.ins_h = 0), a2;
      }, Ct = function(t3, e3, a2, n2, i3, r3) {
        if (!t3) return at;
        var s3 = 1;
        if (e3 === rt && (e3 = 6), n2 < 0 ? (s3 = 0, n2 = -n2) : n2 > 15 && (s3 = 2, n2 -= 16), i3 < 1 || i3 > 9 || a2 !== ft || n2 < 8 || n2 > 15 || e3 < 0 || e3 > 9 || r3 < 0 || r3 > ht || 8 === n2 && 1 !== s3) return gt(t3, at);
        8 === n2 && (n2 = 9);
        var o2 = new Ft();
        return t3.state = o2, o2.strm = t3, o2.status = wt, o2.wrap = s3, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i3 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + 3 - 1) / 3), o2.window = new Uint8Array(2 * o2.w_size), o2.head = new Uint16Array(o2.hash_size), o2.prev = new Uint16Array(o2.w_size), o2.lit_bufsize = 1 << i3 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new Uint8Array(o2.pending_buf_size), o2.sym_buf = o2.lit_bufsize, o2.sym_end = 3 * (o2.lit_bufsize - 1), o2.level = e3, o2.strategy = r3, o2.method = a2, Bt(t3);
      }, Mt = { deflateInit: function(t3, e3) {
        return Ct(t3, e3, ft, 15, 8, dt);
      }, deflateInit2: Ct, deflateReset: Bt, deflateResetKeep: Nt, deflateSetHeader: function(t3, e3) {
        return Lt(t3) || 2 !== t3.state.wrap ? at : (t3.state.gzhead = e3, tt);
      }, deflate: function(t3, e3) {
        if (Lt(t3) || e3 > $ || e3 < 0) return t3 ? gt(t3, at) : at;
        var a2 = t3.state;
        if (!t3.output || 0 !== t3.avail_in && !t3.input || a2.status === bt && e3 !== V) return gt(t3, 0 === t3.avail_out ? it : at);
        var n2 = a2.last_flush;
        if (a2.last_flush = e3, 0 !== a2.pending) {
          if (xt(t3), 0 === t3.avail_out) return a2.last_flush = -1, tt;
        } else if (0 === t3.avail_in && pt(e3) <= pt(n2) && e3 !== V) return gt(t3, it);
        if (a2.status === bt && 0 !== t3.avail_in) return gt(t3, it);
        if (a2.status === wt && 0 === a2.wrap && (a2.status = mt), a2.status === wt) {
          var i3 = ft + (a2.w_bits - 8 << 4) << 8;
          if (i3 |= (a2.strategy >= ot || a2.level < 2 ? 0 : a2.level < 6 ? 1 : 6 === a2.level ? 2 : 3) << 6, 0 !== a2.strstart && (i3 |= 32), Et(a2, i3 += 31 - i3 % 31), 0 !== a2.strstart && (Et(a2, t3.adler >>> 16), Et(a2, 65535 & t3.adler)), t3.adler = 1, a2.status = mt, xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
        }
        if (57 === a2.status) {
          if (t3.adler = 0, At(a2, 31), At(a2, 139), At(a2, 8), a2.gzhead) At(a2, (a2.gzhead.text ? 1 : 0) + (a2.gzhead.hcrc ? 2 : 0) + (a2.gzhead.extra ? 4 : 0) + (a2.gzhead.name ? 8 : 0) + (a2.gzhead.comment ? 16 : 0)), At(a2, 255 & a2.gzhead.time), At(a2, a2.gzhead.time >> 8 & 255), At(a2, a2.gzhead.time >> 16 & 255), At(a2, a2.gzhead.time >> 24 & 255), At(a2, 9 === a2.level ? 2 : a2.strategy >= ot || a2.level < 2 ? 4 : 0), At(a2, 255 & a2.gzhead.os), a2.gzhead.extra && a2.gzhead.extra.length && (At(a2, 255 & a2.gzhead.extra.length), At(a2, a2.gzhead.extra.length >> 8 & 255)), a2.gzhead.hcrc && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending, 0)), a2.gzindex = 0, a2.status = 69;
          else if (At(a2, 0), At(a2, 0), At(a2, 0), At(a2, 0), At(a2, 0), At(a2, 9 === a2.level ? 2 : a2.strategy >= ot || a2.level < 2 ? 4 : 0), At(a2, 3), a2.status = mt, xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
        }
        if (69 === a2.status) {
          if (a2.gzhead.extra) {
            for (var r3 = a2.pending, s3 = (65535 & a2.gzhead.extra.length) - a2.gzindex; a2.pending + s3 > a2.pending_buf_size; ) {
              var o2 = a2.pending_buf_size - a2.pending;
              if (a2.pending_buf.set(a2.gzhead.extra.subarray(a2.gzindex, a2.gzindex + o2), a2.pending), a2.pending = a2.pending_buf_size, a2.gzhead.hcrc && a2.pending > r3 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - r3, r3)), a2.gzindex += o2, xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
              r3 = 0, s3 -= o2;
            }
            var l2 = new Uint8Array(a2.gzhead.extra);
            a2.pending_buf.set(l2.subarray(a2.gzindex, a2.gzindex + s3), a2.pending), a2.pending += s3, a2.gzhead.hcrc && a2.pending > r3 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - r3, r3)), a2.gzindex = 0;
          }
          a2.status = 73;
        }
        if (73 === a2.status) {
          if (a2.gzhead.name) {
            var h3, d2 = a2.pending;
            do {
              if (a2.pending === a2.pending_buf_size) {
                if (a2.gzhead.hcrc && a2.pending > d2 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - d2, d2)), xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
                d2 = 0;
              }
              h3 = a2.gzindex < a2.gzhead.name.length ? 255 & a2.gzhead.name.charCodeAt(a2.gzindex++) : 0, At(a2, h3);
            } while (0 !== h3);
            a2.gzhead.hcrc && a2.pending > d2 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - d2, d2)), a2.gzindex = 0;
          }
          a2.status = 91;
        }
        if (91 === a2.status) {
          if (a2.gzhead.comment) {
            var _2, f4 = a2.pending;
            do {
              if (a2.pending === a2.pending_buf_size) {
                if (a2.gzhead.hcrc && a2.pending > f4 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - f4, f4)), xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
                f4 = 0;
              }
              _2 = a2.gzindex < a2.gzhead.comment.length ? 255 & a2.gzhead.comment.charCodeAt(a2.gzindex++) : 0, At(a2, _2);
            } while (0 !== _2);
            a2.gzhead.hcrc && a2.pending > f4 && (t3.adler = H(t3.adler, a2.pending_buf, a2.pending - f4, f4));
          }
          a2.status = 103;
        }
        if (103 === a2.status) {
          if (a2.gzhead.hcrc) {
            if (a2.pending + 2 > a2.pending_buf_size && (xt(t3), 0 !== a2.pending)) return a2.last_flush = -1, tt;
            At(a2, 255 & t3.adler), At(a2, t3.adler >> 8 & 255), t3.adler = 0;
          }
          if (a2.status = mt, xt(t3), 0 !== a2.pending) return a2.last_flush = -1, tt;
        }
        if (0 !== t3.avail_in || 0 !== a2.lookahead || e3 !== q && a2.status !== bt) {
          var u2 = 0 === a2.level ? Ut(a2, e3) : a2.strategy === ot ? (function(t4, e4) {
            for (var a3; ; ) {
              if (0 === t4.lookahead && (St(t4), 0 === t4.lookahead)) {
                if (e4 === q) return 1;
                break;
              }
              if (t4.match_length = 0, a3 = X(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++, a3 && (zt(t4, false), 0 === t4.strm.avail_out)) return 1;
            }
            return t4.insert = 0, e4 === V ? (zt(t4, true), 0 === t4.strm.avail_out ? 3 : 4) : t4.sym_next && (zt(t4, false), 0 === t4.strm.avail_out) ? 1 : 2;
          })(a2, e3) : a2.strategy === lt ? (function(t4, e4) {
            for (var a3, n3, i4, r4, s4 = t4.window; ; ) {
              if (t4.lookahead <= ut) {
                if (St(t4), t4.lookahead <= ut && e4 === q) return 1;
                if (0 === t4.lookahead) break;
              }
              if (t4.match_length = 0, t4.lookahead >= 3 && t4.strstart > 0 && (n3 = s4[i4 = t4.strstart - 1]) === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4]) {
                r4 = t4.strstart + ut;
                do {
                } while (n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && n3 === s4[++i4] && i4 < r4);
                t4.match_length = ut - (r4 - i4), t4.match_length > t4.lookahead && (t4.match_length = t4.lookahead);
              }
              if (t4.match_length >= 3 ? (a3 = X(t4, 1, t4.match_length - 3), t4.lookahead -= t4.match_length, t4.strstart += t4.match_length, t4.match_length = 0) : (a3 = X(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++), a3 && (zt(t4, false), 0 === t4.strm.avail_out)) return 1;
            }
            return t4.insert = 0, e4 === V ? (zt(t4, true), 0 === t4.strm.avail_out ? 3 : 4) : t4.sym_next && (zt(t4, false), 0 === t4.strm.avail_out) ? 1 : 2;
          })(a2, e3) : It[a2.level].func(a2, e3);
          if (3 !== u2 && 4 !== u2 || (a2.status = bt), 1 === u2 || 3 === u2) return 0 === t3.avail_out && (a2.last_flush = -1), tt;
          if (2 === u2 && (e3 === J ? W(a2) : e3 !== $ && (Y(a2, 0, 0, false), e3 === Q && (vt(a2.head), 0 === a2.lookahead && (a2.strstart = 0, a2.block_start = 0, a2.insert = 0))), xt(t3), 0 === t3.avail_out)) return a2.last_flush = -1, tt;
        }
        return e3 !== V ? tt : a2.wrap <= 0 ? et : (2 === a2.wrap ? (At(a2, 255 & t3.adler), At(a2, t3.adler >> 8 & 255), At(a2, t3.adler >> 16 & 255), At(a2, t3.adler >> 24 & 255), At(a2, 255 & t3.total_in), At(a2, t3.total_in >> 8 & 255), At(a2, t3.total_in >> 16 & 255), At(a2, t3.total_in >> 24 & 255)) : (Et(a2, t3.adler >>> 16), Et(a2, 65535 & t3.adler)), xt(t3), a2.wrap > 0 && (a2.wrap = -a2.wrap), 0 !== a2.pending ? tt : et);
      }, deflateEnd: function(t3) {
        if (Lt(t3)) return at;
        var e3 = t3.state.status;
        return t3.state = null, e3 === mt ? gt(t3, nt) : tt;
      }, deflateSetDictionary: function(t3, e3) {
        var a2 = e3.length;
        if (Lt(t3)) return at;
        var n2 = t3.state, i3 = n2.wrap;
        if (2 === i3 || 1 === i3 && n2.status !== wt || n2.lookahead) return at;
        if (1 === i3 && (t3.adler = C(t3.adler, e3, a2, 0)), n2.wrap = 0, a2 >= n2.w_size) {
          0 === i3 && (vt(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
          var r3 = new Uint8Array(n2.w_size);
          r3.set(e3.subarray(a2 - n2.w_size, a2), 0), e3 = r3, a2 = n2.w_size;
        }
        var s3 = t3.avail_in, o2 = t3.next_in, l2 = t3.input;
        for (t3.avail_in = a2, t3.next_in = 0, t3.input = e3, St(n2); n2.lookahead >= 3; ) {
          var h3 = n2.strstart, d2 = n2.lookahead - 2;
          do {
            n2.ins_h = yt(n2, n2.ins_h, n2.window[h3 + 3 - 1]), n2.prev[h3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = h3, h3++;
          } while (--d2);
          n2.strstart = h3, n2.lookahead = 2, St(n2);
        }
        return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, t3.next_in = o2, t3.input = l2, t3.avail_in = s3, n2.wrap = i3, tt;
      }, deflateInfo: "pako deflate (from Nodeca project)" };
      function Ht(t3) {
        return Ht = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, Ht(t3);
      }
      var jt = function(t3, e3) {
        return Object.prototype.hasOwnProperty.call(t3, e3);
      }, Kt = function(t3) {
        for (var e3 = Array.prototype.slice.call(arguments, 1); e3.length; ) {
          var a2 = e3.shift();
          if (a2) {
            if ("object" !== Ht(a2)) throw new TypeError(a2 + "must be non-object");
            for (var n2 in a2) jt(a2, n2) && (t3[n2] = a2[n2]);
          }
        }
        return t3;
      }, Pt = function(t3) {
        for (var e3 = 0, a2 = 0, n2 = t3.length; a2 < n2; a2++) e3 += t3[a2].length;
        for (var i3 = new Uint8Array(e3), r3 = 0, s3 = 0, o2 = t3.length; r3 < o2; r3++) {
          var l2 = t3[r3];
          i3.set(l2, s3), s3 += l2.length;
        }
        return i3;
      }, Yt = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (t3) {
        Yt = false;
      }
      for (var Gt = new Uint8Array(256), Xt = 0; Xt < 256; Xt++) Gt[Xt] = Xt >= 252 ? 6 : Xt >= 248 ? 5 : Xt >= 240 ? 4 : Xt >= 224 ? 3 : Xt >= 192 ? 2 : 1;
      Gt[254] = Gt[254] = 1;
      var Wt = function(t3) {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t3);
        var e3, a2, n2, i3, r3, s3 = t3.length, o2 = 0;
        for (i3 = 0; i3 < s3; i3++) 55296 == (64512 & (a2 = t3.charCodeAt(i3))) && i3 + 1 < s3 && 56320 == (64512 & (n2 = t3.charCodeAt(i3 + 1))) && (a2 = 65536 + (a2 - 55296 << 10) + (n2 - 56320), i3++), o2 += a2 < 128 ? 1 : a2 < 2048 ? 2 : a2 < 65536 ? 3 : 4;
        for (e3 = new Uint8Array(o2), r3 = 0, i3 = 0; r3 < o2; i3++) 55296 == (64512 & (a2 = t3.charCodeAt(i3))) && i3 + 1 < s3 && 56320 == (64512 & (n2 = t3.charCodeAt(i3 + 1))) && (a2 = 65536 + (a2 - 55296 << 10) + (n2 - 56320), i3++), a2 < 128 ? e3[r3++] = a2 : a2 < 2048 ? (e3[r3++] = 192 | a2 >>> 6, e3[r3++] = 128 | 63 & a2) : a2 < 65536 ? (e3[r3++] = 224 | a2 >>> 12, e3[r3++] = 128 | a2 >>> 6 & 63, e3[r3++] = 128 | 63 & a2) : (e3[r3++] = 240 | a2 >>> 18, e3[r3++] = 128 | a2 >>> 12 & 63, e3[r3++] = 128 | a2 >>> 6 & 63, e3[r3++] = 128 | 63 & a2);
        return e3;
      }, qt = function(t3, e3) {
        var a2, n2, i3 = e3 || t3.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(t3.subarray(0, e3));
        var r3 = new Array(2 * i3);
        for (n2 = 0, a2 = 0; a2 < i3; ) {
          var s3 = t3[a2++];
          if (s3 < 128) r3[n2++] = s3;
          else {
            var o2 = Gt[s3];
            if (o2 > 4) r3[n2++] = 65533, a2 += o2 - 1;
            else {
              for (s3 &= 2 === o2 ? 31 : 3 === o2 ? 15 : 7; o2 > 1 && a2 < i3; ) s3 = s3 << 6 | 63 & t3[a2++], o2--;
              o2 > 1 ? r3[n2++] = 65533 : s3 < 65536 ? r3[n2++] = s3 : (s3 -= 65536, r3[n2++] = 55296 | s3 >> 10 & 1023, r3[n2++] = 56320 | 1023 & s3);
            }
          }
        }
        return (function(t4, e4) {
          if (e4 < 65534 && t4.subarray && Yt) return String.fromCharCode.apply(null, t4.length === e4 ? t4 : t4.subarray(0, e4));
          for (var a3 = "", n3 = 0; n3 < e4; n3++) a3 += String.fromCharCode(t4[n3]);
          return a3;
        })(r3, n2);
      }, Jt = function(t3, e3) {
        (e3 = e3 || t3.length) > t3.length && (e3 = t3.length);
        for (var a2 = e3 - 1; a2 >= 0 && 128 == (192 & t3[a2]); ) a2--;
        return a2 < 0 || 0 === a2 ? e3 : a2 + Gt[t3[a2]] > e3 ? a2 : e3;
      };
      var Qt = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }, Vt = Object.prototype.toString, $t = K.Z_NO_FLUSH, te = K.Z_SYNC_FLUSH, ee = K.Z_FULL_FLUSH, ae = K.Z_FINISH, ne = K.Z_OK, ie = K.Z_STREAM_END, re = K.Z_DEFAULT_COMPRESSION, se = K.Z_DEFAULT_STRATEGY, oe = K.Z_DEFLATED;
      function le(t3) {
        this.options = Kt({ level: re, method: oe, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: se }, t3 || {});
        var e3 = this.options;
        e3.raw && e3.windowBits > 0 ? e3.windowBits = -e3.windowBits : e3.gzip && e3.windowBits > 0 && e3.windowBits < 16 && (e3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Qt(), this.strm.avail_out = 0;
        var a2 = Mt.deflateInit2(this.strm, e3.level, e3.method, e3.windowBits, e3.memLevel, e3.strategy);
        if (a2 !== ne) throw new Error(j[a2]);
        if (e3.header && Mt.deflateSetHeader(this.strm, e3.header), e3.dictionary) {
          var n2;
          if (n2 = "string" == typeof e3.dictionary ? Wt(e3.dictionary) : "[object ArrayBuffer]" === Vt.call(e3.dictionary) ? new Uint8Array(e3.dictionary) : e3.dictionary, (a2 = Mt.deflateSetDictionary(this.strm, n2)) !== ne) throw new Error(j[a2]);
          this._dict_set = true;
        }
      }
      function he(t3, e3) {
        var a2 = new le(e3);
        if (a2.push(t3, true), a2.err) throw a2.msg || j[a2.err];
        return a2.result;
      }
      le.prototype.push = function(t3, e3) {
        var a2, n2, i3 = this.strm, r3 = this.options.chunkSize;
        if (this.ended) return false;
        for (n2 = e3 === ~~e3 ? e3 : true === e3 ? ae : $t, "string" == typeof t3 ? i3.input = Wt(t3) : "[object ArrayBuffer]" === Vt.call(t3) ? i3.input = new Uint8Array(t3) : i3.input = t3, i3.next_in = 0, i3.avail_in = i3.input.length; ; ) if (0 === i3.avail_out && (i3.output = new Uint8Array(r3), i3.next_out = 0, i3.avail_out = r3), (n2 === te || n2 === ee) && i3.avail_out <= 6) this.onData(i3.output.subarray(0, i3.next_out)), i3.avail_out = 0;
        else {
          if ((a2 = Mt.deflate(i3, n2)) === ie) return i3.next_out > 0 && this.onData(i3.output.subarray(0, i3.next_out)), a2 = Mt.deflateEnd(this.strm), this.onEnd(a2), this.ended = true, a2 === ne;
          if (0 !== i3.avail_out) {
            if (n2 > 0 && i3.next_out > 0) this.onData(i3.output.subarray(0, i3.next_out)), i3.avail_out = 0;
            else if (0 === i3.avail_in) break;
          } else this.onData(i3.output);
        }
        return true;
      }, le.prototype.onData = function(t3) {
        this.chunks.push(t3);
      }, le.prototype.onEnd = function(t3) {
        t3 === ne && (this.result = Pt(this.chunks)), this.chunks = [], this.err = t3, this.msg = this.strm.msg;
      };
      var de = { Deflate: le, deflate: he, deflateRaw: function(t3, e3) {
        return (e3 = e3 || {}).raw = true, he(t3, e3);
      }, gzip: function(t3, e3) {
        return (e3 = e3 || {}).gzip = true, he(t3, e3);
      }, constants: K }, _e = 16209, fe = function(t3, e3) {
        var a2, n2, i3, r3, s3, o2, l2, h3, d2, _2, f4, u2, c2, w2, m3, b2, g2, p2, v2, k2, y2, x3, z2, A3, E2 = t3.state;
        a2 = t3.next_in, z2 = t3.input, n2 = a2 + (t3.avail_in - 5), i3 = t3.next_out, A3 = t3.output, r3 = i3 - (e3 - t3.avail_out), s3 = i3 + (t3.avail_out - 257), o2 = E2.dmax, l2 = E2.wsize, h3 = E2.whave, d2 = E2.wnext, _2 = E2.window, f4 = E2.hold, u2 = E2.bits, c2 = E2.lencode, w2 = E2.distcode, m3 = (1 << E2.lenbits) - 1, b2 = (1 << E2.distbits) - 1;
        t: do {
          u2 < 15 && (f4 += z2[a2++] << u2, u2 += 8, f4 += z2[a2++] << u2, u2 += 8), g2 = c2[f4 & m3];
          e: for (; ; ) {
            if (f4 >>>= p2 = g2 >>> 24, u2 -= p2, 0 === (p2 = g2 >>> 16 & 255)) A3[i3++] = 65535 & g2;
            else {
              if (!(16 & p2)) {
                if (0 == (64 & p2)) {
                  g2 = c2[(65535 & g2) + (f4 & (1 << p2) - 1)];
                  continue e;
                }
                if (32 & p2) {
                  E2.mode = 16191;
                  break t;
                }
                t3.msg = "invalid literal/length code", E2.mode = _e;
                break t;
              }
              v2 = 65535 & g2, (p2 &= 15) && (u2 < p2 && (f4 += z2[a2++] << u2, u2 += 8), v2 += f4 & (1 << p2) - 1, f4 >>>= p2, u2 -= p2), u2 < 15 && (f4 += z2[a2++] << u2, u2 += 8, f4 += z2[a2++] << u2, u2 += 8), g2 = w2[f4 & b2];
              a: for (; ; ) {
                if (f4 >>>= p2 = g2 >>> 24, u2 -= p2, !(16 & (p2 = g2 >>> 16 & 255))) {
                  if (0 == (64 & p2)) {
                    g2 = w2[(65535 & g2) + (f4 & (1 << p2) - 1)];
                    continue a;
                  }
                  t3.msg = "invalid distance code", E2.mode = _e;
                  break t;
                }
                if (k2 = 65535 & g2, u2 < (p2 &= 15) && (f4 += z2[a2++] << u2, (u2 += 8) < p2 && (f4 += z2[a2++] << u2, u2 += 8)), (k2 += f4 & (1 << p2) - 1) > o2) {
                  t3.msg = "invalid distance too far back", E2.mode = _e;
                  break t;
                }
                if (f4 >>>= p2, u2 -= p2, k2 > (p2 = i3 - r3)) {
                  if ((p2 = k2 - p2) > h3 && E2.sane) {
                    t3.msg = "invalid distance too far back", E2.mode = _e;
                    break t;
                  }
                  if (y2 = 0, x3 = _2, 0 === d2) {
                    if (y2 += l2 - p2, p2 < v2) {
                      v2 -= p2;
                      do {
                        A3[i3++] = _2[y2++];
                      } while (--p2);
                      y2 = i3 - k2, x3 = A3;
                    }
                  } else if (d2 < p2) {
                    if (y2 += l2 + d2 - p2, (p2 -= d2) < v2) {
                      v2 -= p2;
                      do {
                        A3[i3++] = _2[y2++];
                      } while (--p2);
                      if (y2 = 0, d2 < v2) {
                        v2 -= p2 = d2;
                        do {
                          A3[i3++] = _2[y2++];
                        } while (--p2);
                        y2 = i3 - k2, x3 = A3;
                      }
                    }
                  } else if (y2 += d2 - p2, p2 < v2) {
                    v2 -= p2;
                    do {
                      A3[i3++] = _2[y2++];
                    } while (--p2);
                    y2 = i3 - k2, x3 = A3;
                  }
                  for (; v2 > 2; ) A3[i3++] = x3[y2++], A3[i3++] = x3[y2++], A3[i3++] = x3[y2++], v2 -= 3;
                  v2 && (A3[i3++] = x3[y2++], v2 > 1 && (A3[i3++] = x3[y2++]));
                } else {
                  y2 = i3 - k2;
                  do {
                    A3[i3++] = A3[y2++], A3[i3++] = A3[y2++], A3[i3++] = A3[y2++], v2 -= 3;
                  } while (v2 > 2);
                  v2 && (A3[i3++] = A3[y2++], v2 > 1 && (A3[i3++] = A3[y2++]));
                }
                break;
              }
            }
            break;
          }
        } while (a2 < n2 && i3 < s3);
        a2 -= v2 = u2 >> 3, f4 &= (1 << (u2 -= v2 << 3)) - 1, t3.next_in = a2, t3.next_out = i3, t3.avail_in = a2 < n2 ? n2 - a2 + 5 : 5 - (a2 - n2), t3.avail_out = i3 < s3 ? s3 - i3 + 257 : 257 - (i3 - s3), E2.hold = f4, E2.bits = u2;
      }, ue = 15, ce = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), we = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), me = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), be = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]), ge = function(t3, e3, a2, n2, i3, r3, s3, o2) {
        var l2, h3, d2, _2, f4, u2, c2, w2, m3, b2 = o2.bits, g2 = 0, p2 = 0, v2 = 0, k2 = 0, y2 = 0, x3 = 0, z2 = 0, A3 = 0, E2 = 0, R2 = 0, Z3 = null, S3 = new Uint16Array(16), U2 = new Uint16Array(16), D2 = null;
        for (g2 = 0; g2 <= ue; g2++) S3[g2] = 0;
        for (p2 = 0; p2 < n2; p2++) S3[e3[a2 + p2]]++;
        for (y2 = b2, k2 = ue; k2 >= 1 && 0 === S3[k2]; k2--) ;
        if (y2 > k2 && (y2 = k2), 0 === k2) return i3[r3++] = 20971520, i3[r3++] = 20971520, o2.bits = 1, 0;
        for (v2 = 1; v2 < k2 && 0 === S3[v2]; v2++) ;
        for (y2 < v2 && (y2 = v2), A3 = 1, g2 = 1; g2 <= ue; g2++) if (A3 <<= 1, (A3 -= S3[g2]) < 0) return -1;
        if (A3 > 0 && (0 === t3 || 1 !== k2)) return -1;
        for (U2[1] = 0, g2 = 1; g2 < ue; g2++) U2[g2 + 1] = U2[g2] + S3[g2];
        for (p2 = 0; p2 < n2; p2++) 0 !== e3[a2 + p2] && (s3[U2[e3[a2 + p2]]++] = p2);
        if (0 === t3 ? (Z3 = D2 = s3, u2 = 20) : 1 === t3 ? (Z3 = ce, D2 = we, u2 = 257) : (Z3 = me, D2 = be, u2 = 0), R2 = 0, p2 = 0, g2 = v2, f4 = r3, x3 = y2, z2 = 0, d2 = -1, _2 = (E2 = 1 << y2) - 1, 1 === t3 && E2 > 852 || 2 === t3 && E2 > 592) return 1;
        for (; ; ) {
          c2 = g2 - z2, s3[p2] + 1 < u2 ? (w2 = 0, m3 = s3[p2]) : s3[p2] >= u2 ? (w2 = D2[s3[p2] - u2], m3 = Z3[s3[p2] - u2]) : (w2 = 96, m3 = 0), l2 = 1 << g2 - z2, v2 = h3 = 1 << x3;
          do {
            i3[f4 + (R2 >> z2) + (h3 -= l2)] = c2 << 24 | w2 << 16 | m3 | 0;
          } while (0 !== h3);
          for (l2 = 1 << g2 - 1; R2 & l2; ) l2 >>= 1;
          if (0 !== l2 ? (R2 &= l2 - 1, R2 += l2) : R2 = 0, p2++, 0 == --S3[g2]) {
            if (g2 === k2) break;
            g2 = e3[a2 + s3[p2]];
          }
          if (g2 > y2 && (R2 & _2) !== d2) {
            for (0 === z2 && (z2 = y2), f4 += v2, A3 = 1 << (x3 = g2 - z2); x3 + z2 < k2 && !((A3 -= S3[x3 + z2]) <= 0); ) x3++, A3 <<= 1;
            if (E2 += 1 << x3, 1 === t3 && E2 > 852 || 2 === t3 && E2 > 592) return 1;
            i3[d2 = R2 & _2] = y2 << 24 | x3 << 16 | f4 - r3 | 0;
          }
        }
        return 0 !== R2 && (i3[f4 + R2] = g2 - z2 << 24 | 64 << 16 | 0), o2.bits = y2, 0;
      }, pe = K.Z_FINISH, ve = K.Z_BLOCK, ke = K.Z_TREES, ye = K.Z_OK, xe = K.Z_STREAM_END, ze = K.Z_NEED_DICT, Ae = K.Z_STREAM_ERROR, Ee = K.Z_DATA_ERROR, Re = K.Z_MEM_ERROR, Ze = K.Z_BUF_ERROR, Se = K.Z_DEFLATED, Ue = 16180, De = 16190, Te = 16191, Oe = 16192, Ie = 16194, Fe = 16199, Le = 16200, Ne = 16206, Be = 16209, Ce = function(t3) {
        return (t3 >>> 24 & 255) + (t3 >>> 8 & 65280) + ((65280 & t3) << 8) + ((255 & t3) << 24);
      };
      function Me() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      var He, je, Ke = function(t3) {
        if (!t3) return 1;
        var e3 = t3.state;
        return !e3 || e3.strm !== t3 || e3.mode < Ue || e3.mode > 16211 ? 1 : 0;
      }, Pe = function(t3) {
        if (Ke(t3)) return Ae;
        var e3 = t3.state;
        return t3.total_in = t3.total_out = e3.total = 0, t3.msg = "", e3.wrap && (t3.adler = 1 & e3.wrap), e3.mode = Ue, e3.last = 0, e3.havedict = 0, e3.flags = -1, e3.dmax = 32768, e3.head = null, e3.hold = 0, e3.bits = 0, e3.lencode = e3.lendyn = new Int32Array(852), e3.distcode = e3.distdyn = new Int32Array(592), e3.sane = 1, e3.back = -1, ye;
      }, Ye = function(t3) {
        if (Ke(t3)) return Ae;
        var e3 = t3.state;
        return e3.wsize = 0, e3.whave = 0, e3.wnext = 0, Pe(t3);
      }, Ge = function(t3, e3) {
        var a2;
        if (Ke(t3)) return Ae;
        var n2 = t3.state;
        return e3 < 0 ? (a2 = 0, e3 = -e3) : (a2 = 5 + (e3 >> 4), e3 < 48 && (e3 &= 15)), e3 && (e3 < 8 || e3 > 15) ? Ae : (null !== n2.window && n2.wbits !== e3 && (n2.window = null), n2.wrap = a2, n2.wbits = e3, Ye(t3));
      }, Xe = function(t3, e3) {
        if (!t3) return Ae;
        var a2 = new Me();
        t3.state = a2, a2.strm = t3, a2.window = null, a2.mode = Ue;
        var n2 = Ge(t3, e3);
        return n2 !== ye && (t3.state = null), n2;
      }, We = true, qe = function(t3) {
        if (We) {
          He = new Int32Array(512), je = new Int32Array(32);
          for (var e3 = 0; e3 < 144; ) t3.lens[e3++] = 8;
          for (; e3 < 256; ) t3.lens[e3++] = 9;
          for (; e3 < 280; ) t3.lens[e3++] = 7;
          for (; e3 < 288; ) t3.lens[e3++] = 8;
          for (ge(1, t3.lens, 0, 288, He, 0, t3.work, { bits: 9 }), e3 = 0; e3 < 32; ) t3.lens[e3++] = 5;
          ge(2, t3.lens, 0, 32, je, 0, t3.work, { bits: 5 }), We = false;
        }
        t3.lencode = He, t3.lenbits = 9, t3.distcode = je, t3.distbits = 5;
      }, Je = function(t3, e3, a2, n2) {
        var i3, r3 = t3.state;
        return null === r3.window && (r3.wsize = 1 << r3.wbits, r3.wnext = 0, r3.whave = 0, r3.window = new Uint8Array(r3.wsize)), n2 >= r3.wsize ? (r3.window.set(e3.subarray(a2 - r3.wsize, a2), 0), r3.wnext = 0, r3.whave = r3.wsize) : ((i3 = r3.wsize - r3.wnext) > n2 && (i3 = n2), r3.window.set(e3.subarray(a2 - n2, a2 - n2 + i3), r3.wnext), (n2 -= i3) ? (r3.window.set(e3.subarray(a2 - n2, a2), 0), r3.wnext = n2, r3.whave = r3.wsize) : (r3.wnext += i3, r3.wnext === r3.wsize && (r3.wnext = 0), r3.whave < r3.wsize && (r3.whave += i3))), 0;
      }, Qe = { inflateReset: Ye, inflateReset2: Ge, inflateResetKeep: Pe, inflateInit: function(t3) {
        return Xe(t3, 15);
      }, inflateInit2: Xe, inflate: function(t3, e3) {
        var a2, n2, i3, r3, s3, o2, l2, h3, d2, _2, f4, u2, c2, w2, m3, b2, g2, p2, v2, k2, y2, x3, z2, A3, E2 = 0, R2 = new Uint8Array(4), Z3 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (Ke(t3) || !t3.output || !t3.input && 0 !== t3.avail_in) return Ae;
        (a2 = t3.state).mode === Te && (a2.mode = Oe), s3 = t3.next_out, i3 = t3.output, l2 = t3.avail_out, r3 = t3.next_in, n2 = t3.input, o2 = t3.avail_in, h3 = a2.hold, d2 = a2.bits, _2 = o2, f4 = l2, x3 = ye;
        t: for (; ; ) switch (a2.mode) {
          case Ue:
            if (0 === a2.wrap) {
              a2.mode = Oe;
              break;
            }
            for (; d2 < 16; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if (2 & a2.wrap && 35615 === h3) {
              0 === a2.wbits && (a2.wbits = 15), a2.check = 0, R2[0] = 255 & h3, R2[1] = h3 >>> 8 & 255, a2.check = H(a2.check, R2, 2, 0), h3 = 0, d2 = 0, a2.mode = 16181;
              break;
            }
            if (a2.head && (a2.head.done = false), !(1 & a2.wrap) || (((255 & h3) << 8) + (h3 >> 8)) % 31) {
              t3.msg = "incorrect header check", a2.mode = Be;
              break;
            }
            if ((15 & h3) !== Se) {
              t3.msg = "unknown compression method", a2.mode = Be;
              break;
            }
            if (d2 -= 4, y2 = 8 + (15 & (h3 >>>= 4)), 0 === a2.wbits && (a2.wbits = y2), y2 > 15 || y2 > a2.wbits) {
              t3.msg = "invalid window size", a2.mode = Be;
              break;
            }
            a2.dmax = 1 << a2.wbits, a2.flags = 0, t3.adler = a2.check = 1, a2.mode = 512 & h3 ? 16189 : Te, h3 = 0, d2 = 0;
            break;
          case 16181:
            for (; d2 < 16; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if (a2.flags = h3, (255 & a2.flags) !== Se) {
              t3.msg = "unknown compression method", a2.mode = Be;
              break;
            }
            if (57344 & a2.flags) {
              t3.msg = "unknown header flags set", a2.mode = Be;
              break;
            }
            a2.head && (a2.head.text = h3 >> 8 & 1), 512 & a2.flags && 4 & a2.wrap && (R2[0] = 255 & h3, R2[1] = h3 >>> 8 & 255, a2.check = H(a2.check, R2, 2, 0)), h3 = 0, d2 = 0, a2.mode = 16182;
          case 16182:
            for (; d2 < 32; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            a2.head && (a2.head.time = h3), 512 & a2.flags && 4 & a2.wrap && (R2[0] = 255 & h3, R2[1] = h3 >>> 8 & 255, R2[2] = h3 >>> 16 & 255, R2[3] = h3 >>> 24 & 255, a2.check = H(a2.check, R2, 4, 0)), h3 = 0, d2 = 0, a2.mode = 16183;
          case 16183:
            for (; d2 < 16; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            a2.head && (a2.head.xflags = 255 & h3, a2.head.os = h3 >> 8), 512 & a2.flags && 4 & a2.wrap && (R2[0] = 255 & h3, R2[1] = h3 >>> 8 & 255, a2.check = H(a2.check, R2, 2, 0)), h3 = 0, d2 = 0, a2.mode = 16184;
          case 16184:
            if (1024 & a2.flags) {
              for (; d2 < 16; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              a2.length = h3, a2.head && (a2.head.extra_len = h3), 512 & a2.flags && 4 & a2.wrap && (R2[0] = 255 & h3, R2[1] = h3 >>> 8 & 255, a2.check = H(a2.check, R2, 2, 0)), h3 = 0, d2 = 0;
            } else a2.head && (a2.head.extra = null);
            a2.mode = 16185;
          case 16185:
            if (1024 & a2.flags && ((u2 = a2.length) > o2 && (u2 = o2), u2 && (a2.head && (y2 = a2.head.extra_len - a2.length, a2.head.extra || (a2.head.extra = new Uint8Array(a2.head.extra_len)), a2.head.extra.set(n2.subarray(r3, r3 + u2), y2)), 512 & a2.flags && 4 & a2.wrap && (a2.check = H(a2.check, n2, u2, r3)), o2 -= u2, r3 += u2, a2.length -= u2), a2.length)) break t;
            a2.length = 0, a2.mode = 16186;
          case 16186:
            if (2048 & a2.flags) {
              if (0 === o2) break t;
              u2 = 0;
              do {
                y2 = n2[r3 + u2++], a2.head && y2 && a2.length < 65536 && (a2.head.name += String.fromCharCode(y2));
              } while (y2 && u2 < o2);
              if (512 & a2.flags && 4 & a2.wrap && (a2.check = H(a2.check, n2, u2, r3)), o2 -= u2, r3 += u2, y2) break t;
            } else a2.head && (a2.head.name = null);
            a2.length = 0, a2.mode = 16187;
          case 16187:
            if (4096 & a2.flags) {
              if (0 === o2) break t;
              u2 = 0;
              do {
                y2 = n2[r3 + u2++], a2.head && y2 && a2.length < 65536 && (a2.head.comment += String.fromCharCode(y2));
              } while (y2 && u2 < o2);
              if (512 & a2.flags && 4 & a2.wrap && (a2.check = H(a2.check, n2, u2, r3)), o2 -= u2, r3 += u2, y2) break t;
            } else a2.head && (a2.head.comment = null);
            a2.mode = 16188;
          case 16188:
            if (512 & a2.flags) {
              for (; d2 < 16; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              if (4 & a2.wrap && h3 !== (65535 & a2.check)) {
                t3.msg = "header crc mismatch", a2.mode = Be;
                break;
              }
              h3 = 0, d2 = 0;
            }
            a2.head && (a2.head.hcrc = a2.flags >> 9 & 1, a2.head.done = true), t3.adler = a2.check = 0, a2.mode = Te;
            break;
          case 16189:
            for (; d2 < 32; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            t3.adler = a2.check = Ce(h3), h3 = 0, d2 = 0, a2.mode = De;
          case De:
            if (0 === a2.havedict) return t3.next_out = s3, t3.avail_out = l2, t3.next_in = r3, t3.avail_in = o2, a2.hold = h3, a2.bits = d2, ze;
            t3.adler = a2.check = 1, a2.mode = Te;
          case Te:
            if (e3 === ve || e3 === ke) break t;
          case Oe:
            if (a2.last) {
              h3 >>>= 7 & d2, d2 -= 7 & d2, a2.mode = Ne;
              break;
            }
            for (; d2 < 3; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            switch (a2.last = 1 & h3, d2 -= 1, 3 & (h3 >>>= 1)) {
              case 0:
                a2.mode = 16193;
                break;
              case 1:
                if (qe(a2), a2.mode = Fe, e3 === ke) {
                  h3 >>>= 2, d2 -= 2;
                  break t;
                }
                break;
              case 2:
                a2.mode = 16196;
                break;
              case 3:
                t3.msg = "invalid block type", a2.mode = Be;
            }
            h3 >>>= 2, d2 -= 2;
            break;
          case 16193:
            for (h3 >>>= 7 & d2, d2 -= 7 & d2; d2 < 32; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if ((65535 & h3) != (h3 >>> 16 ^ 65535)) {
              t3.msg = "invalid stored block lengths", a2.mode = Be;
              break;
            }
            if (a2.length = 65535 & h3, h3 = 0, d2 = 0, a2.mode = Ie, e3 === ke) break t;
          case Ie:
            a2.mode = 16195;
          case 16195:
            if (u2 = a2.length) {
              if (u2 > o2 && (u2 = o2), u2 > l2 && (u2 = l2), 0 === u2) break t;
              i3.set(n2.subarray(r3, r3 + u2), s3), o2 -= u2, r3 += u2, l2 -= u2, s3 += u2, a2.length -= u2;
              break;
            }
            a2.mode = Te;
            break;
          case 16196:
            for (; d2 < 14; ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if (a2.nlen = 257 + (31 & h3), h3 >>>= 5, d2 -= 5, a2.ndist = 1 + (31 & h3), h3 >>>= 5, d2 -= 5, a2.ncode = 4 + (15 & h3), h3 >>>= 4, d2 -= 4, a2.nlen > 286 || a2.ndist > 30) {
              t3.msg = "too many length or distance symbols", a2.mode = Be;
              break;
            }
            a2.have = 0, a2.mode = 16197;
          case 16197:
            for (; a2.have < a2.ncode; ) {
              for (; d2 < 3; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              a2.lens[Z3[a2.have++]] = 7 & h3, h3 >>>= 3, d2 -= 3;
            }
            for (; a2.have < 19; ) a2.lens[Z3[a2.have++]] = 0;
            if (a2.lencode = a2.lendyn, a2.lenbits = 7, z2 = { bits: a2.lenbits }, x3 = ge(0, a2.lens, 0, 19, a2.lencode, 0, a2.work, z2), a2.lenbits = z2.bits, x3) {
              t3.msg = "invalid code lengths set", a2.mode = Be;
              break;
            }
            a2.have = 0, a2.mode = 16198;
          case 16198:
            for (; a2.have < a2.nlen + a2.ndist; ) {
              for (; b2 = (E2 = a2.lencode[h3 & (1 << a2.lenbits) - 1]) >>> 16 & 255, g2 = 65535 & E2, !((m3 = E2 >>> 24) <= d2); ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              if (g2 < 16) h3 >>>= m3, d2 -= m3, a2.lens[a2.have++] = g2;
              else {
                if (16 === g2) {
                  for (A3 = m3 + 2; d2 < A3; ) {
                    if (0 === o2) break t;
                    o2--, h3 += n2[r3++] << d2, d2 += 8;
                  }
                  if (h3 >>>= m3, d2 -= m3, 0 === a2.have) {
                    t3.msg = "invalid bit length repeat", a2.mode = Be;
                    break;
                  }
                  y2 = a2.lens[a2.have - 1], u2 = 3 + (3 & h3), h3 >>>= 2, d2 -= 2;
                } else if (17 === g2) {
                  for (A3 = m3 + 3; d2 < A3; ) {
                    if (0 === o2) break t;
                    o2--, h3 += n2[r3++] << d2, d2 += 8;
                  }
                  d2 -= m3, y2 = 0, u2 = 3 + (7 & (h3 >>>= m3)), h3 >>>= 3, d2 -= 3;
                } else {
                  for (A3 = m3 + 7; d2 < A3; ) {
                    if (0 === o2) break t;
                    o2--, h3 += n2[r3++] << d2, d2 += 8;
                  }
                  d2 -= m3, y2 = 0, u2 = 11 + (127 & (h3 >>>= m3)), h3 >>>= 7, d2 -= 7;
                }
                if (a2.have + u2 > a2.nlen + a2.ndist) {
                  t3.msg = "invalid bit length repeat", a2.mode = Be;
                  break;
                }
                for (; u2--; ) a2.lens[a2.have++] = y2;
              }
            }
            if (a2.mode === Be) break;
            if (0 === a2.lens[256]) {
              t3.msg = "invalid code -- missing end-of-block", a2.mode = Be;
              break;
            }
            if (a2.lenbits = 9, z2 = { bits: a2.lenbits }, x3 = ge(1, a2.lens, 0, a2.nlen, a2.lencode, 0, a2.work, z2), a2.lenbits = z2.bits, x3) {
              t3.msg = "invalid literal/lengths set", a2.mode = Be;
              break;
            }
            if (a2.distbits = 6, a2.distcode = a2.distdyn, z2 = { bits: a2.distbits }, x3 = ge(2, a2.lens, a2.nlen, a2.ndist, a2.distcode, 0, a2.work, z2), a2.distbits = z2.bits, x3) {
              t3.msg = "invalid distances set", a2.mode = Be;
              break;
            }
            if (a2.mode = Fe, e3 === ke) break t;
          case Fe:
            a2.mode = Le;
          case Le:
            if (o2 >= 6 && l2 >= 258) {
              t3.next_out = s3, t3.avail_out = l2, t3.next_in = r3, t3.avail_in = o2, a2.hold = h3, a2.bits = d2, fe(t3, f4), s3 = t3.next_out, i3 = t3.output, l2 = t3.avail_out, r3 = t3.next_in, n2 = t3.input, o2 = t3.avail_in, h3 = a2.hold, d2 = a2.bits, a2.mode === Te && (a2.back = -1);
              break;
            }
            for (a2.back = 0; b2 = (E2 = a2.lencode[h3 & (1 << a2.lenbits) - 1]) >>> 16 & 255, g2 = 65535 & E2, !((m3 = E2 >>> 24) <= d2); ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if (b2 && 0 == (240 & b2)) {
              for (p2 = m3, v2 = b2, k2 = g2; b2 = (E2 = a2.lencode[k2 + ((h3 & (1 << p2 + v2) - 1) >> p2)]) >>> 16 & 255, g2 = 65535 & E2, !(p2 + (m3 = E2 >>> 24) <= d2); ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              h3 >>>= p2, d2 -= p2, a2.back += p2;
            }
            if (h3 >>>= m3, d2 -= m3, a2.back += m3, a2.length = g2, 0 === b2) {
              a2.mode = 16205;
              break;
            }
            if (32 & b2) {
              a2.back = -1, a2.mode = Te;
              break;
            }
            if (64 & b2) {
              t3.msg = "invalid literal/length code", a2.mode = Be;
              break;
            }
            a2.extra = 15 & b2, a2.mode = 16201;
          case 16201:
            if (a2.extra) {
              for (A3 = a2.extra; d2 < A3; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              a2.length += h3 & (1 << a2.extra) - 1, h3 >>>= a2.extra, d2 -= a2.extra, a2.back += a2.extra;
            }
            a2.was = a2.length, a2.mode = 16202;
          case 16202:
            for (; b2 = (E2 = a2.distcode[h3 & (1 << a2.distbits) - 1]) >>> 16 & 255, g2 = 65535 & E2, !((m3 = E2 >>> 24) <= d2); ) {
              if (0 === o2) break t;
              o2--, h3 += n2[r3++] << d2, d2 += 8;
            }
            if (0 == (240 & b2)) {
              for (p2 = m3, v2 = b2, k2 = g2; b2 = (E2 = a2.distcode[k2 + ((h3 & (1 << p2 + v2) - 1) >> p2)]) >>> 16 & 255, g2 = 65535 & E2, !(p2 + (m3 = E2 >>> 24) <= d2); ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              h3 >>>= p2, d2 -= p2, a2.back += p2;
            }
            if (h3 >>>= m3, d2 -= m3, a2.back += m3, 64 & b2) {
              t3.msg = "invalid distance code", a2.mode = Be;
              break;
            }
            a2.offset = g2, a2.extra = 15 & b2, a2.mode = 16203;
          case 16203:
            if (a2.extra) {
              for (A3 = a2.extra; d2 < A3; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              a2.offset += h3 & (1 << a2.extra) - 1, h3 >>>= a2.extra, d2 -= a2.extra, a2.back += a2.extra;
            }
            if (a2.offset > a2.dmax) {
              t3.msg = "invalid distance too far back", a2.mode = Be;
              break;
            }
            a2.mode = 16204;
          case 16204:
            if (0 === l2) break t;
            if (u2 = f4 - l2, a2.offset > u2) {
              if ((u2 = a2.offset - u2) > a2.whave && a2.sane) {
                t3.msg = "invalid distance too far back", a2.mode = Be;
                break;
              }
              u2 > a2.wnext ? (u2 -= a2.wnext, c2 = a2.wsize - u2) : c2 = a2.wnext - u2, u2 > a2.length && (u2 = a2.length), w2 = a2.window;
            } else w2 = i3, c2 = s3 - a2.offset, u2 = a2.length;
            u2 > l2 && (u2 = l2), l2 -= u2, a2.length -= u2;
            do {
              i3[s3++] = w2[c2++];
            } while (--u2);
            0 === a2.length && (a2.mode = Le);
            break;
          case 16205:
            if (0 === l2) break t;
            i3[s3++] = a2.length, l2--, a2.mode = Le;
            break;
          case Ne:
            if (a2.wrap) {
              for (; d2 < 32; ) {
                if (0 === o2) break t;
                o2--, h3 |= n2[r3++] << d2, d2 += 8;
              }
              if (f4 -= l2, t3.total_out += f4, a2.total += f4, 4 & a2.wrap && f4 && (t3.adler = a2.check = a2.flags ? H(a2.check, i3, f4, s3 - f4) : C(a2.check, i3, f4, s3 - f4)), f4 = l2, 4 & a2.wrap && (a2.flags ? h3 : Ce(h3)) !== a2.check) {
                t3.msg = "incorrect data check", a2.mode = Be;
                break;
              }
              h3 = 0, d2 = 0;
            }
            a2.mode = 16207;
          case 16207:
            if (a2.wrap && a2.flags) {
              for (; d2 < 32; ) {
                if (0 === o2) break t;
                o2--, h3 += n2[r3++] << d2, d2 += 8;
              }
              if (4 & a2.wrap && h3 !== (4294967295 & a2.total)) {
                t3.msg = "incorrect length check", a2.mode = Be;
                break;
              }
              h3 = 0, d2 = 0;
            }
            a2.mode = 16208;
          case 16208:
            x3 = xe;
            break t;
          case Be:
            x3 = Ee;
            break t;
          case 16210:
            return Re;
          default:
            return Ae;
        }
        return t3.next_out = s3, t3.avail_out = l2, t3.next_in = r3, t3.avail_in = o2, a2.hold = h3, a2.bits = d2, (a2.wsize || f4 !== t3.avail_out && a2.mode < Be && (a2.mode < Ne || e3 !== pe)) && Je(t3, t3.output, t3.next_out, f4 - t3.avail_out), _2 -= t3.avail_in, f4 -= t3.avail_out, t3.total_in += _2, t3.total_out += f4, a2.total += f4, 4 & a2.wrap && f4 && (t3.adler = a2.check = a2.flags ? H(a2.check, i3, f4, t3.next_out - f4) : C(a2.check, i3, f4, t3.next_out - f4)), t3.data_type = a2.bits + (a2.last ? 64 : 0) + (a2.mode === Te ? 128 : 0) + (a2.mode === Fe || a2.mode === Ie ? 256 : 0), (0 === _2 && 0 === f4 || e3 === pe) && x3 === ye && (x3 = Ze), x3;
      }, inflateEnd: function(t3) {
        if (Ke(t3)) return Ae;
        var e3 = t3.state;
        return e3.window && (e3.window = null), t3.state = null, ye;
      }, inflateGetHeader: function(t3, e3) {
        if (Ke(t3)) return Ae;
        var a2 = t3.state;
        return 0 == (2 & a2.wrap) ? Ae : (a2.head = e3, e3.done = false, ye);
      }, inflateSetDictionary: function(t3, e3) {
        var a2, n2 = e3.length;
        return Ke(t3) || 0 !== (a2 = t3.state).wrap && a2.mode !== De ? Ae : a2.mode === De && C(1, e3, n2, 0) !== a2.check ? Ee : Je(t3, e3, n2, n2) ? (a2.mode = 16210, Re) : (a2.havedict = 1, ye);
      }, inflateInfo: "pako inflate (from Nodeca project)" };
      var Ve = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      }, $e = Object.prototype.toString, ta = K.Z_NO_FLUSH, ea = K.Z_FINISH, aa = K.Z_OK, na = K.Z_STREAM_END, ia = K.Z_NEED_DICT, ra = K.Z_STREAM_ERROR, sa = K.Z_DATA_ERROR, oa = K.Z_MEM_ERROR;
      function la(t3) {
        this.options = Kt({ chunkSize: 65536, windowBits: 15, to: "" }, t3 || {});
        var e3 = this.options;
        e3.raw && e3.windowBits >= 0 && e3.windowBits < 16 && (e3.windowBits = -e3.windowBits, 0 === e3.windowBits && (e3.windowBits = -15)), !(e3.windowBits >= 0 && e3.windowBits < 16) || t3 && t3.windowBits || (e3.windowBits += 32), e3.windowBits > 15 && e3.windowBits < 48 && 0 == (15 & e3.windowBits) && (e3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Qt(), this.strm.avail_out = 0;
        var a2 = Qe.inflateInit2(this.strm, e3.windowBits);
        if (a2 !== aa) throw new Error(j[a2]);
        if (this.header = new Ve(), Qe.inflateGetHeader(this.strm, this.header), e3.dictionary && ("string" == typeof e3.dictionary ? e3.dictionary = Wt(e3.dictionary) : "[object ArrayBuffer]" === $e.call(e3.dictionary) && (e3.dictionary = new Uint8Array(e3.dictionary)), e3.raw && (a2 = Qe.inflateSetDictionary(this.strm, e3.dictionary)) !== aa)) throw new Error(j[a2]);
      }
      function ha(t3, e3) {
        var a2 = new la(e3);
        if (a2.push(t3), a2.err) throw a2.msg || j[a2.err];
        return a2.result;
      }
      la.prototype.push = function(t3, e3) {
        var a2, n2, i3, r3 = this.strm, s3 = this.options.chunkSize, o2 = this.options.dictionary;
        if (this.ended) return false;
        for (n2 = e3 === ~~e3 ? e3 : true === e3 ? ea : ta, "[object ArrayBuffer]" === $e.call(t3) ? r3.input = new Uint8Array(t3) : r3.input = t3, r3.next_in = 0, r3.avail_in = r3.input.length; ; ) {
          for (0 === r3.avail_out && (r3.output = new Uint8Array(s3), r3.next_out = 0, r3.avail_out = s3), (a2 = Qe.inflate(r3, n2)) === ia && o2 && ((a2 = Qe.inflateSetDictionary(r3, o2)) === aa ? a2 = Qe.inflate(r3, n2) : a2 === sa && (a2 = ia)); r3.avail_in > 0 && a2 === na && r3.state.wrap > 0 && 0 !== t3[r3.next_in]; ) Qe.inflateReset(r3), a2 = Qe.inflate(r3, n2);
          switch (a2) {
            case ra:
            case sa:
            case ia:
            case oa:
              return this.onEnd(a2), this.ended = true, false;
          }
          if (i3 = r3.avail_out, r3.next_out && (0 === r3.avail_out || a2 === na)) if ("string" === this.options.to) {
            var l2 = Jt(r3.output, r3.next_out), h3 = r3.next_out - l2, d2 = qt(r3.output, l2);
            r3.next_out = h3, r3.avail_out = s3 - h3, h3 && r3.output.set(r3.output.subarray(l2, l2 + h3), 0), this.onData(d2);
          } else this.onData(r3.output.length === r3.next_out ? r3.output : r3.output.subarray(0, r3.next_out));
          if (a2 !== aa || 0 !== i3) {
            if (a2 === na) return a2 = Qe.inflateEnd(this.strm), this.onEnd(a2), this.ended = true, true;
            if (0 === r3.avail_in) break;
          }
        }
        return true;
      }, la.prototype.onData = function(t3) {
        this.chunks.push(t3);
      }, la.prototype.onEnd = function(t3) {
        t3 === aa && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Pt(this.chunks)), this.chunks = [], this.err = t3, this.msg = this.strm.msg;
      };
      var da = { Inflate: la, inflate: ha, inflateRaw: function(t3, e3) {
        return (e3 = e3 || {}).raw = true, ha(t3, e3);
      }, ungzip: ha, constants: K }, _a = de.Deflate, fa = de.deflate, ua = de.deflateRaw, ca = de.gzip, wa = da.Inflate, ma = da.inflate, ba = da.inflateRaw, ga = da.ungzip, pa = K, va = { Deflate: _a, deflate: fa, deflateRaw: ua, gzip: ca, Inflate: wa, inflate: ma, inflateRaw: ba, ungzip: ga, constants: pa };
      t2.Deflate = _a, t2.Inflate = wa, t2.constants = pa, t2.default = va, t2.deflate = fa, t2.deflateRaw = ua, t2.gzip = ca, t2.inflate = ma, t2.inflateRaw = ba, t2.ungzip = ga, Object.defineProperty(t2, "__esModule", { value: true });
    }));
  }
});

// node_modules/pizzip/js/flate.js
var require_flate = __commonJS({
  "node_modules/pizzip/js/flate.js"(exports) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako_es5_min();
    exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.magic = "\b\0";
    exports.compress = function(input, compressionOptions) {
      return pako.deflateRaw(input, {
        level: compressionOptions.level || -1
        // default compression
      });
    };
    exports.uncompress = function(input) {
      return pako.inflateRaw(input);
    };
  }
});

// node_modules/pizzip/js/compressions.js
var require_compressions = __commonJS({
  "node_modules/pizzip/js/compressions.js"(exports) {
    "use strict";
    exports.STORE = {
      magic: "\0\0",
      compress: function compress(content) {
        return content;
      },
      uncompress: function uncompress(content) {
        return content;
      },
      compressInputType: null,
      uncompressInputType: null
    };
    exports.DEFLATE = require_flate();
  }
});

// node_modules/pizzip/js/nodeBuffer.js
var require_nodeBuffer = __commonJS({
  "node_modules/pizzip/js/nodeBuffer.js"(exports, module) {
    "use strict";
    module.exports = function(data2, encoding) {
      if (typeof data2 === "number") {
        return Buffer.alloc(data2);
      }
      return Buffer.from(data2, encoding);
    };
    module.exports.test = function(b) {
      return Buffer.isBuffer(b);
    };
  }
});

// node_modules/pizzip/js/utils.js
var require_utils = __commonJS({
  "node_modules/pizzip/js/utils.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var support = require_support();
    var compressions = require_compressions();
    var nodeBuffer = require_nodeBuffer();
    exports.string2binary = function(str) {
      var result = "";
      for (var i2 = 0; i2 < str.length; i2++) {
        result += String.fromCharCode(str.charCodeAt(i2) & 255);
      }
      return result;
    };
    exports.arrayBuffer2Blob = function(buffer2, mimeType) {
      exports.checkSupport("blob");
      mimeType = mimeType || "application/zip";
      try {
        return new Blob([buffer2], {
          type: mimeType
        });
      } catch (_unused) {
        try {
          var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          var builder = new Builder();
          builder.append(buffer2);
          return builder.getBlob(mimeType);
        } catch (_unused2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i2 = 0; i2 < str.length; ++i2) {
        array[i2] = str.charCodeAt(i2) & 255;
      }
      return array;
    }
    function arrayLikeToString(array) {
      var chunk = 65536;
      var result = [], len = array.length, type2 = exports.getTypeOf(array);
      var k = 0, canUseApply = true;
      try {
        switch (type2) {
          case "uint8array":
            String.fromCharCode.apply(null, new Uint8Array(0));
            break;
          case "nodebuffer":
            String.fromCharCode.apply(null, nodeBuffer(0));
            break;
        }
      } catch (_unused3) {
        canUseApply = false;
      }
      if (!canUseApply) {
        var resultStr = "";
        for (var i2 = 0; i2 < array.length; i2++) {
          resultStr += String.fromCharCode(array[i2]);
        }
        return resultStr;
      }
      while (k < len && chunk > 1) {
        try {
          if (type2 === "array" || type2 === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        } catch (_unused4) {
          chunk = Math.floor(chunk / 2);
        }
      }
      return result.join("");
    }
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i2 = 0; i2 < arrayFrom.length; i2++) {
        arrayTo[i2] = arrayFrom[i2];
      }
      return arrayTo;
    }
    var transform = {};
    transform.string = {
      string: identity,
      array: function array(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      arraybuffer: function arraybuffer(input) {
        return transform.string.uint8array(input).buffer;
      },
      uint8array: function uint8array(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      nodebuffer: function nodebuffer(input) {
        return stringToArrayLike(input, nodeBuffer(input.length));
      }
    };
    transform.array = {
      string: arrayLikeToString,
      array: identity,
      arraybuffer: function arraybuffer(input) {
        return new Uint8Array(input).buffer;
      },
      uint8array: function uint8array(input) {
        return new Uint8Array(input);
      },
      nodebuffer: function nodebuffer(input) {
        return nodeBuffer(input);
      }
    };
    transform.arraybuffer = {
      string: function string(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      array: function array(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      arraybuffer: identity,
      uint8array: function uint8array(input) {
        return new Uint8Array(input);
      },
      nodebuffer: function nodebuffer(input) {
        return nodeBuffer(new Uint8Array(input));
      }
    };
    transform.uint8array = {
      string: arrayLikeToString,
      array: function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      arraybuffer: function arraybuffer(input) {
        return input.buffer;
      },
      uint8array: identity,
      nodebuffer: function nodebuffer(input) {
        return nodeBuffer(input);
      }
    };
    transform.nodebuffer = {
      string: arrayLikeToString,
      array: function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      arraybuffer: function arraybuffer(input) {
        return transform.nodebuffer.uint8array(input).buffer;
      },
      uint8array: function uint8array(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      nodebuffer: identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports.getTypeOf = function(input) {
      if (input == null) {
        return;
      }
      if (typeof input === "string") {
        return "string";
      }
      var protoResult = Object.prototype.toString.call(input);
      if (protoResult === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodeBuffer.test(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && protoResult === "[object Uint8Array]") {
        return "uint8array";
      }
      if (support.arraybuffer && protoResult === "[object ArrayBuffer]") {
        return "arraybuffer";
      }
      if (protoResult === "[object Promise]") {
        throw new Error("Cannot read data from a promise, you probably are running new PizZip(data) with a promise");
      }
      if (_typeof(input) === "object" && typeof input.file === "function") {
        throw new Error("Cannot read data from a pizzip instance, you probably are running new PizZip(zip) with a zipinstance");
      }
      if (protoResult === "[object Date]") {
        throw new Error("Cannot read data from a Date, you probably are running new PizZip(data) with a date");
      }
      if (_typeof(input) === "object" && input.crc32 == null) {
        throw new Error("Unsupported data given to new PizZip(data) (object given)");
      }
    };
    exports.checkSupport = function(type2) {
      var supported = support[type2.toLowerCase()];
      if (!supported) {
        throw new Error(type2 + " is not supported by this browser");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = "", code, i2;
      for (i2 = 0; i2 < (str || "").length; i2++) {
        code = str.charCodeAt(i2);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    exports.isRegExp = function(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    };
    exports.extend = function() {
      var result = {};
      var i2, attr;
      for (i2 = 0; i2 < arguments.length; i2++) {
        for (attr in arguments[i2]) {
          if (arguments[i2].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i2][attr];
          }
        }
      }
      return result;
    };
  }
});

// node_modules/pizzip/js/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pizzip/js/crc32.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    module.exports = function crc32(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils2.getTypeOf(input) !== "string";
      if (typeof crc == "undefined") {
        crc = 0;
      }
      var x2 = 0;
      var y = 0;
      var b = 0;
      crc ^= -1;
      for (var i2 = 0, iTop = input.length; i2 < iTop; i2++) {
        b = isArray ? input[i2] : input.charCodeAt(i2);
        y = (crc ^ b) & 255;
        x2 = table[y];
        crc = crc >>> 8 ^ x2;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pizzip/js/signature.js
var require_signature = __commonJS({
  "node_modules/pizzip/js/signature.js"(exports) {
    "use strict";
    exports.LOCAL_FILE_HEADER = "PK";
    exports.CENTRAL_FILE_HEADER = "PK";
    exports.CENTRAL_DIRECTORY_END = "PK";
    exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/pizzip/js/defaults.js
var require_defaults = __commonJS({
  "node_modules/pizzip/js/defaults.js"(exports) {
    "use strict";
    exports.base64 = false;
    exports.binary = false;
    exports.dir = false;
    exports.createFolders = false;
    exports.date = null;
    exports.compression = null;
    exports.compressionOptions = null;
    exports.comment = null;
    exports.unixPermissions = null;
    exports.dosPermissions = null;
  }
});

// node_modules/pizzip/js/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/pizzip/js/compressedObject.js"(exports, module) {
    "use strict";
    function CompressedObject() {
      this.compressedSize = 0;
      this.uncompressedSize = 0;
      this.crc32 = 0;
      this.compressionMethod = null;
      this.compressedContent = null;
    }
    CompressedObject.prototype = {
      /**
       * Return the decompressed content in an unspecified format.
       * The format will depend on the decompressor.
       * @return {Object} the decompressed content.
       */
      getContent: function getContent() {
        return null;
      },
      /**
       * Return the compressed content in an unspecified format.
       * The format will depend on the compressed conten source.
       * @return {Object} the compressed content.
       */
      getCompressedContent: function getCompressedContent() {
        return null;
      }
    };
    module.exports = CompressedObject;
  }
});

// node_modules/pizzip/js/utf8.js
var require_utf8 = __commonJS({
  "node_modules/pizzip/js/utf8.js"(exports) {
    "use strict";
    var utils2 = require_utils();
    var support = require_support();
    var nodeBuffer = require_nodeBuffer();
    var _utf8len = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      _utf8len[i2] = i2 >= 252 ? 6 : i2 >= 248 ? 5 : i2 >= 240 ? 4 : i2 >= 224 ? 3 : i2 >= 192 ? 2 : 1;
    }
    var i2;
    _utf8len[254] = _utf8len[254] = 1;
    function string2buf(str) {
      var buf, c, c2, mPos, i3, bufLen = 0;
      var strLen = str.length;
      for (mPos = 0; mPos < strLen; mPos++) {
        c = str.charCodeAt(mPos);
        if ((c & 64512) === 55296 && mPos + 1 < strLen) {
          c2 = str.charCodeAt(mPos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            mPos++;
          }
        }
        bufLen += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(bufLen);
      } else {
        buf = new Array(bufLen);
      }
      for (i3 = 0, mPos = 0; i3 < bufLen; mPos++) {
        c = str.charCodeAt(mPos);
        if ((c & 64512) === 55296 && mPos + 1 < strLen) {
          c2 = str.charCodeAt(mPos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            mPos++;
          }
        }
        if (c < 128) {
          buf[i3++] = c;
        } else if (c < 2048) {
          buf[i3++] = 192 | c >>> 6;
          buf[i3++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i3++] = 224 | c >>> 12;
          buf[i3++] = 128 | c >>> 6 & 63;
          buf[i3++] = 128 | c & 63;
        } else {
          buf[i3++] = 240 | c >>> 18;
          buf[i3++] = 128 | c >>> 12 & 63;
          buf[i3++] = 128 | c >>> 6 & 63;
          buf[i3++] = 128 | c & 63;
        }
      }
      return buf;
    }
    function utf8border(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    }
    function buf2string(buf) {
      var i3, out, c, cLen;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i3 = 0; i3 < len; ) {
        c = buf[i3++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        cLen = _utf8len[c];
        if (cLen > 4) {
          utf16buf[out++] = 65533;
          i3 += cLen - 1;
          continue;
        }
        c &= cLen === 2 ? 31 : cLen === 3 ? 15 : 7;
        while (cLen > 1 && i3 < len) {
          c = c << 6 | buf[i3++] & 63;
          cLen--;
        }
        if (cLen > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils2.applyFromCharCode(utf16buf);
    }
    exports.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodeBuffer(str, "utf-8");
      }
      return string2buf(str);
    };
    exports.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils2.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils2.transformTo(support.uint8array ? "uint8array" : "array", buf);
      var result = [], len = buf.length, chunk = 65536;
      var k = 0;
      while (k < len) {
        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
        if (support.uint8array) {
          result.push(buf2string(buf.subarray(k, nextBoundary)));
        } else {
          result.push(buf2string(buf.slice(k, nextBoundary)));
        }
        k = nextBoundary;
      }
      return result.join("");
    };
  }
});

// node_modules/pizzip/js/stringWriter.js
var require_stringWriter = __commonJS({
  "node_modules/pizzip/js/stringWriter.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    function StringWriter() {
      this.data = [];
    }
    StringWriter.prototype = {
      /**
       * Append any content to the current string.
       * @param {Object} input the content to add.
       */
      append: function append(input) {
        input = utils2.transformTo("string", input);
        this.data.push(input);
      },
      /**
       * Finalize the construction an return the result.
       * @return {string} the generated string.
       */
      finalize: function finalize() {
        return this.data.join("");
      }
    };
    module.exports = StringWriter;
  }
});

// node_modules/pizzip/js/uint8ArrayWriter.js
var require_uint8ArrayWriter = __commonJS({
  "node_modules/pizzip/js/uint8ArrayWriter.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    function Uint8ArrayWriter(length) {
      this.data = new Uint8Array(length);
      this.index = 0;
    }
    Uint8ArrayWriter.prototype = {
      /**
       * Append any content to the current array.
       * @param {Object} input the content to add.
       */
      append: function append(input) {
        if (input.length !== 0) {
          input = utils2.transformTo("uint8array", input);
          this.data.set(input, this.index);
          this.index += input.length;
        }
      },
      /**
       * Finalize the construction an return the result.
       * @return {Uint8Array} the generated array.
       */
      finalize: function finalize() {
        return this.data;
      }
    };
    module.exports = Uint8ArrayWriter;
  }
});

// node_modules/pizzip/js/object.js
var require_object = __commonJS({
  "node_modules/pizzip/js/object.js"(exports, module) {
    "use strict";
    function _createForOfIteratorHelper(r2, e2) {
      var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (!t2) {
        if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
          t2 && (r2 = t2);
          var _n = 0, F2 = function F3() {
          };
          return { s: F2, n: function n() {
            return _n >= r2.length ? { done: true } : { done: false, value: r2[_n++] };
          }, e: function e3(r3) {
            throw r3;
          }, f: F2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s2() {
        t2 = t2.call(r2);
      }, n: function n() {
        var r3 = t2.next();
        return a = r3.done, r3;
      }, e: function e3(r3) {
        u = true, o = r3;
      }, f: function f3() {
        try {
          a || null == t2["return"] || t2["return"]();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r2[e2];
      return n;
    }
    var support = require_support();
    var utils2 = require_utils();
    var _crc = require_crc32();
    var signature = require_signature();
    var defaults = require_defaults();
    var base64 = require_base64();
    var compressions = require_compressions();
    var CompressedObject = require_compressedObject();
    var nodeBuffer = require_nodeBuffer();
    var utf8 = require_utf8();
    var StringWriter = require_stringWriter();
    var Uint8ArrayWriter = require_uint8ArrayWriter();
    function getRawData(file) {
      if (file._data instanceof CompressedObject) {
        file._data = file._data.getContent();
        file.options.binary = true;
        file.options.base64 = false;
        if (utils2.getTypeOf(file._data) === "uint8array") {
          var copy = file._data;
          file._data = new Uint8Array(copy.length);
          if (copy.length !== 0) {
            file._data.set(copy, 0);
          }
        }
      }
      return file._data;
    }
    function getBinaryData(file) {
      var result = getRawData(file), type2 = utils2.getTypeOf(result);
      if (type2 === "string") {
        if (!file.options.binary) {
          if (support.nodebuffer) {
            return nodeBuffer(result, "utf-8");
          }
        }
        return file.asBinary();
      }
      return result;
    }
    var out = {
      /**
       * Read an existing zip and merge the data in the current PizZip object.
       * The implementation is in pizzip-load.js, don't forget to include it.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load
       * @param {Object} options Options for loading the stream.
       *  options.base64 : is the stream in base64 ? default : false
       * @return {PizZip} the current PizZip object
       */
      load: function load() {
        throw new Error("Load method is not defined. Is the file pizzip-load.js included ?");
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function filter(search) {
        var result = [];
        var filename, relativePath, file, fileClone;
        for (filename in this.files) {
          if (!this.files.hasOwnProperty(filename)) {
            continue;
          }
          file = this.files[filename];
          fileClone = new ZipObject(file.name, file._data, utils2.extend(file.options));
          relativePath = filename.slice(this.root.length, filename.length);
          if (filename.slice(0, this.root.length) === this.root && // the file is in the current root
          search(relativePath, fileClone)) {
            result.push(fileClone);
          }
        }
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {PizZip|Object|Array} this PizZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function file(name, data2, o) {
        if (arguments.length === 1) {
          if (utils2.isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file2) {
              return !file2.dir && regexp.test(relativePath);
            });
          }
          return this.filter(function(relativePath, file2) {
            return !file2.dir && relativePath === name;
          })[0] || null;
        }
        name = this.root + name;
        fileAdd.call(this, name, data2, o);
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {PizZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function folder(arg) {
        if (!arg) {
          return this;
        }
        if (utils2.isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.shallowClone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {PizZip} this PizZip object
       */
      remove: function remove(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i2 = 0; i2 < kids.length; i2++) {
            delete this.files[kids[i2].name];
          }
        }
        return this;
      },
      /**
       * Generate the complete zip file
       * @param {Object} options the options to generate the zip file :
       * - base64, (deprecated, use type instead) true to generate base64.
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
       */
      generate: function generate(options) {
        options = utils2.extend(options || {}, {
          base64: true,
          compression: "STORE",
          compressionOptions: null,
          type: "base64",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf8.utf8encode
        });
        utils2.checkSupport(options.type);
        if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
          options.platform = "UNIX";
        }
        if (options.platform === "win32") {
          options.platform = "DOS";
        }
        var zipData = [], encodedComment = utils2.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
        var localDirLength = 0, centralDirLength = 0, writer, i2;
        var fileNames = [];
        if (options.fileOrder instanceof Array) {
          fileNames = options.fileOrder;
        }
        for (var name in this.files) {
          if (fileNames.indexOf(name) === -1) {
            fileNames.push(name);
          }
        }
        if (typeof options.fileOrder === "function") {
          fileNames = options.fileOrder(this.files);
        }
        var _iterator = _createForOfIteratorHelper(fileNames), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _name = _step.value;
            if (!this.files.hasOwnProperty(_name)) {
              continue;
            }
            var file = this.files[_name];
            var compressionName = file.options.compression || options.compression.toUpperCase();
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !");
            }
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
            var zipPart = generateZipParts.call(this, _name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
            centralDirLength += zipPart.dirRecord.length;
            zipData.push(zipPart);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var dirEnd = "";
        dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        decToHex(zipData.length, 2) + // total number of entries in the central directory
        decToHex(zipData.length, 2) + // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) + // .ZIP file comment length
        decToHex(encodedComment.length, 2) + // .ZIP file comment
        encodedComment;
        var typeName = options.type.toLowerCase();
        if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
          writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
        } else {
          writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
        }
        for (i2 = 0; i2 < zipData.length; i2++) {
          writer.append(zipData[i2].fileRecord);
          writer.append(zipData[i2].compressedObject.compressedContent);
        }
        for (i2 = 0; i2 < zipData.length; i2++) {
          writer.append(zipData[i2].dirRecord);
        }
        writer.append(dirEnd);
        var zip = writer.finalize();
        switch (options.type.toLowerCase()) {
          // case "zip is an Uint8Array"
          case "uint8array":
          case "arraybuffer":
          case "nodebuffer":
            return utils2.transformTo(options.type.toLowerCase(), zip);
          case "blob":
            return utils2.arrayBuffer2Blob(utils2.transformTo("arraybuffer", zip), options.mimeType);
          // case "zip is a string"
          case "base64":
            return options.base64 ? base64.encode(zip) : zip;
          default:
            return zip;
        }
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      crc32: function crc32(input, crc) {
        return _crc(input, crc);
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      utf8encode: function utf8encode(string) {
        return utils2.transformTo("string", utf8.utf8encode(string));
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      utf8decode: function utf8decode(input) {
        return utf8.utf8decode(input);
      }
    };
    function dataToString(asUTF8) {
      var result = getRawData(this);
      if (result === null || typeof result === "undefined") {
        return "";
      }
      if (this.options.base64) {
        result = base64.decode(result);
      }
      if (asUTF8 && this.options.binary) {
        result = out.utf8decode(result);
      } else {
        result = utils2.transformTo("string", result);
      }
      if (!asUTF8 && !this.options.binary) {
        result = utils2.transformTo("string", out.utf8encode(result));
      }
      return result;
    }
    function ZipObject(name, data2, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data2;
      this.options = options;
      this._initialMetadata = {
        dir: options.dir,
        date: options.date
      };
    }
    ZipObject.prototype = {
      /**
       * Return the content as UTF8 string.
       * @return {string} the UTF8 string.
       */
      asText: function asText() {
        return dataToString.call(this, true);
      },
      /**
       * Returns the binary content.
       * @return {string} the content as binary.
       */
      asBinary: function asBinary() {
        return dataToString.call(this, false);
      },
      /**
       * Returns the content as a nodejs Buffer.
       * @return {Buffer} the content as a Buffer.
       */
      asNodeBuffer: function asNodeBuffer() {
        var result = getBinaryData(this);
        return utils2.transformTo("nodebuffer", result);
      },
      /**
       * Returns the content as an Uint8Array.
       * @return {Uint8Array} the content as an Uint8Array.
       */
      asUint8Array: function asUint8Array() {
        var result = getBinaryData(this);
        return utils2.transformTo("uint8array", result);
      },
      /**
       * Returns the content as an ArrayBuffer.
       * @return {ArrayBuffer} the content as an ArrayBufer.
       */
      asArrayBuffer: function asArrayBuffer() {
        return this.asUint8Array().buffer;
      }
    };
    function decToHex(dec, bytes) {
      var hex = "", i2;
      for (i2 = 0; i2 < bytes; i2++) {
        hex += String.fromCharCode(dec & 255);
        dec >>>= 8;
      }
      return hex;
    }
    function prepareFileAttrs(o) {
      o = o || {};
      if (o.base64 === true && (o.binary === null || o.binary === void 0)) {
        o.binary = true;
      }
      o = utils2.extend(o, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      return o;
    }
    function fileAdd(name, data2, o) {
      var dataType = utils2.getTypeOf(data2), parent;
      o = prepareFileAttrs(o);
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      if (o.dir || data2 === null || typeof data2 === "undefined") {
        o.base64 = false;
        o.binary = false;
        data2 = null;
        dataType = null;
      } else if (dataType === "string") {
        if (o.binary && !o.base64) {
          if (o.optimizedBinaryString !== true) {
            data2 = utils2.string2binary(data2);
          }
        }
      } else {
        o.base64 = false;
        o.binary = true;
        if (!dataType && !(data2 instanceof CompressedObject)) {
          throw new Error("The data of '" + name + "' is in an unsupported format !");
        }
        if (dataType === "arraybuffer") {
          data2 = utils2.transformTo("uint8array", data2);
        }
      }
      var object = new ZipObject(name, data2, o);
      this.files[name] = object;
      return object;
    }
    function parentFolder(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    }
    function forceTrailingSlash(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    }
    function folderAdd(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : false;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    }
    function generateCompressedObjectFrom(file, compression, compressionOptions) {
      var result = new CompressedObject();
      var content;
      if (file._data instanceof CompressedObject) {
        result.uncompressedSize = file._data.uncompressedSize;
        result.crc32 = file._data.crc32;
        if (result.uncompressedSize === 0 || file.dir) {
          compression = compressions.STORE;
          result.compressedContent = "";
          result.crc32 = 0;
        } else if (file._data.compressionMethod === compression.magic) {
          result.compressedContent = file._data.getCompressedContent();
        } else {
          content = file._data.getContent();
          result.compressedContent = compression.compress(utils2.transformTo(compression.compressInputType, content), compressionOptions);
        }
      } else {
        content = getBinaryData(file);
        if (!content || content.length === 0 || file.dir) {
          compression = compressions.STORE;
          content = "";
        }
        result.uncompressedSize = content.length;
        result.crc32 = _crc(content);
        result.compressedContent = compression.compress(utils2.transformTo(compression.compressInputType, content), compressionOptions);
      }
      result.compressedSize = result.compressedContent.length;
      result.compressionMethod = compression.magic;
      return result;
    }
    function generateUnixExternalFileAttr(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    }
    function generateDosExternalFileAttr(dosPermissions) {
      return (dosPermissions || 0) & 63;
    }
    function generateZipParts(name, file, compressedObject, offset, platform, encodeFileName) {
      var useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils2.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils2.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment || "", encodedComment = utils2.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils2.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options;
      var dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir, date;
      if (file._initialMetadata.dir !== file.dir) {
        dir = file.dir;
      } else {
        dir = o.dir;
      }
      if (file._initialMetadata.date !== file.date) {
        date = file.date;
      } else {
        date = o.date;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getHours();
      dosTime <<= 6;
      dosTime |= date.getMinutes();
      dosTime <<= 5;
      dosTime |= date.getSeconds() / 2;
      dosDate = date.getFullYear() - 1980;
      dosDate <<= 4;
      dosDate |= date.getMonth() + 1;
      dosDate <<= 5;
      dosDate |= date.getDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(_crc(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(this.crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\0\b" : "\0\0";
      header += compressedObject.compressionMethod;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(compressedObject.crc32, 4);
      header += decToHex(compressedObject.compressedSize, 4);
      header += decToHex(compressedObject.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord,
        compressedObject
      };
    }
    module.exports = out;
  }
});

// node_modules/pizzip/js/dataReader.js
var require_dataReader = __commonJS({
  "node_modules/pizzip/js/dataReader.js"(exports, module) {
    "use strict";
    var utils2 = require_utils();
    function DataReader() {
      this.data = null;
      this.length = 0;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function checkOffset(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specifed index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function checkIndex(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function setIndex(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function skip(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function byteAt() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function readInt(size) {
        var result = 0, i2;
        this.checkOffset(size);
        for (i2 = this.index + size - 1; i2 >= this.index; i2--) {
          result = (result << 8) + this.byteAt(i2);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function readString(size) {
        return utils2.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function readData() {
      },
      /**
       * Find the last occurence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurence, -1 if not found.
       */
      lastIndexOfSignature: function lastIndexOfSignature() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function readDate() {
        var dostime = this.readInt(4);
        return new Date(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        );
      }
    };
    module.exports = DataReader;
  }
});

// node_modules/pizzip/js/stringReader.js
var require_stringReader = __commonJS({
  "node_modules/pizzip/js/stringReader.js"(exports, module) {
    "use strict";
    var DataReader = require_dataReader();
    var utils2 = require_utils();
    function StringReader(data2, optimizedBinaryString) {
      this.data = data2;
      if (!optimizedBinaryString) {
        this.data = utils2.string2binary(this.data);
      }
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    StringReader.prototype = new DataReader();
    StringReader.prototype.byteAt = function(i2) {
      return this.data.charCodeAt(this.zero + i2);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = StringReader;
  }
});

// node_modules/pizzip/js/arrayReader.js
var require_arrayReader = __commonJS({
  "node_modules/pizzip/js/arrayReader.js"(exports, module) {
    "use strict";
    var DataReader = require_dataReader();
    function ArrayReader(data2) {
      if (data2) {
        this.data = data2;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
        for (var i2 = 0; i2 < this.data.length; i2++) {
          data2[i2] &= data2[i2];
        }
      }
    }
    ArrayReader.prototype = new DataReader();
    ArrayReader.prototype.byteAt = function(i2) {
      return this.data[this.zero + i2];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i2 = this.length - 4; i2 >= 0; --i2) {
        if (this.data[i2] === sig0 && this.data[i2 + 1] === sig1 && this.data[i2 + 2] === sig2 && this.data[i2 + 3] === sig3) {
          return i2 - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = ArrayReader;
  }
});

// node_modules/pizzip/js/uint8ArrayReader.js
var require_uint8ArrayReader = __commonJS({
  "node_modules/pizzip/js/uint8ArrayReader.js"(exports, module) {
    "use strict";
    var ArrayReader = require_arrayReader();
    function Uint8ArrayReader(data2) {
      if (data2) {
        this.data = data2;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
      }
    }
    Uint8ArrayReader.prototype = new ArrayReader();
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = Uint8ArrayReader;
  }
});

// node_modules/pizzip/js/nodeBufferReader.js
var require_nodeBufferReader = __commonJS({
  "node_modules/pizzip/js/nodeBufferReader.js"(exports, module) {
    "use strict";
    var Uint8ArrayReader = require_uint8ArrayReader();
    function NodeBufferReader(data2) {
      this.data = data2;
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    NodeBufferReader.prototype = new Uint8ArrayReader();
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = NodeBufferReader;
  }
});

// node_modules/pizzip/js/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/pizzip/js/zipEntry.js"(exports, module) {
    "use strict";
    var StringReader = require_stringReader();
    var utils2 = require_utils();
    var CompressedObject = require_compressedObject();
    var pizzipProto = require_object();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function isEncrypted() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function useUTF8() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Prepare the function used to generate the compressed content from this ZipFile.
       * @param {DataReader} reader the reader to use.
       * @param {number} from the offset from where we should read the data.
       * @param {number} length the length of the data to read.
       * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).
       */
      prepareCompressedContent: function prepareCompressedContent(reader, from, length) {
        return function() {
          var previousIndex = reader.index;
          reader.setIndex(from);
          var compressedFileData = reader.readData(length);
          reader.setIndex(previousIndex);
          return compressedFileData;
        };
      },
      /**
       * Prepare the function used to generate the uncompressed content from this ZipFile.
       * @param {DataReader} reader the reader to use.
       * @param {number} from the offset from where we should read the data.
       * @param {number} length the length of the data to read.
       * @param {PizZip.compression} compression the compression used on this file.
       * @param {number} uncompressedSize the uncompressed size to expect.
       * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).
       */
      prepareContent: function prepareContent(reader, from, length, compression, uncompressedSize) {
        return function() {
          var compressedFileData = utils2.transformTo(compression.uncompressInputType, this.getCompressedContent());
          var uncompressedFileData = compression.uncompress(compressedFileData);
          if (uncompressedFileData.length !== uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
          return uncompressedFileData;
        };
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function readLocalPart(reader) {
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        var localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");
        }
        var compression = utils2.findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils2.pretty(this.compressionMethod) + " unknown (inner file : " + utils2.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject();
        this.decompressed.compressedSize = this.compressedSize;
        this.decompressed.uncompressedSize = this.uncompressedSize;
        this.decompressed.crc32 = this.crc32;
        this.decompressed.compressionMethod = this.compressionMethod;
        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
        if (this.loadOptions.checkCRC32) {
          this.decompressed = utils2.transformTo("string", this.decompressed.getContent());
          if (pizzipProto.crc32(this.decompressed) !== this.crc32) {
            throw new Error("Corrupted zip : CRC32 mismatch");
          }
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function readCentralPart(reader) {
        this.versionMadeBy = reader.readInt(2);
        this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        this.fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        this.fileName = reader.readData(this.fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function processAttributes() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = !!(this.externalFileAttributes & 16);
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       */
      parseZIP64ExtraField: function parseZIP64ExtraField() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = new StringReader(this.extraFields[1].value);
        if (this.uncompressedSize === utils2.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils2.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils2.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils2.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function readExtraFields(reader) {
        var start = reader.index;
        var extraFieldId, extraFieldLength, extraFieldValue;
        this.extraFields = this.extraFields || {};
        while (reader.index < start + this.extraFieldsLength) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readString(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function handleUTF8() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = pizzipProto.utf8decode(this.fileName);
          this.fileCommentStr = pizzipProto.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils2.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils2.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = new StringReader(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (pizzipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return pizzipProto.utf8decode(extraReader.readString(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = new StringReader(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (pizzipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return pizzipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
        }
        return null;
      }
    };
    module.exports = ZipEntry;
  }
});

// node_modules/pizzip/js/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/pizzip/js/zipEntries.js"(exports, module) {
    "use strict";
    var StringReader = require_stringReader();
    var NodeBufferReader = require_nodeBufferReader();
    var Uint8ArrayReader = require_uint8ArrayReader();
    var ArrayReader = require_arrayReader();
    var utils2 = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(data2, loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
      if (data2) {
        this.load(data2);
      }
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the speficied signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function checkSignature(expectedSignature) {
        var signature = this.reader.readString(4);
        if (signature !== expectedSignature) {
          throw new Error("Corrupted zip or bug : unexpected signature (" + utils2.pretty(signature) + ", expected " + utils2.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function isSignature(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function readBlockEndOfCentral() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils2.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.versionMadeBy = this.reader.readString(2);
        this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44;
        var index = 0;
        var extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readString(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function readLocalFiles() {
        var i2, file;
        for (i2 = 0; i2 < this.files.length; i2++) {
          file = this.files[i2];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function readCentralDir() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function readEndOfCentral() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ?");
          } else {
            throw new Error("Corrupted zip : can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils2.MAX_VALUE_16BITS || this.centralDirRecords === utils2.MAX_VALUE_16BITS || this.centralDirSize === utils2.MAX_VALUE_32BITS || this.centralDirOffset === utils2.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function prepareReader(data2) {
        var type2 = utils2.getTypeOf(data2);
        utils2.checkSupport(type2);
        if (type2 === "string" && !support.uint8array) {
          this.reader = new StringReader(data2, this.loadOptions.optimizedBinaryString);
        } else if (type2 === "nodebuffer") {
          this.reader = new NodeBufferReader(data2);
        } else if (support.uint8array) {
          this.reader = new Uint8ArrayReader(utils2.transformTo("uint8array", data2));
        } else if (support.array) {
          this.reader = new ArrayReader(utils2.transformTo("array", data2));
        } else {
          throw new Error("Unexpected error: unsupported type '" + type2 + "'");
        }
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function load(data2) {
        this.prepareReader(data2);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module.exports = ZipEntries;
  }
});

// node_modules/pizzip/js/load.js
var require_load = __commonJS({
  "node_modules/pizzip/js/load.js"(exports, module) {
    "use strict";
    var base64 = require_base64();
    var utf8 = require_utf8();
    var utils2 = require_utils();
    var ZipEntries = require_zipEntries();
    module.exports = function(data2, options) {
      var i2, input;
      options = utils2.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (options.base64) {
        data2 = base64.decode(data2);
      }
      var zipEntries = new ZipEntries(data2, options);
      var files = zipEntries.files;
      for (i2 = 0; i2 < files.length; i2++) {
        input = files[i2];
        this.file(input.fileNameStr, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
      }
      if (zipEntries.zipComment.length) {
        this.comment = zipEntries.zipComment;
      }
      return this;
    };
  }
});

// node_modules/pizzip/js/deprecatedPublicUtils.js
var require_deprecatedPublicUtils = __commonJS({
  "node_modules/pizzip/js/deprecatedPublicUtils.js"(exports) {
    "use strict";
    var utils2 = require_utils();
    exports.string2binary = function(str) {
      return utils2.string2binary(str);
    };
    exports.string2Uint8Array = function(str) {
      return utils2.transformTo("uint8array", str);
    };
    exports.uint8Array2String = function(array) {
      return utils2.transformTo("string", array);
    };
    exports.string2Blob = function(str) {
      var buffer2 = utils2.transformTo("arraybuffer", str);
      return utils2.arrayBuffer2Blob(buffer2);
    };
    exports.arrayBuffer2Blob = function(buffer2) {
      return utils2.arrayBuffer2Blob(buffer2);
    };
    exports.transformTo = function(outputType, input) {
      return utils2.transformTo(outputType, input);
    };
    exports.getTypeOf = function(input) {
      return utils2.getTypeOf(input);
    };
    exports.checkSupport = function(type2) {
      return utils2.checkSupport(type2);
    };
    exports.MAX_VALUE_16BITS = utils2.MAX_VALUE_16BITS;
    exports.MAX_VALUE_32BITS = utils2.MAX_VALUE_32BITS;
    exports.pretty = function(str) {
      return utils2.pretty(str);
    };
    exports.findCompression = function(compressionMethod) {
      return utils2.findCompression(compressionMethod);
    };
    exports.isRegExp = function(object) {
      return utils2.isRegExp(object);
    };
  }
});

// node_modules/pizzip/js/index.js
var require_js = __commonJS({
  "node_modules/pizzip/js/index.js"(exports, module) {
    "use strict";
    var base64 = require_base64();
    function PizZip2(data2, options) {
      if (!(this instanceof PizZip2)) {
        return new PizZip2(data2, options);
      }
      this.files = {};
      this.comment = null;
      this.root = "";
      if (data2) {
        this.load(data2, options);
      }
      this.clone = function() {
        var _this = this;
        var newObj = new PizZip2();
        Object.keys(this.files).forEach(function(file) {
          newObj.file(file, _this.files[file].asUint8Array());
        });
        return newObj;
      };
      this.shallowClone = function() {
        var newObj = new PizZip2();
        for (var i2 in this) {
          if (typeof this[i2] !== "function") {
            newObj[i2] = this[i2];
          }
        }
        return newObj;
      };
    }
    PizZip2.prototype = require_object();
    PizZip2.prototype.load = require_load();
    PizZip2.support = require_support();
    PizZip2.defaults = require_defaults();
    PizZip2.utils = require_deprecatedPublicUtils();
    PizZip2.base64 = {
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      encode: function encode(input) {
        return base64.encode(input);
      },
      /**
       * @deprecated
       * This method will be removed in a future version without replacement.
       */
      decode: function decode(input) {
        return base64.decode(input);
      }
    };
    PizZip2.compressions = require_compressions();
    module.exports = PizZip2;
    module.exports["default"] = PizZip2;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, (function(exports2) {
      "use strict";
      function noop3() {
        return void 0;
      }
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop3;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a2) {
        }
      }
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise((resolve) => resolve(value));
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(void 0);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e2) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a2) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      var _a, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer2) => buffer2.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer2) => structuredClone(buffer2, { transfer: [buffer2] });
        } else {
          TransferArrayBuffer = (buffer2) => buffer2;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer2) => buffer2.detached;
        } else {
          IsDetachedBuffer = (buffer2) => buffer2.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer2, begin, end) {
        if (buffer2.slice) {
          return buffer2.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer2, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        const asyncIterator = (async function* () {
          return yield* syncIterable;
        })();
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer2 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer2);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
          }
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state2 = this._controlledReadableByteStream._state;
          if (state2 !== "readable") {
            throw new TypeError(`The stream (in ${state2} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state2 = this._controlledReadableByteStream._state;
          if (state2 !== "readable") {
            throw new TypeError(`The stream (in ${state2} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer2;
            try {
              buffer2 = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer: buffer2,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer2, byteOffset, byteLength) {
        controller._queue.push({ buffer: buffer2, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer2, byteOffset, byteLength) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer2, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue2 = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue2.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue2.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min2, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min2 * elementSize;
        let buffer2;
        try {
          buffer2 = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        const pullIntoDescriptor = {
          buffer: buffer2,
          bufferByteLength: buffer2.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state2 = controller._controlledReadableByteStream._state;
        if (state2 === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer: buffer2, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer2)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        const transferredBuffer = TransferArrayBuffer(buffer2);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state2 = controller._controlledReadableByteStream._state;
        if (state2 === "errored") {
          return null;
        }
        if (state2 === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state2 = controller._controlledReadableByteStream._state;
        if (state2 === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state2 = controller._controlledReadableByteStream._state;
        if (state2 === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a2;
        assertDictionary(options, context);
        const min2 = (_a2 = options === null || options === void 0 ? void 0 : options.min) !== null && _a2 !== void 0 ? _a2 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min2, `${context} has member 'min' that`)
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(new TypeError("view's buffer has been detached"));
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const min2 = options.min;
          if (min2 === 0) {
            return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
          }
          if (!isDataView(view)) {
            if (min2 > view.length) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
            }
          } else if (min2 > view.byteLength) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve, reject) => {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, min2, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min2, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min2, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type2 = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type: type2
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type2 = underlyingSink.type;
          if (type2 !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a2;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort(reason);
        const state2 = stream._state;
        if (state2 === "closed" || state2 === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state2 === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state2 = stream._state;
        if (state2 === "closed" || state2 === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state2} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
          const closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state2 === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
          const writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state2 = stream._state;
        if (state2 === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state2 = stream._state;
        if (state2 === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state2 = stream._state;
          if (state2 === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state2 === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state2 === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state2 = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state2 === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state2 === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state2 = stream._state;
        if (state2 === "errored" || state2 === "erroring") {
          return null;
        }
        if (state2 === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state2 = stream._state;
        if (state2 === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state2 === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state2 === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state2 = this._controlledWritableStream._state;
          if (state2 !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state2 = stream._state;
        if (state2 === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state2 = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state2 === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        const ctor = function DOMException3(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException2 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = signal.reason !== void 0 ? signal.reason : new DOMException2("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
            return null;
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state2 = controller._controlledReadableStream._state;
        if (state2 === "errored") {
          return null;
        }
        if (state2 === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state2 = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state2 === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve) => {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type2 = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type2 === void 0 ? void 0 : convertReadableStreamType(type2, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type2, context) {
        type2 = `${type2}`;
        if (type2 !== "bytes") {
          throw new TypeError(`${context} '${type2}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type2;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop3);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve) => {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve) => {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state2 = writable._state;
            if (state2 === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const writable = stream._writable;
        controller._finishPromise = newPromise((resolve, reject) => {
          controller._finishPromise_resolve = resolve;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports2.CountQueuingStrategy = CountQueuingStrategy;
      exports2.ReadableByteStreamController = ReadableByteStreamController;
      exports2.ReadableStream = ReadableStream2;
      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports2.TransformStream = TransformStream;
      exports2.TransformStreamDefaultController = TransformStreamDefaultController;
      exports2.WritableStream = WritableStream;
      exports2.WritableStreamDefaultController = WritableStreamDefaultController;
      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    }));
  }
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process3 = __require("node:process");
        const { emitWarning } = process3;
        try {
          process3.emitWarning = () => {
          };
          Object.assign(globalThis, __require("node:stream/web"));
          process3.emitWarning = emitWarning;
        } catch (error) {
          process3.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob4 } = __require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
              const buffer2 = await chunk.arrayBuffer();
              position += buffer2.byteLength;
              ctrl.enqueue(new Uint8Array(buffer2));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* (
        /** @type {AsyncIterableIterator<Uint8Array>} */
        part.stream()
      );
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = (
        /** @type {Blob} */
        part
      );
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer2 = await chunk.arrayBuffer();
        position += buffer2.byteLength;
        yield new Uint8Array(buffer2);
      }
    }
  }
}
var import_streams, POOL_SIZE, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm({
  "node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null) options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type2 = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type2) ? type2 : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data2 = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data2.set(chunk, offset);
          offset += chunk.length;
        }
        return data2.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type2 = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type2).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    fetch_blob_default = Blob3;
  }
});

// node_modules/fetch-blob/file.js
var _File, File3, file_default;
var init_file = __esm({
  "node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = class File2 extends fetch_blob_default {
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null) options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    File3 = _File;
    file_default = File3;
  }
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, FormData;
var init_esm_min = __esm({
  "node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    };
  }
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "node_modules/node-domexception/index.js"(exports, module) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel: MessageChannel2 } = __require("worker_threads"), port = new MessageChannel2().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module.exports = globalThis.DOMException;
  }
});

// node_modules/fetch-blob/from.js
import { statSync, createReadStream, promises as fs2 } from "node:fs";
var import_node_domexception, stat;
var init_from = __esm({
  "node_modules/fetch-blob/from.js"() {
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = fs2);
  }
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body3, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body3) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop2, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop2 = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop2;
        this.onHeaderField = noop2;
        this.onHeadersEnd = noop2;
        this.onHeaderValue = noop2;
        this.onPartBegin = noop2;
        this.onPartData = noop2;
        this.onPartEnd = noop2;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data2) {
        let i2 = 0;
        const length_ = data2.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state: state2, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data2.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data2);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data2.length, data2);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data2[i2];
          switch (state2) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state2 = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state2 = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state2 = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            // falls through
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state2 = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state2 = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state2 = S.HEADER_VALUE;
            // falls through
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state2 = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state2 = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state2 = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state2 = S.PART_DATA;
              mark("onPartData");
            // falls through
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data2[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data2[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state2 = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state2 = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state2}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state2;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/docx/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var BaseXmlComponent = class {
  constructor(rootKey) {
    __publicField(this, "rootKey");
    this.rootKey = rootKey;
  }
};
var EMPTY_OBJECT = Object.seal({});
var XmlComponent = class extends BaseXmlComponent {
  constructor(rootKey) {
    super(rootKey);
    __publicField(this, "root");
    this.root = new Array();
  }
  // This method is called by the formatter to get the XML representation of this component.
  // It is called recursively for all child components.
  // It is a serializer to be used in the xml library.
  // https://www.npmjs.com/package/xml
  // Child components can override this method to customize the XML representation, or execute side effects.
  prepForXml(context) {
    var _a;
    context.stack.push(this);
    const children = this.root.map((comp) => {
      if (comp instanceof BaseXmlComponent) {
        return comp.prepForXml(context);
      }
      return comp;
    }).filter((comp) => comp !== void 0);
    context.stack.pop();
    return {
      [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? void 0 : _a._attr) ? children[0] : children : EMPTY_OBJECT
    };
  }
  /**
   * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.
   */
  addChildElement(child) {
    this.root.push(child);
    return this;
  }
};
var IgnoreIfEmptyXmlComponent = class extends XmlComponent {
  prepForXml(context) {
    const result = super.prepForXml(context);
    if (result && (typeof result[this.rootKey] !== "object" || Object.keys(result[this.rootKey]).length)) {
      return result;
    }
    return void 0;
  }
};
var XmlAttributeComponent = class extends BaseXmlComponent {
  constructor(root) {
    super("_attr");
    __publicField(this, "xmlKeys");
    this.root = root;
  }
  prepForXml(_) {
    const attrs = {};
    Object.entries(this.root).forEach(([key, value]) => {
      if (value !== void 0) {
        const newKey = this.xmlKeys && this.xmlKeys[key] || key;
        attrs[newKey] = value;
      }
    });
    return { _attr: attrs };
  }
};
var NextAttributeComponent = class extends BaseXmlComponent {
  constructor(root) {
    super("_attr");
    this.root = root;
  }
  prepForXml(_) {
    const attrs = Object.values(this.root).filter(({ value }) => value !== void 0).reduce((acc, { key, value }) => __spreadProps(__spreadValues({}, acc), { [key]: value }), {});
    return { _attr: attrs };
  }
};
var Attributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      val: "w:val",
      color: "w:color",
      fill: "w:fill",
      space: "w:space",
      sz: "w:sz",
      type: "w:type",
      rsidR: "w:rsidR",
      rsidRPr: "w:rsidRPr",
      rsidSect: "w:rsidSect",
      w: "w:w",
      h: "w:h",
      top: "w:top",
      right: "w:right",
      bottom: "w:bottom",
      left: "w:left",
      header: "w:header",
      footer: "w:footer",
      gutter: "w:gutter",
      linePitch: "w:linePitch",
      pos: "w:pos"
    });
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var sax = {};
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type2) {
    var args = [];
    for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        ReflectApply(listeners[i2], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m2;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m2 = _getMaxListeners(target);
      if (m2 > 0 && existing.length > m2 && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i2, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i2 = list.length - 1; i2 >= 0; i2--) {
        if (list[i2] === listener || list[i2].listener === listener) {
          originalListener = list[i2].listener;
          position = i2;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i2;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i2 = 0; i2 < keys.length; ++i2) {
        key = keys[i2];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i2 = listeners.length - 1; i2 >= 0; i2--) {
        this.removeListener(type2, listeners[i2]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i2 = 0; i2 < n; ++i2)
      copy[i2] = arr[i2];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var browser$1 = { exports: {} };
var process2 = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e22) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e22) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process2.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process2.title = "browser";
process2.browser = true;
process2.env = {};
process2.argv = [];
process2.version = "";
process2.versions = {};
function noop() {
}
process2.on = noop;
process2.addListener = noop;
process2.once = noop;
process2.off = noop;
process2.removeListener = noop;
process2.removeAllListeners = noop;
process2.emit = noop;
process2.prependListener = noop;
process2.prependOnceListener = noop;
process2.listeners = function(name) {
  return [];
};
process2.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process2.cwd = function() {
  return "/";
};
process2.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process2.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
var process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i22;
    for (i22 = 0; i22 < len2; i22 += 4) {
      tmp = revLookup[b64.charCodeAt(i22)] << 18 | revLookup[b64.charCodeAt(i22 + 1)] << 12 | revLookup[b64.charCodeAt(i22 + 2)] << 6 | revLookup[b64.charCodeAt(i22 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i22)] << 2 | revLookup[b64.charCodeAt(i22 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i22)] << 10 | revLookup[b64.charCodeAt(i22 + 1)] << 4 | revLookup[b64.charCodeAt(i22 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i22 = start; i22 < end; i22 += 3) {
      tmp = (uint8[i22] << 16 & 16711680) + (uint8[i22 + 1] << 8 & 65280) + (uint8[i22 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i22 = 0, len22 = len2 - extraBytes; i22 < len22; i22 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i22, i22 + maxChunkLength > len22 ? len22 : i22 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e2, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer2[offset + i2];
    i2 += d;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    m2 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e2, m2, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e2)) < 1) {
        e2--;
        c *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e2++;
        c /= 2;
      }
      if (e2 + eBias >= eMax) {
        m2 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m2 = (value * c - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d, m2 /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d, e2 /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d] |= s2 * 128;
  };
  return ieee754;
}
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    var base64 = requireBase64Js();
    var ieee7542 = requireIeee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer22;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer22.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer22.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer22.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer22.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer22.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer22.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer22.prototype);
      return buf;
    }
    function Buffer22(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer22.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer22.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer22.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer22.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer22.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer22, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer22.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer22.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer22.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer22.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer22.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer22.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer22.alloc(+length);
    }
    Buffer22.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer22.prototype;
    };
    Buffer22.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer22.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer22.from(b, b.offset, b.byteLength);
      if (!Buffer22.isBuffer(a) || !Buffer22.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x2 = a.length;
      var y = b.length;
      for (var i2 = 0, len = Math.min(x2, y); i2 < len; ++i2) {
        if (a[i2] !== b[i2]) {
          x2 = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x2 < y) return -1;
      if (y < x2) return 1;
      return 0;
    };
    Buffer22.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer22.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer22.alloc(0);
      }
      var i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      var buffer2 = Buffer22.allocUnsafe(length);
      var pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        var buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer22.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer22.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer22.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer22.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer22.prototype._isBuffer = true;
    function swap(b, n, m2) {
      var i2 = b[n];
      b[n] = b[m2];
      b[m2] = i2;
    }
    Buffer22.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer22.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer22.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer22.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
    Buffer22.prototype.equals = function equals(b) {
      if (!Buffer22.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer22.compare(this, b) === 0;
    };
    Buffer22.prototype.inspect = function inspect() {
      var str = "";
      var max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer22.prototype[customInspectSymbol] = Buffer22.prototype.inspect;
    }
    Buffer22.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer22.from(target, target.offset, target.byteLength);
      }
      if (!Buffer22.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x2 = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x2, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x2 < y) return -1;
      if (y < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer22.from(val, encoding);
      }
      if (Buffer22.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i22) {
        if (indexSize === 1) {
          return buf[i22];
        } else {
          return buf.readUInt16BE(i22 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer22.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer22.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer22.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i2 = 0; i2 < length; ++i2) {
        var parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer22.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer22.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer22.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer22.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer22.prototype.readUintLE = Buffer22.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer22.prototype.readUintBE = Buffer22.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer22.prototype.readUint8 = Buffer22.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer22.prototype.readUint16LE = Buffer22.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer22.prototype.readUint16BE = Buffer22.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer22.prototype.readUint32LE = Buffer22.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer22.prototype.readUint32BE = Buffer22.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer22.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer22.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i2 = byteLength2;
      var mul = 1;
      var val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer22.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer22.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer22.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer22.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer22.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer22.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer22.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer22.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer22.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max2, min2) {
      if (!Buffer22.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer22.prototype.writeUintLE = Buffer22.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer22.prototype.writeUintBE = Buffer22.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer22.prototype.writeUint8 = Buffer22.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer22.prototype.writeUint16LE = Buffer22.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer22.prototype.writeUint16BE = Buffer22.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer22.prototype.writeUint32LE = Buffer22.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer22.prototype.writeUint32BE = Buffer22.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer22.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer22.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer22.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer22.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer22.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer22.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer22.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max2, min2) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer22.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer22.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer22.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer22.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer22.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer22.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer22.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length) break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    })();
  })(buffer);
  return buffer;
}
var util = {};
var types = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e2) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i2 = 0; i2 < a.length; i2 += 1) {
      arr[i2] = a[i2];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i2 = offset, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
      arr[j] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str += arr[i2];
      if (i2 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e2) {
    if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
      throw e2;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    (function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    })
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e2) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e2) {
      var errorProto = getProto2(getProto2(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e2) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define2 = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind = requireFunctionBind();
    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $TypeError = /* @__PURE__ */ requireType();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength2(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = requireShams()();
  var getProto2 = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e2) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto2(generatorFunc) : false;
    }
    return getProto2(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e2) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e2) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e2) {
      if (e2 !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i2 = 0, len = array.length; i2 < len; i2++) {
      if (hasOwnProperty.call(array, i2)) {
        if (receiver == null) {
          iterator(array[i2], i2, array);
        } else {
          iterator.call(receiver, array[i2], i2, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i2 = 0, len = string.length; i2 < len; i2++) {
      if (receiver == null) {
        iterator(string.charAt(i2), i2, string);
      } else {
        iterator.call(receiver, string.charAt(i2), i2, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  var forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr.call(list) === "[object Array]") {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  forEach_1 = forEach;
  return forEach_1;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i2 = 0; i2 < possibleNames.length; i2++) {
      if (typeof g[possibleNames[i2]] === "function") {
        out[out.length] = possibleNames[i2];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach = requireForEach();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var getPrototypeOf = Object.getPrototypeOf;
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i2 = 0; i2 < array.length; i2 += 1) {
      if (array[i2] === value) {
        return i2;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn = arr.slice || arr.set;
      if (fn) {
        cache["$" + typedArray] = callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e2) {
          }
        }
      }
    );
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      cache,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name, 1);
          } catch (e2) {
          }
        }
      }
    );
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function uncurryThis(f3) {
      return f3.call.bind(f3);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction2;
    exports.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i2 = 0; i2 < keys.length; i2++) {
        descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f3) {
      if (!isString(f3)) {
        var objects = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          objects.push(inspect(arguments[i2]));
        }
        return objects.join(" ");
      }
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f3).replace(formatRegExp, function(x22) {
        if (x22 === "%%") return "%";
        if (i2 >= len) return x22;
        switch (x22) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x22;
        }
      });
      for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
        if (isNull(x2) || !isObject(x2)) {
          str += " " + x2;
        } else {
          str += " " + inspect(x2);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i2 = 0, l = value.length; i2 < l; ++i2) {
        if (hasOwnProperty(value, String(i2))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i2),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = requireTypes();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e2) {
      return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = requireInherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add[keys[i2]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify2(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  })(util);
  return util;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require = requireBuffer(), Buffer22 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer22.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer22.alloc(0);
        var ret = Buffer22.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer22.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i2) {
        return String(i2);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate3;
  function deprecate3(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream3 = requireStreamBrowser();
  var Buffer22 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer22.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream3);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream3.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer22.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer22.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireBuffer();
    var Buffer22 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer22(arg, encodingOrOffset, length);
    }
    copyProps(Buffer22, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer22(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer22(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer22(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer22 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer22.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer22.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer22.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r2;
    var i2;
    if (this.lastNeed) {
      r2 = this.fillLast(buf);
      if (r2 === void 0) return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length) return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
    return r2 || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r2 = utf8CheckExtraBytes(this, buf);
    if (r2 !== void 0) return r2;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed) return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i2, end);
  }
  function utf8End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r2 + "\uFFFD";
    return r2;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r2 = buf.toString("utf16le", i2);
      if (r2) {
        var c = r2.charCodeAt(r2.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r2.slice(0, -1);
        }
      }
      return r2;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r2 + this.lastChar.toString("utf16le", 0, end);
    }
    return r2;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    if (n === 0) return buf.toString("base64", i2);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n);
  }
  function base64End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r2;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop22() {
  }
  function isRequest2(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop22);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest2(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream3 = requireStreamBrowser();
  var Buffer22 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer22.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer22.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser()(Readable, Stream3);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream3.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer22.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer22.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len; i2++) {
        dests[i2].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream3.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream3.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream3.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i2 in stream) {
      if (this[i2] === void 0 && typeof stream[i2] === "function") {
        this[i2] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x2) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x2) return i2;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data2) {
    if (er) return stream.emit("error", er);
    if (data2 != null)
      stream.push(data2);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough3;
  var Transform = require_stream_transform();
  requireInherits_browser()(PassThrough3, Transform);
  function PassThrough3(options) {
    if (!(this instanceof PassThrough3)) return new PassThrough3(options);
    Transform.call(this, options);
  }
  PassThrough3.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop22(err) {
    if (err) throw err;
  }
  function isRequest2(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest2(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop22;
    if (typeof streams[streams.length - 1] !== "function") return noop22;
    return streams.pop();
  }
  function pipeline2() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i2) {
      var reading = i2 < streams.length - 1;
      var writing = i2 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline2;
  return pipeline_1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream3;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser();
  inherits(Stream3, EE);
  Stream3.Readable = require_stream_readable();
  Stream3.Writable = require_stream_writable();
  Stream3.Duplex = require_stream_duplex();
  Stream3.Transform = require_stream_transform();
  Stream3.PassThrough = require_stream_passthrough();
  Stream3.finished = requireEndOfStream();
  Stream3.pipeline = requirePipeline();
  Stream3.Stream = Stream3;
  function Stream3() {
    EE.call(this);
  }
  Stream3.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i2 in o) if (o.hasOwnProperty(i2)) a.push(i2);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream3;
      try {
        Stream3 = requireStreamBrowserify().Stream;
      } catch (ex) {
        Stream3 = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream3.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream3.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data2) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data2)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data2 = this._decoder.write(data2);
        }
        this._parser.write(data2.toString());
        this.emit("data", data2);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream3.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S2 = 0;
      sax2.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e2 = sax2.ENTITIES[key];
        var s22 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax2.ENTITIES[key] = s22;
      });
      for (var s2 in sax2.STATE) {
        sax2.STATE[sax2.STATE[s2]] = s2;
      }
      S2 = sax2.STATE;
      function emit(parser, event, data2) {
        parser[event] && parser[event](data2);
      }
      function emitNode(parser, nodeType, data2) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data2);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t2 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close = parser.tags[t2];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s22 = parser.tags.length;
        while (s22-- > t2) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag.ns) {
            x2[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t2 === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i2++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i2++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S2.DOCTYPE:
              if (c === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S2.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S2.COMMENT;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S2.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer2 = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer2] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax);
  return sax;
}
var arrayHelper;
var hasRequiredArrayHelper;
function requireArrayHelper() {
  if (hasRequiredArrayHelper) return arrayHelper;
  hasRequiredArrayHelper = 1;
  arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  return arrayHelper;
}
var optionsHelper;
var hasRequiredOptionsHelper;
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var isArray = requireArrayHelper().isArray;
  optionsHelper = {
    copyOptions: function(options) {
      var key, copy = {};
      for (key in options) {
        if (options.hasOwnProperty(key)) {
          copy[key] = options[key];
        }
      }
      return copy;
    },
    ensureFlagExists: function(item, options) {
      if (!(item in options) || typeof options[item] !== "boolean") {
        options[item] = false;
      }
    },
    ensureSpacesExists: function(options) {
      if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
        options.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options) {
      if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
        options.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options) {
      if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
        options[key + "Key"] = options.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options) {
      return key + "Fn" in options;
    }
  };
  return optionsHelper;
}
var xml2js;
var hasRequiredXml2js;
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var sax2 = requireSax();
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var options;
  var currentElement;
  function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("alwaysChildren", options);
    helper.ensureFlagExists("addParent", options);
    helper.ensureFlagExists("trim", options);
    helper.ensureFlagExists("nativeType", options);
    helper.ensureFlagExists("nativeTypeAttributes", options);
    helper.ensureFlagExists("sanitize", options);
    helper.ensureFlagExists("instructionHasAttributes", options);
    helper.ensureFlagExists("captureSpacesBetweenElements", options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.ensureKeyExists("parent", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type2, value) {
    var key;
    if (options.compact) {
      if (!currentElement[options[type2 + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement[options[type2 + "Key"]] = [];
      }
      if (currentElement[options[type2 + "Key"]] && !isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]] = [currentElement[options[type2 + "Key"]]];
      }
      if (type2 + "Fn" in options && typeof value === "string") {
        value = options[type2 + "Fn"](value, currentElement);
      }
      if (type2 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement)] = temp;
            }
          }
        }
      }
      if (isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]].push(value);
      } else {
        currentElement[options[type2 + "Key"]] = value;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type2;
      if (type2 === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type2 + "Fn" in options) {
          value = options[type2 + "Fn"](value, currentElement);
        }
        element[options[type2 + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement;
      }
      currentElement[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim) attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement[name] = [];
      }
      if (currentElement[name] && !isArray(currentElement[name])) {
        currentElement[name] = [currentElement[name]];
      }
      if (isArray(currentElement[name])) {
        currentElement[name].push(element);
      } else {
        currentElement[name] = element;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement;
    currentElement = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
      delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  xml2js = function(xml2, userOptions) {
    var parser = sax2.parser(true, {});
    var result = {};
    currentElement = result;
    options = validateOptions(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml2).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  return xml2js;
}
var xml2json;
var hasRequiredXml2json;
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var helper = requireOptionsHelper();
  var xml2js2 = requireXml2js();
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
  }
  xml2json = function(xml2, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js2(xml2, options);
    parentKey = "compact" in options && options.compact ? "_parent" : "parent";
    if ("addParent" in options && options.addParent) {
      json = JSON.stringify(js, function(k, v) {
        return k === parentKey ? "_" : v;
      }, options.spaces);
    } else {
      json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  return xml2json;
}
var js2xml;
var hasRequiredJs2xml;
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("indentText", options);
    helper.ensureFlagExists("indentCdata", options);
    helper.ensureFlagExists("indentAttributes", options);
    helper.ensureFlagExists("indentInstruction", options);
    helper.ensureFlagExists("fullTagEmptyElement", options);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === "number") {
      options.spaces = Array(options.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    helper.checkFnExists("fullTagEmptyElement", options);
    return options;
  }
  function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
  }
  function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options) {
      attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
      result.push(writeIndentation(options, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
  }
  function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options) {
    return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options) {
    return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options) {
    if (options.ignoreText) return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options) {
    var i2;
    if (element.elements && element.elements.length) {
      for (i2 = 0; i2 < element.elements.length; ++i2) {
        switch (element.elements[i2][options.typeKey]) {
          case "text":
            if (options.indentText) {
              return true;
            }
            break;
          // skip to next key
          case "cdata":
            if (options.indentCdata) {
              return true;
            }
            break;
          // skip to next key
          case "instruction":
            if (options.indentInstruction) {
              return true;
            }
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml2 = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
    xml2.push("<" + elementName);
    if (element[options.attributesKey]) {
      xml2.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options) {
        withClosingTag = options.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml2.push(">");
      if (element[options.elementsKey] && element[options.elementsKey].length) {
        xml2.push(writeElements(element[options.elementsKey], options, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml2.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
      xml2.push("</" + elementName + ">");
    } else {
      xml2.push("/>");
    }
    return xml2.join("");
  }
  function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml2, element) {
      var indent = writeIndentation(options, depth, firstLine && !xml2);
      switch (element.type) {
        case "element":
          return xml2 + indent + writeElement(element, options, depth);
        case "comment":
          return xml2 + indent + writeComment(element[options.commentKey], options);
        case "doctype":
          return xml2 + indent + writeDoctype(element[options.doctypeKey], options);
        case "cdata":
          return xml2 + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
        case "text":
          return xml2 + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
        case "instruction":
          var instruction = {};
          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
          return xml2 + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options.parentKey:
          case options.attributesKey:
            break;
          // skip to next key
          case options.textKey:
            if (options.indentText || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.cdataKey:
            if (options.indentCdata || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.instructionKey:
            if (options.indentInstruction || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.doctypeKey:
          case options.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml2 = [];
    if (name) {
      xml2.push("<" + elementName);
      if (typeof element !== "object") {
        xml2.push(">" + writeText(element, options) + "</" + elementName + ">");
        return xml2.join("");
      }
      if (element[options.attributesKey]) {
        xml2.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml2.push(">");
      } else {
        xml2.push("/>");
        return xml2.join("");
      }
    }
    xml2.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml2.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
    }
    return xml2.join("");
  }
  function writeElementsCompact(element, options, depth, firstLine) {
    var i2, key, nodes, xml2 = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [element[key]];
        for (i2 = 0; i2 < nodes.length; ++i2) {
          switch (key) {
            case options.declarationKey:
              xml2.push(writeDeclaration(nodes[i2], options, depth));
              break;
            case options.instructionKey:
              xml2.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i2], options, depth));
              break;
            case options.attributesKey:
            case options.parentKey:
              break;
            // skip
            case options.textKey:
              xml2.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i2], options));
              break;
            case options.cdataKey:
              xml2.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i2], options));
              break;
            case options.doctypeKey:
              xml2.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i2], options));
              break;
            case options.commentKey:
              xml2.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i2], options));
              break;
            default:
              xml2.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i2], key, options, depth, hasContentCompact(nodes[i2], options)));
          }
          firstLine = firstLine && !xml2.length;
        }
      }
    }
    return xml2.join("");
  }
  js2xml = function(js, options) {
    options = validateOptions(options);
    var xml2 = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options.compact) {
      xml2.push(writeElementsCompact(js, options, 0, true));
    } else {
      if (js[options.declarationKey]) {
        xml2.push(writeDeclaration(js[options.declarationKey], options, 0));
      }
      if (js[options.elementsKey] && js[options.elementsKey].length) {
        xml2.push(writeElements(js[options.elementsKey], options, 0, !xml2.length));
      }
    }
    return xml2.join("");
  };
  return js2xml;
}
var json2xml;
var hasRequiredJson2xml;
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var js2xml2 = requireJs2xml();
  json2xml = function(json, options) {
    if (json instanceof Buffer) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e2) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml2(js, options);
  };
  return json2xml;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var xml2js2 = requireXml2js();
  var xml2json2 = requireXml2json();
  var js2xml2 = requireJs2xml();
  var json2xml2 = requireJson2xml();
  lib = {
    xml2js: xml2js2,
    xml2json: xml2json2,
    js2xml: js2xml2,
    json2xml: json2xml2
  };
  return lib;
}
var libExports = requireLib();
var convertToXmlComponent = (element) => {
  switch (element.type) {
    case void 0:
    case "element":
      const xmlComponent = new ImportedXmlComponent(element.name, element.attributes);
      const childElements = element.elements || [];
      for (const childElm of childElements) {
        const child = convertToXmlComponent(childElm);
        if (child !== void 0) {
          xmlComponent.push(child);
        }
      }
      return xmlComponent;
    case "text":
      return element.text;
    default:
      return void 0;
  }
};
var ImportedXmlComponentAttributes = class extends XmlAttributeComponent {
  // noop
};
var ImportedXmlComponent = class extends XmlComponent {
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  static fromXmlString(importedContent) {
    const xmlObj = libExports.xml2js(importedContent, { compact: false });
    return convertToXmlComponent(xmlObj);
  }
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(rootKey, _attr) {
    super(rootKey);
    if (_attr) {
      this.root.push(new ImportedXmlComponentAttributes(_attr));
    }
  }
  push(xmlComponent) {
    this.root.push(xmlComponent);
  }
};
var ImportedRootElementAttributes = class extends XmlComponent {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(_attr) {
    super("");
    this._attr = _attr;
  }
  prepForXml(_) {
    return {
      _attr: this._attr
    };
  }
};
var InitializableXmlComponent = class extends XmlComponent {
  constructor(rootKey, initComponent) {
    super(rootKey);
    if (initComponent) {
      this.root = initComponent.root;
    }
  }
};
var decimalNumber = (val) => {
  if (isNaN(val)) {
    throw new Error(`Invalid value '${val}' specified. Must be an integer.`);
  }
  return Math.floor(val);
};
var unsignedDecimalNumber = (val) => {
  const value = decimalNumber(val);
  if (value < 0) {
    throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);
  }
  return value;
};
var hexBinary = (val, length) => {
  const expectedLength = length * 2;
  if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {
    throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);
  }
  return val;
};
var uCharHexNumber = (val) => hexBinary(val, 1);
var universalMeasureValue = (val) => {
  const unit = val.slice(-2);
  const amount = val.substring(0, val.length - 2);
  return `${Number(amount)}${unit}`;
};
var positiveUniversalMeasureValue = (val) => {
  const value = universalMeasureValue(val);
  if (parseFloat(value) < 0) {
    throw new Error(`Invalid value '${value}' specified. Expected a positive number.`);
  }
  return value;
};
var hexColorValue = (val) => {
  if (val === "auto") {
    return val;
  }
  const color = val.charAt(0) === "#" ? val.substring(1) : val;
  return hexBinary(color, 3);
};
var signedTwipsMeasureValue = (val) => typeof val === "string" ? universalMeasureValue(val) : decimalNumber(val);
var hpsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
var twipsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
var percentageValue = (val) => {
  const percent = val.substring(0, val.length - 1);
  return `${Number(percent)}%`;
};
var measurementOrPercentValue = (val) => {
  if (typeof val === "number") {
    return decimalNumber(val);
  }
  if (val.slice(-1) === "%") {
    return percentageValue(val);
  }
  return universalMeasureValue(val);
};
var eighthPointMeasureValue = unsignedDecimalNumber;
var pointMeasureValue = unsignedDecimalNumber;
var dateTimeValue = (val) => val.toISOString();
var OnOffElement = class extends XmlComponent {
  constructor(name, val = true) {
    super(name);
    if (val !== true) {
      this.root.push(new Attributes({ val }));
    }
  }
};
var HpsMeasureElement = class extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val: hpsMeasureValue(val) }));
  }
};
var StringValueElement = class extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
};
var createStringElement = (name, value) => new BuilderElement({
  name,
  attributes: {
    value: { key: "w:val", value }
  }
});
var NumberValueElement = class extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
};
var StringEnumValueElement = class extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
};
var StringContainer = class extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(val);
  }
};
var BuilderElement = class extends XmlComponent {
  constructor({
    name,
    attributes,
    children
  }) {
    super(name);
    if (attributes) {
      this.root.push(new NextAttributeComponent(attributes));
    }
    if (children) {
      this.root.push(...children);
    }
  }
};
var AlignmentType = {
  /** Align Start */
  START: "start",
  /** Align Center */
  CENTER: "center",
  /** End */
  END: "end",
  /** Justified */
  BOTH: "both",
  /** Medium Kashida Length */
  MEDIUM_KASHIDA: "mediumKashida",
  /** Distribute All Characters Equally */
  DISTRIBUTE: "distribute",
  /** Align to List Tab */
  NUM_TAB: "numTab",
  /** Widest Kashida Length */
  HIGH_KASHIDA: "highKashida",
  /** Low Kashida Length */
  LOW_KASHIDA: "lowKashida",
  /** Thai Language Justification */
  THAI_DISTRIBUTE: "thaiDistribute",
  /** Align Left */
  LEFT: "left",
  /** Align Right */
  RIGHT: "right",
  /** Justified */
  JUSTIFIED: "both"
};
var AlignmentAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var Alignment = class extends XmlComponent {
  constructor(type2) {
    super("w:jc");
    this.root.push(new AlignmentAttributes({ val: type2 }));
  }
};
var BorderElement = class extends XmlComponent {
  constructor(elementName, { color, size, space, style }) {
    super(elementName);
    this.root.push(
      new BordersAttributes({
        style,
        color: color === void 0 ? void 0 : hexColorValue(color),
        size: size === void 0 ? void 0 : eighthPointMeasureValue(size),
        space: space === void 0 ? void 0 : pointMeasureValue(space)
      })
    );
  }
};
var BordersAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      style: "w:val",
      color: "w:color",
      size: "w:sz",
      space: "w:space"
    });
  }
};
var BorderStyle = {
  /** a single line */
  SINGLE: "single",
  /** a line with a series of alternating thin and thick strokes */
  DASH_DOT_STROKED: "dashDotStroked",
  /** a dashed line */
  DASHED: "dashed",
  /** a dashed line with small gaps */
  DASH_SMALL_GAP: "dashSmallGap",
  /** a line with alternating dots and dashes */
  DOT_DASH: "dotDash",
  /** a line with a repeating dot - dot - dash sequence */
  DOT_DOT_DASH: "dotDotDash",
  /** a dotted line */
  DOTTED: "dotted",
  /** a double line */
  DOUBLE: "double",
  /** a double wavy line */
  DOUBLE_WAVE: "doubleWave",
  /** an inset set of lines */
  INSET: "inset",
  /** no border */
  NIL: "nil",
  /** no border */
  NONE: "none",
  /** an outset set of lines */
  OUTSET: "outset",
  /** a single line */
  THICK: "thick",
  /** a thick line contained within a thin line with a large-sized intermediate gap */
  THICK_THIN_LARGE_GAP: "thickThinLargeGap",
  /** a thick line contained within a thin line with a medium-sized intermediate gap */
  THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
  /** a thick line contained within a thin line with a small intermediate gap */
  THICK_THIN_SMALL_GAP: "thickThinSmallGap",
  /** a thin line contained within a thick line with a large-sized intermediate gap */
  THIN_THICK_LARGE_GAP: "thinThickLargeGap",
  /** a thick line contained within a thin line with a medium-sized intermediate gap */
  THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
  /** a thick line contained within a thin line with a small intermediate gap */
  THIN_THICK_SMALL_GAP: "thinThickSmallGap",
  /** a thin-thick-thin line with a large gap */
  THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
  /** a thin-thick-thin line with a medium gap */
  THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
  /** a thin-thick-thin line with a small gap */
  THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
  /** a three-staged gradient line, getting darker towards the paragraph */
  THREE_D_EMBOSS: "threeDEmboss",
  /** a three-staged gradient like, getting darker away from the paragraph */
  THREE_D_ENGRAVE: "threeDEngrave",
  /** a triple line */
  TRIPLE: "triple",
  /** a wavy line */
  WAVE: "wave"
};
var Border = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:pBdr");
    if (options.top) {
      this.root.push(new BorderElement("w:top", options.top));
    }
    if (options.bottom) {
      this.root.push(new BorderElement("w:bottom", options.bottom));
    }
    if (options.left) {
      this.root.push(new BorderElement("w:left", options.left));
    }
    if (options.right) {
      this.root.push(new BorderElement("w:right", options.right));
    }
  }
};
var ThematicBreak = class extends XmlComponent {
  constructor() {
    super("w:pBdr");
    const bottom = new BorderElement("w:bottom", {
      color: "auto",
      space: 1,
      style: BorderStyle.SINGLE,
      size: 6
    });
    this.root.push(bottom);
  }
};
var Indent = class extends XmlComponent {
  constructor({ start, end, left, right, hanging, firstLine }) {
    super("w:ind");
    this.root.push(
      new NextAttributeComponent({
        start: {
          key: "w:start",
          value: start === void 0 ? void 0 : signedTwipsMeasureValue(start)
        },
        end: {
          key: "w:end",
          value: end === void 0 ? void 0 : signedTwipsMeasureValue(end)
        },
        left: {
          key: "w:left",
          value: left === void 0 ? void 0 : signedTwipsMeasureValue(left)
        },
        right: {
          key: "w:right",
          value: right === void 0 ? void 0 : signedTwipsMeasureValue(right)
        },
        hanging: {
          key: "w:hanging",
          value: hanging === void 0 ? void 0 : twipsMeasureValue(hanging)
        },
        firstLine: {
          key: "w:firstLine",
          value: firstLine === void 0 ? void 0 : twipsMeasureValue(firstLine)
        }
      })
    );
  }
};
var Break$1 = class Break extends XmlComponent {
  constructor() {
    super("w:br");
  }
};
var FieldCharacterType = {
  BEGIN: "begin",
  END: "end",
  SEPARATE: "separate"
};
var FidCharAttrs = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
  }
};
var Begin = class extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.BEGIN, dirty }));
  }
};
var Separate = class extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.SEPARATE, dirty }));
  }
};
var End = class extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.END, dirty }));
  }
};
var SpaceType = {
  DEFAULT: "default",
  PRESERVE: "preserve"
};
var TextAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { space: "xml:space" });
  }
};
var Page = class extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("PAGE");
  }
};
var NumberOfPages = class extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("NUMPAGES");
  }
};
var NumberOfPagesSection = class extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("SECTIONPAGES");
  }
};
var CurrentSection = class extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("SECTION");
  }
};
var ShadingAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      fill: "w:fill",
      color: "w:color",
      type: "w:val"
    });
  }
};
var Shading = class extends XmlComponent {
  constructor({ fill, color, type: type2 }) {
    super("w:shd");
    this.root.push(
      new ShadingAttributes({
        fill: fill === void 0 ? void 0 : hexColorValue(fill),
        color: color === void 0 ? void 0 : hexColorValue(color),
        type: type2
      })
    );
  }
};
var ShadingType = {
  CLEAR: "clear",
  DIAGONAL_CROSS: "diagCross",
  DIAGONAL_STRIPE: "diagStripe",
  HORIZONTAL_CROSS: "horzCross",
  HORIZONTAL_STRIPE: "horzStripe",
  NIL: "nil",
  PERCENT_5: "pct5",
  PERCENT_10: "pct10",
  PERCENT_12: "pct12",
  PERCENT_15: "pct15",
  PERCENT_20: "pct20",
  PERCENT_25: "pct25",
  PERCENT_30: "pct30",
  PERCENT_35: "pct35",
  PERCENT_37: "pct37",
  PERCENT_40: "pct40",
  PERCENT_45: "pct45",
  PERCENT_50: "pct50",
  PERCENT_55: "pct55",
  PERCENT_60: "pct60",
  PERCENT_62: "pct62",
  PERCENT_65: "pct65",
  PERCENT_70: "pct70",
  PERCENT_75: "pct75",
  PERCENT_80: "pct80",
  PERCENT_85: "pct85",
  PERCENT_87: "pct87",
  PERCENT_90: "pct90",
  PERCENT_95: "pct95",
  REVERSE_DIAGONAL_STRIPE: "reverseDiagStripe",
  SOLID: "solid",
  THIN_DIAGONAL_CROSS: "thinDiagCross",
  THIN_DIAGONAL_STRIPE: "thinDiagStripe",
  THIN_HORIZONTAL_CROSS: "thinHorzCross",
  THIN_REVERSE_DIAGONAL_STRIPE: "thinReverseDiagStripe",
  THIN_VERTICAL_STRIPE: "thinVertStripe",
  VERTICAL_STRIPE: "vertStripe"
};
var ChangeAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id",
      author: "w:author",
      date: "w:date"
    });
  }
};
var EmphasisMarkType = {
  DOT: "dot"
};
var BaseEmphasisMark = class extends XmlComponent {
  constructor(emphasisMarkType) {
    super("w:em");
    this.root.push(
      new Attributes({
        val: emphasisMarkType
      })
    );
  }
};
var EmphasisMark = class extends BaseEmphasisMark {
  constructor(emphasisMarkType = EmphasisMarkType.DOT) {
    super(emphasisMarkType);
  }
};
var CharacterSpacing = class extends XmlComponent {
  constructor(value) {
    super("w:spacing");
    this.root.push(
      new Attributes({
        val: signedTwipsMeasureValue(value)
      })
    );
  }
};
var Color = class extends XmlComponent {
  constructor(color) {
    super("w:color");
    this.root.push(
      new Attributes({
        val: hexColorValue(color)
      })
    );
  }
};
var Highlight = class extends XmlComponent {
  constructor(color) {
    super("w:highlight");
    this.root.push(
      new Attributes({
        val: color
      })
    );
  }
};
var HighlightComplexScript = class extends XmlComponent {
  constructor(color) {
    super("w:highlightCs");
    this.root.push(
      new Attributes({
        val: color
      })
    );
  }
};
var createLanguageComponent = (options) => new BuilderElement({
  name: "w:lang",
  attributes: {
    value: {
      key: "w:val",
      value: options.value
    },
    eastAsia: {
      key: "w:eastAsia",
      value: options.eastAsia
    },
    bidirectional: {
      key: "w:bidi",
      value: options.bidirectional
    }
  }
});
var RunFontAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      ascii: "w:ascii",
      cs: "w:cs",
      eastAsia: "w:eastAsia",
      hAnsi: "w:hAnsi",
      hint: "w:hint"
    });
  }
};
var RunFonts = class extends XmlComponent {
  constructor(nameOrAttrs, hint) {
    super("w:rFonts");
    if (typeof nameOrAttrs === "string") {
      const name = nameOrAttrs;
      this.root.push(
        new RunFontAttributes({
          ascii: name,
          cs: name,
          eastAsia: name,
          hAnsi: name,
          hint
        })
      );
    } else {
      const attrs = nameOrAttrs;
      this.root.push(new RunFontAttributes(attrs));
    }
  }
};
var VerticalAlign$1 = class VerticalAlign extends XmlComponent {
  constructor(type2) {
    super("w:vertAlign");
    this.root.push(
      new Attributes({
        val: type2
      })
    );
  }
};
var SuperScript = class extends VerticalAlign$1 {
  constructor() {
    super("superscript");
  }
};
var SubScript = class extends VerticalAlign$1 {
  constructor() {
    super("subscript");
  }
};
var UnderlineType = {
  SINGLE: "single",
  WORDS: "words",
  DOUBLE: "double",
  THICK: "thick",
  DOTTED: "dotted",
  DOTTEDHEAVY: "dottedHeavy",
  DASH: "dash",
  DASHEDHEAVY: "dashedHeavy",
  DASHLONG: "dashLong",
  DASHLONGHEAVY: "dashLongHeavy",
  DOTDASH: "dotDash",
  DASHDOTHEAVY: "dashDotHeavy",
  DOTDOTDASH: "dotDotDash",
  DASHDOTDOTHEAVY: "dashDotDotHeavy",
  WAVE: "wave",
  WAVYHEAVY: "wavyHeavy",
  WAVYDOUBLE: "wavyDouble",
  NONE: "none"
};
var Underline = class extends XmlComponent {
  constructor(underlineType = UnderlineType.SINGLE, color) {
    super("w:u");
    this.root.push(
      new Attributes({
        val: underlineType,
        color: color === void 0 ? void 0 : hexColorValue(color)
      })
    );
  }
};
var RunProperties = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    var _a, _b;
    super("w:rPr");
    if (!options) {
      return;
    }
    if (options.style) {
      this.push(new StringValueElement("w:rStyle", options.style));
    }
    if (options.font) {
      if (typeof options.font === "string") {
        this.push(new RunFonts(options.font));
      } else if ("name" in options.font) {
        this.push(new RunFonts(options.font.name, options.font.hint));
      } else {
        this.push(new RunFonts(options.font));
      }
    }
    if (options.bold !== void 0) {
      this.push(new OnOffElement("w:b", options.bold));
    }
    if (options.boldComplexScript === void 0 && options.bold !== void 0 || options.boldComplexScript) {
      this.push(new OnOffElement("w:bCs", (_a = options.boldComplexScript) != null ? _a : options.bold));
    }
    if (options.italics !== void 0) {
      this.push(new OnOffElement("w:i", options.italics));
    }
    if (options.italicsComplexScript === void 0 && options.italics !== void 0 || options.italicsComplexScript) {
      this.push(new OnOffElement("w:iCs", (_b = options.italicsComplexScript) != null ? _b : options.italics));
    }
    if (options.smallCaps !== void 0) {
      this.push(new OnOffElement("w:smallCaps", options.smallCaps));
    } else if (options.allCaps !== void 0) {
      this.push(new OnOffElement("w:caps", options.allCaps));
    }
    if (options.strike !== void 0) {
      this.push(new OnOffElement("w:strike", options.strike));
    }
    if (options.doubleStrike !== void 0) {
      this.push(new OnOffElement("w:dstrike", options.doubleStrike));
    }
    if (options.emboss !== void 0) {
      this.push(new OnOffElement("w:emboss", options.emboss));
    }
    if (options.imprint !== void 0) {
      this.push(new OnOffElement("w:imprint", options.imprint));
    }
    if (options.noProof !== void 0) {
      this.push(new OnOffElement("w:noProof", options.noProof));
    }
    if (options.snapToGrid !== void 0) {
      this.push(new OnOffElement("w:snapToGrid", options.snapToGrid));
    }
    if (options.vanish) {
      this.push(new OnOffElement("w:vanish", options.vanish));
    }
    if (options.color) {
      this.push(new Color(options.color));
    }
    if (options.characterSpacing) {
      this.push(new CharacterSpacing(options.characterSpacing));
    }
    if (options.scale !== void 0) {
      this.push(new NumberValueElement("w:w", options.scale));
    }
    if (options.kern) {
      this.push(new HpsMeasureElement("w:kern", options.kern));
    }
    if (options.position) {
      this.push(new StringValueElement("w:position", options.position));
    }
    if (options.size !== void 0) {
      this.push(new HpsMeasureElement("w:sz", options.size));
    }
    const szCs = options.sizeComplexScript === void 0 || options.sizeComplexScript === true ? options.size : options.sizeComplexScript;
    if (szCs) {
      this.push(new HpsMeasureElement("w:szCs", szCs));
    }
    if (options.highlight) {
      this.push(new Highlight(options.highlight));
    }
    const highlightCs = options.highlightComplexScript === void 0 || options.highlightComplexScript === true ? options.highlight : options.highlightComplexScript;
    if (highlightCs) {
      this.push(new HighlightComplexScript(highlightCs));
    }
    if (options.underline) {
      this.push(new Underline(options.underline.type, options.underline.color));
    }
    if (options.effect) {
      this.push(new StringValueElement("w:effect", options.effect));
    }
    if (options.border) {
      this.push(new BorderElement("w:bdr", options.border));
    }
    if (options.shading) {
      this.push(new Shading(options.shading));
    }
    if (options.subScript) {
      this.push(new SubScript());
    }
    if (options.superScript) {
      this.push(new SuperScript());
    }
    if (options.rightToLeft !== void 0) {
      this.push(new OnOffElement("w:rtl", options.rightToLeft));
    }
    if (options.emphasisMark) {
      this.push(new EmphasisMark(options.emphasisMark.type));
    }
    if (options.language) {
      this.push(createLanguageComponent(options.language));
    }
    if (options.specVanish) {
      this.push(new OnOffElement("w:specVanish", options.vanish));
    }
    if (options.math) {
      this.push(new OnOffElement("w:oMath", options.math));
    }
    if (options.revision) {
      this.push(new RunPropertiesChange(options.revision));
    }
  }
  push(item) {
    this.root.push(item);
  }
};
var RunPropertiesChange = class extends XmlComponent {
  constructor(options) {
    super("w:rPrChange");
    this.root.push(
      new ChangeAttributes({
        id: options.id,
        author: options.author,
        date: options.date
      })
    );
    this.addChildElement(new RunProperties(options));
  }
};
var Text = class extends XmlComponent {
  constructor(options) {
    var _a;
    super("w:t");
    if (typeof options === "string") {
      this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
      this.root.push(options);
    } else {
      this.root.push(new TextAttributes({ space: (_a = options.space) != null ? _a : SpaceType.DEFAULT }));
      this.root.push(options.text);
    }
  }
};
var PageNumber = {
  CURRENT: "CURRENT",
  TOTAL_PAGES: "TOTAL_PAGES",
  TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
  CURRENT_SECTION: "SECTION"
};
var Run = class extends XmlComponent {
  constructor(options) {
    super("w:r");
    __publicField(this, "properties");
    this.properties = new RunProperties(options);
    this.root.push(this.properties);
    if (options.break) {
      for (let i2 = 0; i2 < options.break; i2++) {
        this.root.push(new Break$1());
      }
    }
    if (options.children) {
      for (const child of options.children) {
        if (typeof child === "string") {
          switch (child) {
            case PageNumber.CURRENT:
              this.root.push(new Begin());
              this.root.push(new Page());
              this.root.push(new Separate());
              this.root.push(new End());
              break;
            case PageNumber.TOTAL_PAGES:
              this.root.push(new Begin());
              this.root.push(new NumberOfPages());
              this.root.push(new Separate());
              this.root.push(new End());
              break;
            case PageNumber.TOTAL_PAGES_IN_SECTION:
              this.root.push(new Begin());
              this.root.push(new NumberOfPagesSection());
              this.root.push(new Separate());
              this.root.push(new End());
              break;
            case PageNumber.CURRENT_SECTION:
              this.root.push(new Begin());
              this.root.push(new CurrentSection());
              this.root.push(new Separate());
              this.root.push(new End());
              break;
            default:
              this.root.push(new Text(child));
              break;
          }
          continue;
        }
        this.root.push(child);
      }
    } else if (options.text !== void 0) {
      this.root.push(new Text(options.text));
    }
  }
};
var TextRun = class extends Run {
  constructor(options) {
    super(typeof options === "string" ? { text: options } : options);
  }
};
var hash$1 = {};
var utils = {};
var minimalisticAssert;
var hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1;
  minimalisticAssert = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert.equal = function assertEqual(l, r2, msg) {
    if (l != r2)
      throw new Error(msg || "Assertion failed: " + l + " != " + r2);
  };
  return minimalisticAssert;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var assert = requireMinimalisticAssert();
  var inherits = requireInherits_browser();
  utils.inherits = inherits;
  function isSurrogatePair(msg, i2) {
    if ((msg.charCodeAt(i2) & 64512) !== 55296) {
      return false;
    }
    if (i2 < 0 || i2 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c = msg.charCodeAt(i2);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i2)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      }
    } else {
      for (i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
    }
    return res;
  }
  utils.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex;
  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  }
  utils.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++) {
      var w = msg[i2];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i2 = 0, k = start; i2 < res.length; i2++, k += 4) {
      var w;
      if (endian === "big")
        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i2] = w >>> 0;
    }
    return res;
  }
  utils.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
      var m2 = msg[i2];
      if (endian === "big") {
        res[k] = m2 >>> 24;
        res[k + 1] = m2 >>> 16 & 255;
        res[k + 2] = m2 >>> 8 & 255;
        res[k + 3] = m2 & 255;
      } else {
        res[k + 3] = m2 >>> 24;
        res[k + 2] = m2 >>> 16 & 255;
        res[k + 1] = m2 >>> 8 & 255;
        res[k] = m2 & 255;
      }
    }
    return res;
  }
  utils.split32 = split32;
  function rotr32(w, b) {
    return w >>> b | w << 32 - b;
  }
  utils.rotr32 = rotr32;
  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  utils.rotl32 = rotl32;
  function sum32(a, b) {
    return a + b >>> 0;
  }
  utils.sum32 = sum32;
  function sum32_3(a, b, c) {
    return a + b + c >>> 0;
  }
  utils.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  utils.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e2) {
    return a + b + c + d + e2 >>> 0;
  }
  utils.sum32_5 = sum32_5;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r2 = al << 32 - num | ah >>> num;
    return r2 >>> 0;
  }
  utils.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  utils.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils.shr64_lo = shr64_lo;
  return utils;
}
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var utils2 = requireUtils();
  var assert = requireMinimalisticAssert();
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$1.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils2.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils2.join32(msg, 0, msg.length - r2, this.endian);
      for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
        this._update(msg, i2, i2 + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i2 = 1; i2 < k; i2++)
      res[i2] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len & 255;
    } else {
      res[i2++] = len & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      for (t2 = 8; t2 < this.padLength; t2++)
        res[i2++] = 0;
    }
    return res;
  };
  return common$1;
}
var sha = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var utils2 = requireUtils();
  var rotr32 = utils2.rotr32;
  function ft_1(s2, x2, y, z) {
    if (s2 === 0)
      return ch32(x2, y, z);
    if (s2 === 1 || s2 === 3)
      return p32(x2, y, z);
    if (s2 === 2)
      return maj32(x2, y, z);
  }
  common.ft_1 = ft_1;
  function ch32(x2, y, z) {
    return x2 & y ^ ~x2 & z;
  }
  common.ch32 = ch32;
  function maj32(x2, y, z) {
    return x2 & y ^ x2 & z ^ y & z;
  }
  common.maj32 = maj32;
  function p32(x2, y, z) {
    return x2 ^ y ^ z;
  }
  common.p32 = p32;
  function s0_256(x2) {
    return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
  }
  common.s0_256 = s0_256;
  function s1_256(x2) {
    return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
  }
  common.s1_256 = s1_256;
  function g0_256(x2) {
    return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
  }
  common.g0_256 = g0_256;
  function g1_256(x2) {
    return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
  }
  common.g1_256 = g1_256;
  return common;
}
var _1;
var hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_5 = utils2.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common2.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils2.inherits(SHA1, BlockHash);
  _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = rotl32(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e2 = this.h[4];
    for (i2 = 0; i2 < W.length; i2++) {
      var s2 = ~~(i2 / 20);
      var t2 = sum32_5(rotl32(a, 5), ft_1(s2, b, c, d), e2, W[i2], sha1_K[s2]);
      e2 = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t2;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e2);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _1;
}
var _256;
var hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var assert = requireMinimalisticAssert();
  var sum32 = utils2.sum32;
  var sum32_4 = utils2.sum32_4;
  var sum32_5 = utils2.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils2.inherits(SHA256, BlockHash);
  _256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = sum32_4(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e2 = this.h[4];
    var f3 = this.h[5];
    var g = this.h[6];
    var h2 = this.h[7];
    assert(this.k.length === W.length);
    for (i2 = 0; i2 < W.length; i2++) {
      var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f3, g), this.k[i2], W[i2]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h2 = g;
      g = f3;
      f3 = e2;
      e2 = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e2);
    this.h[5] = sum32(this.h[5], f3);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h2);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _256;
}
var _224;
var hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var utils2 = requireUtils();
  var SHA256 = require_256();
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils2.inherits(SHA224, SHA256);
  _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 7), "big");
    else
      return utils2.split32(this.h.slice(0, 7), "big");
  };
  return _224;
}
var _512;
var hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var assert = requireMinimalisticAssert();
  var rotr64_hi = utils2.rotr64_hi;
  var rotr64_lo = utils2.rotr64_lo;
  var shr64_hi = utils2.shr64_hi;
  var shr64_lo = utils2.shr64_lo;
  var sum64 = utils2.sum64;
  var sum64_hi = utils2.sum64_hi;
  var sum64_lo = utils2.sum64_lo;
  var sum64_4_hi = utils2.sum64_4_hi;
  var sum64_4_lo = utils2.sum64_4_lo;
  var sum64_5_hi = utils2.sum64_5_hi;
  var sum64_5_lo = utils2.sum64_5_lo;
  var BlockHash = common2.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils2.inherits(SHA512, BlockHash);
  _512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 32; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2 += 2) {
      var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]);
      var c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]);
      var c1_hi = W[i2 - 14];
      var c1_lo = W[i2 - 13];
      var c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]);
      var c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]);
      var c3_hi = W[i2 - 32];
      var c3_lo = W[i2 - 31];
      W[i2] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W[i2 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i2 = 0; i2 < W.length; i2 += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i2];
      var c3_lo = this.k[i2 + 1];
      var c4_hi = W[i2];
      var c4_lo = W[i2 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ ~xh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ ~xl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ xh & zh ^ yh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ xl & zl ^ yl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  return _512;
}
var _384;
var hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var utils2 = requireUtils();
  var SHA512 = require_512();
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils2.inherits(SHA384, SHA512);
  _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils2.split32(this.h.slice(0, 12), "big");
  };
  return _384;
}
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  sha.sha1 = require_1();
  sha.sha224 = require_224();
  sha.sha256 = require_256();
  sha.sha384 = require_384();
  sha.sha512 = require_512();
  return sha;
}
var ripemd = {};
var hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_3 = utils2.sum32_3;
  var sum32_4 = utils2.sum32_4;
  var BlockHash = common2.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils2.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A2 = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A2;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A2, f3(j, B, C, D), msg[r2[j] + start], K(j)),
          s2[j]
        ),
        E
      );
      A2 = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f3(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A2, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "little");
    else
      return utils2.split32(this.h, "little");
  };
  function f3(j, x2, y, z) {
    if (j <= 15)
      return x2 ^ y ^ z;
    else if (j <= 31)
      return x2 & y | ~x2 & z;
    else if (j <= 47)
      return (x2 | ~y) ^ z;
    else if (j <= 63)
      return x2 & z | y & ~z;
    else
      return x2 ^ (y | ~z);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r2 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s2 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac;
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var utils2 = requireUtils();
  var assert = requireMinimalisticAssert();
  function Hmac(hash2, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils2.toArray(key, enc));
  }
  hmac = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i2 = key.length; i2 < this.blockSize; i2++)
      key.push(0);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  return hmac;
}
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$1;
  hasRequiredHash = 1;
  (function(exports) {
    var hash2 = exports;
    hash2.utils = requireUtils();
    hash2.common = requireCommon$1();
    hash2.sha = requireSha();
    hash2.ripemd = requireRipemd();
    hash2.hmac = requireHmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash$1);
  return hash$1;
}
var hashExports = requireHash();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i2 = size | 0;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var nanoid = (size = 21) => {
  let id = "";
  let i2 = size | 0;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var convertInchesToTwip = (inches) => Math.floor(inches * 72 * 20);
var uniqueNumericIdCreator = (initial = 0) => {
  let currentCount = initial;
  return () => ++currentCount;
};
var abstractNumUniqueNumericIdGen = () => uniqueNumericIdCreator();
var concreteNumUniqueNumericIdGen = () => uniqueNumericIdCreator(1);
var bookmarkUniqueNumericIdGen = () => uniqueNumericIdCreator();
var uniqueId = () => nanoid().toLowerCase();
var generateUuidPart = (count) => customAlphabet("1234567890abcdef", count)();
var uniqueUuid = () => `${generateUuidPart(8)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(12)}`;
var RelationshipsAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
};
var RelationshipAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "Id",
      type: "Type",
      target: "Target",
      targetMode: "TargetMode"
    });
  }
};
var TargetModeType = {
  EXTERNAL: "External"
};
var Relationship = class extends XmlComponent {
  constructor(id, type2, target, targetMode) {
    super("Relationship");
    this.root.push(
      new RelationshipAttributes({
        id,
        type: type2,
        target,
        targetMode
      })
    );
  }
};
var Relationships = class extends XmlComponent {
  constructor() {
    super("Relationships");
    this.root.push(
      new RelationshipsAttributes({
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      })
    );
  }
  createRelationship(id, type2, target, targetMode) {
    const relationship = new Relationship(`rId${id}`, type2, target, targetMode);
    this.root.push(relationship);
    return relationship;
  }
  get RelationshipCount() {
    return this.root.length - 1;
  }
};
var CommentAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
  }
};
var RootCommentsAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      "xmlns:cx": "xmlns:cx",
      "xmlns:cx1": "xmlns:cx1",
      "xmlns:cx2": "xmlns:cx2",
      "xmlns:cx3": "xmlns:cx3",
      "xmlns:cx4": "xmlns:cx4",
      "xmlns:cx5": "xmlns:cx5",
      "xmlns:cx6": "xmlns:cx6",
      "xmlns:cx7": "xmlns:cx7",
      "xmlns:cx8": "xmlns:cx8",
      "xmlns:mc": "xmlns:mc",
      "xmlns:aink": "xmlns:aink",
      "xmlns:am3d": "xmlns:am3d",
      "xmlns:o": "xmlns:o",
      "xmlns:r": "xmlns:r",
      "xmlns:m": "xmlns:m",
      "xmlns:v": "xmlns:v",
      "xmlns:wp14": "xmlns:wp14",
      "xmlns:wp": "xmlns:wp",
      "xmlns:w10": "xmlns:w10",
      "xmlns:w": "xmlns:w",
      "xmlns:w14": "xmlns:w14",
      "xmlns:w15": "xmlns:w15",
      "xmlns:w16cex": "xmlns:w16cex",
      "xmlns:w16cid": "xmlns:w16cid",
      "xmlns:w16": "xmlns:w16",
      "xmlns:w16sdtdh": "xmlns:w16sdtdh",
      "xmlns:w16se": "xmlns:w16se",
      "xmlns:wpg": "xmlns:wpg",
      "xmlns:wpi": "xmlns:wpi",
      "xmlns:wne": "xmlns:wne",
      "xmlns:wps": "xmlns:wps"
    });
  }
};
var Comment = class extends XmlComponent {
  constructor({ id, initials, author, date = /* @__PURE__ */ new Date(), children }) {
    super("w:comment");
    this.root.push(
      new CommentAttributes({
        id,
        initials,
        author,
        date: date.toISOString()
      })
    );
    for (const child of children) {
      this.root.push(child);
    }
  }
};
var Comments = class extends XmlComponent {
  constructor({ children }) {
    super("w:comments");
    __publicField(this, "relationships");
    this.root.push(
      new RootCommentsAttributes({
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      })
    );
    for (const child of children) {
      this.root.push(new Comment(child));
    }
    this.relationships = new Relationships();
  }
  get Relationships() {
    return this.relationships;
  }
};
var PageBreakBefore = class extends XmlComponent {
  constructor() {
    super("w:pageBreakBefore");
  }
};
var LineRuleType = {
  AT_LEAST: "atLeast",
  EXACTLY: "exactly",
  EXACT: "exact",
  AUTO: "auto"
};
var SpacingAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      after: "w:after",
      before: "w:before",
      line: "w:line",
      lineRule: "w:lineRule",
      beforeAutoSpacing: "w:beforeAutospacing",
      afterAutoSpacing: "w:afterAutospacing"
    });
  }
};
var Spacing = class extends XmlComponent {
  constructor(options) {
    super("w:spacing");
    this.root.push(new SpacingAttributes(options));
  }
};
var HeadingLevel = {
  HEADING_1: "Heading1",
  HEADING_2: "Heading2",
  HEADING_3: "Heading3",
  HEADING_4: "Heading4",
  HEADING_5: "Heading5",
  HEADING_6: "Heading6",
  TITLE: "Title"
};
var Style$1 = class Style extends XmlComponent {
  constructor(styleId) {
    super("w:pStyle");
    this.root.push(
      new Attributes({
        val: styleId
      })
    );
  }
};
var TabStop = class extends XmlComponent {
  constructor(tabDefinitions) {
    super("w:tabs");
    for (const tabDefinition of tabDefinitions) {
      this.root.push(new TabStopItem(tabDefinition));
    }
  }
};
var TabStopType = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  BAR: "bar",
  CLEAR: "clear",
  DECIMAL: "decimal",
  END: "end",
  NUM: "num",
  START: "start"
};
var TabAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
  }
};
var TabStopItem = class extends XmlComponent {
  constructor({ type: type2, position, leader }) {
    super("w:tab");
    this.root.push(
      new TabAttributes({
        val: type2,
        pos: position,
        leader
      })
    );
  }
};
var NumberProperties = class extends XmlComponent {
  constructor(numberId, indentLevel) {
    super("w:numPr");
    this.root.push(new IndentLevel(indentLevel));
    this.root.push(new NumberId(numberId));
  }
};
var IndentLevel = class extends XmlComponent {
  constructor(level) {
    super("w:ilvl");
    if (level > 9) {
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    }
    this.root.push(
      new Attributes({
        val: level
      })
    );
  }
};
var NumberId = class extends XmlComponent {
  constructor(id) {
    super("w:numId");
    this.root.push(
      new Attributes({
        val: typeof id === "string" ? `{${id}}` : id
      })
    );
  }
};
var FileChild = class extends XmlComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "fileChild", Symbol());
  }
};
var HyperlinkAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "r:id",
      history: "w:history",
      anchor: "w:anchor"
    });
  }
};
var ConcreteHyperlink = class extends XmlComponent {
  constructor(children, relationshipId, anchor) {
    super("w:hyperlink");
    __publicField(this, "linkId");
    this.linkId = relationshipId;
    const props = {
      history: 1,
      anchor: anchor ? anchor : void 0,
      id: !anchor ? `rId${this.linkId}` : void 0
    };
    const attributes = new HyperlinkAttributes(props);
    this.root.push(attributes);
    children.forEach((child) => {
      this.root.push(child);
    });
  }
};
var ExternalHyperlink = class extends XmlComponent {
  constructor(options) {
    super("w:externalHyperlink");
    this.options = options;
  }
};
var BookmarkStartAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id",
      name: "w:name"
    });
  }
};
var BookmarkEndAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id"
    });
  }
};
var Bookmark = class {
  constructor(options) {
    __publicField(this, "bookmarkUniqueNumericId", bookmarkUniqueNumericIdGen());
    __publicField(this, "start");
    __publicField(this, "children");
    __publicField(this, "end");
    const linkId = this.bookmarkUniqueNumericId();
    this.start = new BookmarkStart(options.id, linkId);
    this.children = options.children;
    this.end = new BookmarkEnd(linkId);
  }
};
var BookmarkStart = class extends XmlComponent {
  constructor(id, linkId) {
    super("w:bookmarkStart");
    const attributes = new BookmarkStartAttributes({
      name: id,
      id: linkId
    });
    this.root.push(attributes);
  }
};
var BookmarkEnd = class extends XmlComponent {
  constructor(linkId) {
    super("w:bookmarkEnd");
    const attributes = new BookmarkEndAttributes({
      id: linkId
    });
    this.root.push(attributes);
  }
};
var OutlineLevel = class extends XmlComponent {
  constructor(level) {
    super("w:outlineLvl");
    this.level = level;
    this.root.push(
      new Attributes({
        val: level
      })
    );
  }
};
var VerticalAlignTable = {
  TOP: "top",
  CENTER: "center",
  BOTTOM: "bottom"
};
var VerticalAlignSection = __spreadProps(__spreadValues({}, VerticalAlignTable), {
  BOTH: "both"
});
var VerticalAlignAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      verticalAlign: "w:val"
    });
  }
};
var VerticalAlignElement = class extends XmlComponent {
  constructor(value) {
    super("w:vAlign");
    this.root.push(new VerticalAlignAttributes({ verticalAlign: value }));
  }
};
var Columns = class extends XmlComponent {
  constructor({ space, count, separate, equalWidth, children }) {
    super("w:cols");
    this.root.push(
      new NextAttributeComponent({
        space: { key: "w:space", value: space === void 0 ? void 0 : twipsMeasureValue(space) },
        count: { key: "w:num", value: count === void 0 ? void 0 : decimalNumber(count) },
        separate: { key: "w:sep", value: separate },
        equalWidth: { key: "w:equalWidth", value: equalWidth }
      })
    );
    if (!equalWidth && children) {
      children.forEach((column) => this.addChildElement(column));
    }
  }
};
var createDocumentGrid = ({ type: type2, linePitch, charSpace }) => new BuilderElement({
  name: "w:docGrid",
  attributes: {
    type: { key: "w:type", value: type2 },
    linePitch: { key: "w:linePitch", value: decimalNumber(linePitch) },
    charSpace: { key: "w:charSpace", value: charSpace ? decimalNumber(charSpace) : void 0 }
  }
});
var HeaderFooterReferenceType = {
  /** Specifies that this header or footer shall appear on every page in this section which is not overridden with a specific `even` or `first` page header/footer. In a section with all three types specified, this type shall be used on all odd numbered pages (counting from the `first` page in the section, not the section numbering). */
  DEFAULT: "default",
  /** Specifies that this header or footer shall appear on the first page in this section. The appearance of this header or footer is contingent on the setting of the `titlePg` element (§2.10.6). */
  FIRST: "first",
  /** Specifies that this header or footer shall appear on all even numbered pages in this section (counting from the first page in the section, not the section numbering). The appearance of this header or footer is contingent on the setting of the `evenAndOddHeaders` element (§2.10.1). */
  EVEN: "even"
};
var FooterReferenceAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      id: "r:id"
    });
  }
};
var HeaderFooterType = {
  HEADER: "w:headerReference",
  FOOTER: "w:footerReference"
};
var HeaderFooterReference = class extends XmlComponent {
  constructor(type2, options) {
    super(type2);
    this.root.push(
      new FooterReferenceAttributes({
        type: options.type || HeaderFooterReferenceType.DEFAULT,
        id: `rId${options.id}`
      })
    );
  }
};
var createLineNumberType = ({ countBy, start, restart, distance }) => new BuilderElement({
  name: "w:lnNumType",
  attributes: {
    countBy: { key: "w:countBy", value: countBy === void 0 ? void 0 : decimalNumber(countBy) },
    start: { key: "w:start", value: start === void 0 ? void 0 : decimalNumber(start) },
    restart: { key: "w:restart", value: restart },
    distance: {
      key: "w:distance",
      value: distance === void 0 ? void 0 : twipsMeasureValue(distance)
    }
  }
});
var PageBordersAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      display: "w:display",
      offsetFrom: "w:offsetFrom",
      zOrder: "w:zOrder"
    });
  }
};
var PageBorders = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:pgBorders");
    if (!options) {
      return this;
    }
    if (options.pageBorders) {
      this.root.push(
        new PageBordersAttributes({
          display: options.pageBorders.display,
          offsetFrom: options.pageBorders.offsetFrom,
          zOrder: options.pageBorders.zOrder
        })
      );
    } else {
      this.root.push(new PageBordersAttributes({}));
    }
    if (options.pageBorderTop) {
      this.root.push(new BorderElement("w:top", options.pageBorderTop));
    }
    if (options.pageBorderLeft) {
      this.root.push(new BorderElement("w:left", options.pageBorderLeft));
    }
    if (options.pageBorderBottom) {
      this.root.push(new BorderElement("w:bottom", options.pageBorderBottom));
    }
    if (options.pageBorderRight) {
      this.root.push(new BorderElement("w:right", options.pageBorderRight));
    }
  }
};
var PageMargin = class extends XmlComponent {
  constructor(top, right, bottom, left, header, footer, gutter) {
    super("w:pgMar");
    this.root.push(
      new NextAttributeComponent({
        top: { key: "w:top", value: signedTwipsMeasureValue(top) },
        right: { key: "w:right", value: twipsMeasureValue(right) },
        bottom: { key: "w:bottom", value: signedTwipsMeasureValue(bottom) },
        left: { key: "w:left", value: twipsMeasureValue(left) },
        header: { key: "w:header", value: twipsMeasureValue(header) },
        footer: { key: "w:footer", value: twipsMeasureValue(footer) },
        gutter: { key: "w:gutter", value: twipsMeasureValue(gutter) }
      })
    );
  }
};
var PageNumberTypeAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      start: "w:start",
      formatType: "w:fmt",
      separator: "w:chapSep"
    });
  }
};
var PageNumberType = class extends XmlComponent {
  constructor({ start, formatType, separator }) {
    super("w:pgNumType");
    this.root.push(
      new PageNumberTypeAttributes({
        start: start === void 0 ? void 0 : decimalNumber(start),
        formatType,
        separator
      })
    );
  }
};
var PageOrientation = {
  /**
   * ## Portrait Mode
   *
   * Specifies that pages in this section shall be printed in portrait mode.
   */
  PORTRAIT: "portrait",
  /**
   * ## Landscape Mode
   *
   * Specifies that pages in this section shall be printed in landscape mode, which prints the page contents with a 90 degree rotation with respect to the normal page orientation.
   */
  LANDSCAPE: "landscape"
};
var createPageSize = ({ width, height, orientation, code }) => {
  const widthTwips = twipsMeasureValue(width);
  const heightTwips = twipsMeasureValue(height);
  return new BuilderElement({
    name: "w:pgSz",
    attributes: {
      width: { key: "w:w", value: orientation === PageOrientation.LANDSCAPE ? heightTwips : widthTwips },
      height: { key: "w:h", value: orientation === PageOrientation.LANDSCAPE ? widthTwips : heightTwips },
      orientation: { key: "w:orient", value: orientation },
      code: { key: "w:code", value: code }
    }
  });
};
var PageTextDirectionAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var PageTextDirection = class extends XmlComponent {
  constructor(value) {
    super("w:textDirection");
    this.root.push(
      new PageTextDirectionAttributes({
        val: value
      })
    );
  }
};
var SectionTypeAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      val: "w:val"
    });
  }
};
var Type = class extends XmlComponent {
  constructor(value) {
    super("w:type");
    this.root.push(new SectionTypeAttributes({ val: value }));
  }
};
var sectionMarginDefaults = {
  TOP: 1440,
  RIGHT: 1440,
  BOTTOM: 1440,
  LEFT: 1440,
  HEADER: 708,
  FOOTER: 708,
  GUTTER: 0
};
var sectionPageSizeDefaults = {
  WIDTH: 11906,
  HEIGHT: 16838,
  ORIENTATION: PageOrientation.PORTRAIT
};
var SectionProperties = class extends XmlComponent {
  constructor({
    page: {
      size: {
        width = sectionPageSizeDefaults.WIDTH,
        height = sectionPageSizeDefaults.HEIGHT,
        orientation = sectionPageSizeDefaults.ORIENTATION
      } = {},
      margin: {
        top = sectionMarginDefaults.TOP,
        right = sectionMarginDefaults.RIGHT,
        bottom = sectionMarginDefaults.BOTTOM,
        left = sectionMarginDefaults.LEFT,
        header = sectionMarginDefaults.HEADER,
        footer = sectionMarginDefaults.FOOTER,
        gutter = sectionMarginDefaults.GUTTER
      } = {},
      pageNumbers = {},
      borders,
      textDirection
    } = {},
    grid: { linePitch = 360, charSpace, type: gridType } = {},
    headerWrapperGroup = {},
    footerWrapperGroup = {},
    lineNumbers,
    titlePage,
    verticalAlign,
    column,
    type: type2
  } = {}) {
    super("w:sectPr");
    this.addHeaderFooterGroup(HeaderFooterType.HEADER, headerWrapperGroup);
    this.addHeaderFooterGroup(HeaderFooterType.FOOTER, footerWrapperGroup);
    if (type2) {
      this.root.push(new Type(type2));
    }
    this.root.push(createPageSize({ width, height, orientation }));
    this.root.push(new PageMargin(top, right, bottom, left, header, footer, gutter));
    if (borders) {
      this.root.push(new PageBorders(borders));
    }
    if (lineNumbers) {
      this.root.push(createLineNumberType(lineNumbers));
    }
    this.root.push(new PageNumberType(pageNumbers));
    if (column) {
      this.root.push(new Columns(column));
    }
    if (verticalAlign) {
      this.root.push(new VerticalAlignElement(verticalAlign));
    }
    if (titlePage !== void 0) {
      this.root.push(new OnOffElement("w:titlePg", titlePage));
    }
    if (textDirection) {
      this.root.push(new PageTextDirection(textDirection));
    }
    this.root.push(createDocumentGrid({ linePitch, charSpace, type: gridType }));
  }
  addHeaderFooterGroup(type2, group) {
    if (group.default) {
      this.root.push(
        new HeaderFooterReference(type2, {
          type: HeaderFooterReferenceType.DEFAULT,
          id: group.default.View.ReferenceId
        })
      );
    }
    if (group.first) {
      this.root.push(
        new HeaderFooterReference(type2, {
          type: HeaderFooterReferenceType.FIRST,
          id: group.first.View.ReferenceId
        })
      );
    }
    if (group.even) {
      this.root.push(
        new HeaderFooterReference(type2, {
          type: HeaderFooterReferenceType.EVEN,
          id: group.even.View.ReferenceId
        })
      );
    }
  }
};
var Body = class extends XmlComponent {
  constructor() {
    super("w:body");
    __publicField(this, "sections", []);
  }
  /**
   * Adds new section properties.
   * Note: Previous section is created in paragraph after the current element, and then new section will be added.
   * The spec says:
   *  - section element should be in the last paragraph of the section
   *  - last section should be direct child of body
   *
   * @param options new section options
   */
  addSection(options) {
    const currentSection = this.sections.pop();
    this.root.push(this.createSectionParagraph(currentSection));
    this.sections.push(new SectionProperties(options));
  }
  prepForXml(context) {
    if (this.sections.length === 1) {
      this.root.splice(0, 1);
      this.root.push(this.sections.pop());
    }
    return super.prepForXml(context);
  }
  push(component) {
    this.root.push(component);
  }
  createSectionParagraph(section) {
    const paragraph = new Paragraph({});
    const properties = new ParagraphProperties({});
    properties.push(section);
    paragraph.addChildElement(properties);
    return paragraph;
  }
};
var DocumentAttributeNamespaces = {
  wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
  mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
  o: "urn:schemas-microsoft-com:office:office",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
  v: "urn:schemas-microsoft-com:vml",
  wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
  wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  w10: "urn:schemas-microsoft-com:office:word",
  w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  w14: "http://schemas.microsoft.com/office/word/2010/wordml",
  w15: "http://schemas.microsoft.com/office/word/2012/wordml",
  wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
  wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
  wne: "http://schemas.microsoft.com/office/word/2006/wordml",
  wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
  cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
  cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
  cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
  cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
  cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
  cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
  cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
  cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
  cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
  aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
  am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
  w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
  w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
  w16: "http://schemas.microsoft.com/office/word/2018/wordml",
  w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
  w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
};
var DocumentAttributes = class extends XmlAttributeComponent {
  constructor(ns, Ignorable) {
    super(__spreadValues({ Ignorable }, Object.fromEntries(ns.map((n) => [n, DocumentAttributeNamespaces[n]]))));
    __publicField(this, "xmlKeys", __spreadValues({
      Ignorable: "mc:Ignorable"
    }, Object.fromEntries(Object.keys(DocumentAttributeNamespaces).map((key) => [key, `xmlns:${key}`]))));
  }
};
var DocumentBackgroundAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      color: "w:color",
      themeColor: "w:themeColor",
      themeShade: "w:themeShade",
      themeTint: "w:themeTint"
    });
  }
};
var DocumentBackground = class extends XmlComponent {
  constructor(options) {
    super("w:background");
    this.root.push(
      new DocumentBackgroundAttributes({
        color: options.color === void 0 ? void 0 : hexColorValue(options.color),
        themeColor: options.themeColor,
        themeShade: options.themeShade === void 0 ? void 0 : uCharHexNumber(options.themeShade),
        themeTint: options.themeTint === void 0 ? void 0 : uCharHexNumber(options.themeTint)
      })
    );
  }
};
var Document = class extends XmlComponent {
  constructor(options) {
    super("w:document");
    __publicField(this, "body");
    this.root.push(
      new DocumentAttributes(
        [
          "wpc",
          "mc",
          "o",
          "r",
          "m",
          "v",
          "wp14",
          "wp",
          "w10",
          "w",
          "w14",
          "w15",
          "wpg",
          "wpi",
          "wne",
          "wps",
          "cx",
          "cx1",
          "cx2",
          "cx3",
          "cx4",
          "cx5",
          "cx6",
          "cx7",
          "cx8",
          "aink",
          "am3d",
          "w16cex",
          "w16cid",
          "w16",
          "w16sdtdh",
          "w16se"
        ],
        "w14 w15 wp14"
      )
    );
    this.body = new Body();
    if (options.background) {
      this.root.push(new DocumentBackground(options.background));
    }
    this.root.push(this.body);
  }
  add(item) {
    this.body.push(item);
    return this;
  }
  get Body() {
    return this.body;
  }
};
var DocumentWrapper = class {
  constructor(options) {
    __publicField(this, "document");
    __publicField(this, "relationships");
    this.document = new Document(options);
    this.relationships = new Relationships();
  }
  get View() {
    return this.document;
  }
  get Relationships() {
    return this.relationships;
  }
};
var WordWrapAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var WordWrap = class extends XmlComponent {
  constructor() {
    super("w:wordWrap");
    this.root.push(new WordWrapAttributes({ val: 0 }));
  }
};
var createFrameProperties = (options) => {
  var _a, _b;
  return new BuilderElement({
    name: "w:framePr",
    attributes: {
      anchorLock: {
        key: "w:anchorLock",
        value: options.anchorLock
      },
      dropCap: {
        key: "w:dropCap",
        value: options.dropCap
      },
      width: {
        key: "w:w",
        value: options.width
      },
      height: {
        key: "w:h",
        value: options.height
      },
      x: {
        key: "w:x",
        value: options.position ? options.position.x : void 0
      },
      y: {
        key: "w:y",
        value: options.position ? options.position.y : void 0
      },
      anchorHorizontal: {
        key: "w:hAnchor",
        value: options.anchor.horizontal
      },
      anchorVertical: {
        key: "w:vAnchor",
        value: options.anchor.vertical
      },
      spaceHorizontal: {
        key: "w:hSpace",
        value: (_a = options.space) == null ? void 0 : _a.horizontal
      },
      spaceVertical: {
        key: "w:vSpace",
        value: (_b = options.space) == null ? void 0 : _b.vertical
      },
      rule: {
        key: "w:hRule",
        value: options.rule
      },
      alignmentX: {
        key: "w:xAlign",
        value: options.alignment ? options.alignment.x : void 0
      },
      alignmentY: {
        key: "w:yAlign",
        value: options.alignment ? options.alignment.y : void 0
      },
      lines: {
        key: "w:lines",
        value: options.lines
      },
      wrap: {
        key: "w:wrap",
        value: options.wrap
      }
    }
  });
};
var ParagraphProperties = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    var _a, _b;
    super("w:pPr");
    __publicField(this, "numberingReferences", []);
    if (!options) {
      return this;
    }
    if (options.heading) {
      this.push(new Style$1(options.heading));
    }
    if (options.bullet) {
      this.push(new Style$1("ListParagraph"));
    }
    if (options.numbering) {
      if (!options.style && !options.heading) {
        if (!options.numbering.custom) {
          this.push(new Style$1("ListParagraph"));
        }
      }
    }
    if (options.style) {
      this.push(new Style$1(options.style));
    }
    if (options.keepNext !== void 0) {
      this.push(new OnOffElement("w:keepNext", options.keepNext));
    }
    if (options.keepLines !== void 0) {
      this.push(new OnOffElement("w:keepLines", options.keepLines));
    }
    if (options.pageBreakBefore) {
      this.push(new PageBreakBefore());
    }
    if (options.frame) {
      this.push(createFrameProperties(options.frame));
    }
    if (options.widowControl !== void 0) {
      this.push(new OnOffElement("w:widowControl", options.widowControl));
    }
    if (options.bullet) {
      this.push(new NumberProperties(1, options.bullet.level));
    }
    if (options.numbering) {
      this.numberingReferences.push({
        reference: options.numbering.reference,
        instance: (_a = options.numbering.instance) != null ? _a : 0
      });
      this.push(new NumberProperties(`${options.numbering.reference}-${(_b = options.numbering.instance) != null ? _b : 0}`, options.numbering.level));
    } else if (options.numbering === false) {
      this.push(new NumberProperties(0, 0));
    }
    if (options.border) {
      this.push(new Border(options.border));
    }
    if (options.thematicBreak) {
      this.push(new ThematicBreak());
    }
    if (options.shading) {
      this.push(new Shading(options.shading));
    }
    if (options.wordWrap) {
      this.push(new WordWrap());
    }
    if (options.overflowPunctuation) {
      this.push(new OnOffElement("w:overflowPunct", options.overflowPunctuation));
    }
    const tabDefinitions = [
      ...options.rightTabStop !== void 0 ? [{ type: TabStopType.RIGHT, position: options.rightTabStop }] : [],
      ...options.tabStops ? options.tabStops : [],
      ...options.leftTabStop !== void 0 ? [{ type: TabStopType.LEFT, position: options.leftTabStop }] : []
    ];
    if (tabDefinitions.length > 0) {
      this.push(new TabStop(tabDefinitions));
    }
    if (options.bidirectional !== void 0) {
      this.push(new OnOffElement("w:bidi", options.bidirectional));
    }
    if (options.spacing) {
      this.push(new Spacing(options.spacing));
    }
    if (options.indent) {
      this.push(new Indent(options.indent));
    }
    if (options.contextualSpacing !== void 0) {
      this.push(new OnOffElement("w:contextualSpacing", options.contextualSpacing));
    }
    if (options.alignment) {
      this.push(new Alignment(options.alignment));
    }
    if (options.outlineLevel !== void 0) {
      this.push(new OutlineLevel(options.outlineLevel));
    }
    if (options.suppressLineNumbers !== void 0) {
      this.push(new OnOffElement("w:suppressLineNumbers", options.suppressLineNumbers));
    }
    if (options.autoSpaceEastAsianText !== void 0) {
      this.push(new OnOffElement("w:autoSpaceDN", options.autoSpaceEastAsianText));
    }
    if (options.run) {
      this.push(new RunProperties(options.run));
    }
  }
  push(item) {
    this.root.push(item);
  }
  prepForXml(context) {
    if (context.viewWrapper instanceof DocumentWrapper) {
      for (const reference of this.numberingReferences) {
        context.file.Numbering.createConcreteNumberingInstance(reference.reference, reference.instance);
      }
    }
    return super.prepForXml(context);
  }
};
var Paragraph = class extends FileChild {
  constructor(options) {
    super("w:p");
    __publicField(this, "properties");
    if (typeof options === "string") {
      this.properties = new ParagraphProperties({});
      this.root.push(this.properties);
      this.root.push(new TextRun(options));
      return this;
    }
    this.properties = new ParagraphProperties(options);
    this.root.push(this.properties);
    if (options.text) {
      this.root.push(new TextRun(options.text));
    }
    if (options.children) {
      for (const child of options.children) {
        if (child instanceof Bookmark) {
          this.root.push(child.start);
          for (const textRun of child.children) {
            this.root.push(textRun);
          }
          this.root.push(child.end);
          continue;
        }
        this.root.push(child);
      }
    }
  }
  prepForXml(context) {
    for (const element of this.root) {
      if (element instanceof ExternalHyperlink) {
        const index = this.root.indexOf(element);
        const concreteHyperlink = new ConcreteHyperlink(element.options.children, uniqueId());
        context.viewWrapper.Relationships.createRelationship(
          concreteHyperlink.linkId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          element.options.link,
          TargetModeType.EXTERNAL
        );
        this.root[index] = concreteHyperlink;
      }
    }
    return super.prepForXml(context);
  }
  addRunToFront(run) {
    this.root.splice(1, 0, run);
    return this;
  }
};
var TableGrid = class extends XmlComponent {
  constructor(widths) {
    super("w:tblGrid");
    for (const width of widths) {
      this.root.push(new GridCol(width));
    }
  }
};
var GridCol = class extends XmlComponent {
  constructor(width) {
    super("w:gridCol");
    if (width !== void 0) {
      this.root.push(
        new NextAttributeComponent({
          width: { key: "w:w", value: twipsMeasureValue(width) }
        })
      );
    }
  }
};
var TableCellMarginElementType = {
  TABLE: "w:tblCellMar",
  TABLE_CELL: "w:tcMar"
};
var TableCellMargin = class extends IgnoreIfEmptyXmlComponent {
  constructor(type2, { marginUnitType = WidthType.DXA, top, left, bottom, right }) {
    super(type2);
    if (top !== void 0) {
      this.root.push(new TableWidthElement("w:top", { type: marginUnitType, size: top }));
    }
    if (left !== void 0) {
      this.root.push(new TableWidthElement("w:left", { type: marginUnitType, size: left }));
    }
    if (bottom !== void 0) {
      this.root.push(new TableWidthElement("w:bottom", { type: marginUnitType, size: bottom }));
    }
    if (right !== void 0) {
      this.root.push(new TableWidthElement("w:right", { type: marginUnitType, size: right }));
    }
  }
};
var WidthType = {
  /** Auto. */
  AUTO: "auto",
  /** Value is in twentieths of a point */
  DXA: "dxa",
  /** No (empty) value. */
  NIL: "nil",
  /** Value is in percentage. */
  PERCENTAGE: "pct"
};
var TableWidthElement = class extends XmlComponent {
  constructor(name, { type: type2 = WidthType.AUTO, size }) {
    super(name);
    let tableWidthValue = size;
    if (type2 === WidthType.PERCENTAGE && typeof size === "number") {
      tableWidthValue = `${size}%`;
    }
    this.root.push(
      new NextAttributeComponent({
        type: { key: "w:type", value: type2 },
        size: { key: "w:w", value: measurementOrPercentValue(tableWidthValue) }
      })
    );
  }
};
var TableCellBorders = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:tcBorders");
    if (options.top) {
      this.root.push(new BorderElement("w:top", options.top));
    }
    if (options.start) {
      this.root.push(new BorderElement("w:start", options.start));
    }
    if (options.left) {
      this.root.push(new BorderElement("w:left", options.left));
    }
    if (options.bottom) {
      this.root.push(new BorderElement("w:bottom", options.bottom));
    }
    if (options.end) {
      this.root.push(new BorderElement("w:end", options.end));
    }
    if (options.right) {
      this.root.push(new BorderElement("w:right", options.right));
    }
  }
};
var GridSpanAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var GridSpan = class extends XmlComponent {
  constructor(value) {
    super("w:gridSpan");
    this.root.push(
      new GridSpanAttributes({
        val: decimalNumber(value)
      })
    );
  }
};
var VerticalMergeType = {
  /**
   * Cell that is merged with upper one.
   */
  CONTINUE: "continue",
  /**
   * Cell that is starting the vertical merge.
   */
  RESTART: "restart"
};
var VerticalMergeAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var VerticalMerge = class extends XmlComponent {
  constructor(value) {
    super("w:vMerge");
    this.root.push(
      new VerticalMergeAttributes({
        val: value
      })
    );
  }
};
var TDirectionAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var TDirection = class extends XmlComponent {
  constructor(value) {
    super("w:textDirection");
    this.root.push(
      new TDirectionAttributes({
        val: value
      })
    );
  }
};
var TableCellProperties = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:tcPr");
    if (options.width) {
      this.root.push(new TableWidthElement("w:tcW", options.width));
    }
    if (options.columnSpan) {
      this.root.push(new GridSpan(options.columnSpan));
    }
    if (options.verticalMerge) {
      this.root.push(new VerticalMerge(options.verticalMerge));
    } else if (options.rowSpan && options.rowSpan > 1) {
      this.root.push(new VerticalMerge(VerticalMergeType.RESTART));
    }
    if (options.borders) {
      this.root.push(new TableCellBorders(options.borders));
    }
    if (options.shading) {
      this.root.push(new Shading(options.shading));
    }
    if (options.margins) {
      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE_CELL, options.margins));
    }
    if (options.textDirection) {
      this.root.push(new TDirection(options.textDirection));
    }
    if (options.verticalAlign) {
      this.root.push(new VerticalAlignElement(options.verticalAlign));
    }
  }
};
var TableCell = class extends XmlComponent {
  constructor(options) {
    super("w:tc");
    this.options = options;
    this.root.push(new TableCellProperties(options));
    for (const child of options.children) {
      this.root.push(child);
    }
  }
  prepForXml(context) {
    if (!(this.root[this.root.length - 1] instanceof Paragraph)) {
      this.root.push(new Paragraph({}));
    }
    return super.prepForXml(context);
  }
};
var NONE_BORDER = {
  style: BorderStyle.NONE,
  size: 0,
  color: "auto"
};
var DEFAULT_BORDER = {
  style: BorderStyle.SINGLE,
  size: 4,
  color: "auto"
};
var TableBorders = class extends XmlComponent {
  constructor(options) {
    super("w:tblBorders");
    if (options.top) {
      this.root.push(new BorderElement("w:top", options.top));
    } else {
      this.root.push(new BorderElement("w:top", DEFAULT_BORDER));
    }
    if (options.left) {
      this.root.push(new BorderElement("w:left", options.left));
    } else {
      this.root.push(new BorderElement("w:left", DEFAULT_BORDER));
    }
    if (options.bottom) {
      this.root.push(new BorderElement("w:bottom", options.bottom));
    } else {
      this.root.push(new BorderElement("w:bottom", DEFAULT_BORDER));
    }
    if (options.right) {
      this.root.push(new BorderElement("w:right", options.right));
    } else {
      this.root.push(new BorderElement("w:right", DEFAULT_BORDER));
    }
    if (options.insideHorizontal) {
      this.root.push(new BorderElement("w:insideH", options.insideHorizontal));
    } else {
      this.root.push(new BorderElement("w:insideH", DEFAULT_BORDER));
    }
    if (options.insideVertical) {
      this.root.push(new BorderElement("w:insideV", options.insideVertical));
    } else {
      this.root.push(new BorderElement("w:insideV", DEFAULT_BORDER));
    }
  }
};
__publicField(TableBorders, "NONE", {
  top: NONE_BORDER,
  bottom: NONE_BORDER,
  left: NONE_BORDER,
  right: NONE_BORDER,
  insideHorizontal: NONE_BORDER,
  insideVertical: NONE_BORDER
});
var TableFloatProperties = class extends XmlComponent {
  constructor({
    horizontalAnchor,
    verticalAnchor,
    absoluteHorizontalPosition,
    relativeHorizontalPosition,
    absoluteVerticalPosition,
    relativeVerticalPosition,
    bottomFromText,
    topFromText,
    leftFromText,
    rightFromText,
    overlap
  }) {
    super("w:tblpPr");
    this.root.push(
      new NextAttributeComponent({
        leftFromText: {
          key: "w:leftFromText",
          value: leftFromText === void 0 ? void 0 : twipsMeasureValue(leftFromText)
        },
        rightFromText: {
          key: "w:rightFromText",
          value: rightFromText === void 0 ? void 0 : twipsMeasureValue(rightFromText)
        },
        topFromText: {
          key: "w:topFromText",
          value: topFromText === void 0 ? void 0 : twipsMeasureValue(topFromText)
        },
        bottomFromText: {
          key: "w:bottomFromText",
          value: bottomFromText === void 0 ? void 0 : twipsMeasureValue(bottomFromText)
        },
        absoluteHorizontalPosition: {
          key: "w:tblpX",
          value: absoluteHorizontalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteHorizontalPosition)
        },
        absoluteVerticalPosition: {
          key: "w:tblpY",
          value: absoluteVerticalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteVerticalPosition)
        },
        horizontalAnchor: {
          key: "w:horzAnchor",
          value: horizontalAnchor === void 0 ? void 0 : horizontalAnchor
        },
        relativeHorizontalPosition: {
          key: "w:tblpXSpec",
          value: relativeHorizontalPosition
        },
        relativeVerticalPosition: {
          key: "w:tblpYSpec",
          value: relativeVerticalPosition
        },
        verticalAnchor: {
          key: "w:vertAnchor",
          value: verticalAnchor
        }
      })
    );
    if (overlap) {
      this.root.push(new StringEnumValueElement("w:tblOverlap", overlap));
    }
  }
};
var TableLayoutAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { type: "w:type" });
  }
};
var TableLayout = class extends XmlComponent {
  constructor(type2) {
    super("w:tblLayout");
    this.root.push(new TableLayoutAttributes({ type: type2 }));
  }
};
var CellSpacingType = {
  /** Value is in twentieths of a point */
  DXA: "dxa"
};
var TableCellSpacingElement = class extends XmlComponent {
  constructor({ type: type2 = CellSpacingType.DXA, value }) {
    super("w:tblCellSpacing");
    this.root.push(
      new NextAttributeComponent({
        type: { key: "w:type", value: type2 },
        value: { key: "w:w", value: measurementOrPercentValue(value) }
      })
    );
  }
};
var TableProperties = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:tblPr");
    if (options.style) {
      this.root.push(new StringValueElement("w:tblStyle", options.style));
    }
    if (options.float) {
      this.root.push(new TableFloatProperties(options.float));
    }
    if (options.visuallyRightToLeft !== void 0) {
      this.root.push(new OnOffElement("w:bidiVisual", options.visuallyRightToLeft));
    }
    if (options.width) {
      this.root.push(new TableWidthElement("w:tblW", options.width));
    }
    if (options.alignment) {
      this.root.push(new Alignment(options.alignment));
    }
    if (options.indent) {
      this.root.push(new TableWidthElement("w:tblInd", options.indent));
    }
    if (options.borders) {
      this.root.push(new TableBorders(options.borders));
    }
    if (options.shading) {
      this.root.push(new Shading(options.shading));
    }
    if (options.layout) {
      this.root.push(new TableLayout(options.layout));
    }
    if (options.cellMargin) {
      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE, options.cellMargin));
    }
    if (options.cellSpacing) {
      this.root.push(new TableCellSpacingElement(options.cellSpacing));
    }
  }
};
var Table = class extends FileChild {
  constructor({
    rows,
    width,
    // eslint-disable-next-line functional/immutable-data
    columnWidths = Array(Math.max(...rows.map((row) => row.CellCount))).fill(100),
    margins,
    indent,
    float,
    layout,
    style,
    borders,
    alignment,
    visuallyRightToLeft,
    cellSpacing
  }) {
    super("w:tbl");
    this.root.push(
      new TableProperties({
        borders: borders != null ? borders : {},
        width: width != null ? width : { size: 100 },
        indent,
        float,
        layout,
        style,
        alignment,
        cellMargin: margins,
        visuallyRightToLeft,
        cellSpacing
      })
    );
    this.root.push(new TableGrid(columnWidths));
    for (const row of rows) {
      this.root.push(row);
    }
    rows.forEach((row, rowIndex) => {
      if (rowIndex === rows.length - 1) {
        return;
      }
      let columnIndex = 0;
      row.cells.forEach((cell) => {
        if (cell.options.rowSpan && cell.options.rowSpan > 1) {
          const continueCell = new TableCell({
            // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row
            rowSpan: cell.options.rowSpan - 1,
            columnSpan: cell.options.columnSpan,
            borders: cell.options.borders,
            children: [],
            verticalMerge: VerticalMergeType.CONTINUE
          });
          rows[rowIndex + 1].addCellToColumnIndex(continueCell, columnIndex);
        }
        columnIndex += cell.options.columnSpan || 1;
      });
    });
  }
};
var TableRowHeightAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
  }
};
var TableRowHeight = class extends XmlComponent {
  constructor(value, rule) {
    super("w:trHeight");
    this.root.push(
      new TableRowHeightAttributes({
        value: twipsMeasureValue(value),
        rule
      })
    );
  }
};
var TableRowProperties = class extends IgnoreIfEmptyXmlComponent {
  constructor(options) {
    super("w:trPr");
    if (options.cantSplit !== void 0) {
      this.root.push(new OnOffElement("w:cantSplit", options.cantSplit));
    }
    if (options.tableHeader !== void 0) {
      this.root.push(new OnOffElement("w:tblHeader", options.tableHeader));
    }
    if (options.height) {
      this.root.push(new TableRowHeight(options.height.value, options.height.rule));
    }
    if (options.cellSpacing) {
      this.root.push(new TableCellSpacingElement(options.cellSpacing));
    }
  }
};
var TableRow = class extends XmlComponent {
  constructor(options) {
    super("w:tr");
    this.options = options;
    this.root.push(new TableRowProperties(options));
    for (const child of options.children) {
      this.root.push(child);
    }
  }
  get CellCount() {
    return this.options.children.length;
  }
  get cells() {
    return this.root.filter((xmlComponent) => xmlComponent instanceof TableCell);
  }
  addCellToIndex(cell, index) {
    this.root.splice(index + 1, 0, cell);
  }
  addCellToColumnIndex(cell, columnIndex) {
    const rootIndex = this.columnIndexToRootIndex(columnIndex, true);
    this.addCellToIndex(cell, rootIndex - 1);
  }
  rootIndexToColumnIndex(rootIndex) {
    if (rootIndex < 1 || rootIndex >= this.root.length) {
      throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
    }
    let colIdx = 0;
    for (let rootIdx = 1; rootIdx < rootIndex; rootIdx++) {
      const cell = this.root[rootIdx];
      colIdx += cell.options.columnSpan || 1;
    }
    return colIdx;
  }
  columnIndexToRootIndex(columnIndex, allowEndNewCell = false) {
    if (columnIndex < 0) {
      throw new Error(`cell 'columnIndex' should not less than zero`);
    }
    let colIdx = 0;
    let rootIdx = 1;
    while (colIdx <= columnIndex) {
      if (rootIdx >= this.root.length) {
        if (allowEndNewCell) {
          return this.root.length;
        } else {
          throw new Error(`cell 'columnIndex' should not great than ${colIdx - 1}`);
        }
      }
      const cell = this.root[rootIdx];
      rootIdx += 1;
      colIdx += cell && cell.options.columnSpan || 1;
    }
    return rootIdx - 1;
  }
};
var AppPropertiesAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
};
var AppProperties = class extends XmlComponent {
  constructor() {
    super("Properties");
    this.root.push(
      new AppPropertiesAttributes({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    );
  }
};
var ContentTypeAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
};
var DefaultAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      contentType: "ContentType",
      extension: "Extension"
    });
  }
};
var Default = class extends XmlComponent {
  constructor(contentType, extension) {
    super("Default");
    this.root.push(
      new DefaultAttributes({
        contentType,
        extension
      })
    );
  }
};
var OverrideAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      contentType: "ContentType",
      partName: "PartName"
    });
  }
};
var Override = class extends XmlComponent {
  constructor(contentType, partName) {
    super("Override");
    this.root.push(
      new OverrideAttributes({
        contentType,
        partName
      })
    );
  }
};
var ContentTypes = class extends XmlComponent {
  constructor() {
    super("Types");
    this.root.push(
      new ContentTypeAttributes({
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      })
    );
    this.root.push(new Default("image/png", "png"));
    this.root.push(new Default("image/jpeg", "jpeg"));
    this.root.push(new Default("image/jpeg", "jpg"));
    this.root.push(new Default("image/bmp", "bmp"));
    this.root.push(new Default("image/gif", "gif"));
    this.root.push(new Default("image/svg+xml", "svg"));
    this.root.push(new Default("application/vnd.openxmlformats-package.relationships+xml", "rels"));
    this.root.push(new Default("application/xml", "xml"));
    this.root.push(new Default("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf"));
    this.root.push(
      new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml")
    );
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
  }
  addFooter(index) {
    this.root.push(
      new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${index}.xml`)
    );
  }
  addHeader(index) {
    this.root.push(
      new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${index}.xml`)
    );
  }
};
var CoreProperties = class extends XmlComponent {
  constructor(options) {
    super("cp:coreProperties");
    this.root.push(new DocumentAttributes(["cp", "dc", "dcterms", "dcmitype", "xsi"]));
    if (options.title) {
      this.root.push(new StringContainer("dc:title", options.title));
    }
    if (options.subject) {
      this.root.push(new StringContainer("dc:subject", options.subject));
    }
    if (options.creator) {
      this.root.push(new StringContainer("dc:creator", options.creator));
    }
    if (options.keywords) {
      this.root.push(new StringContainer("cp:keywords", options.keywords));
    }
    if (options.description) {
      this.root.push(new StringContainer("dc:description", options.description));
    }
    if (options.lastModifiedBy) {
      this.root.push(new StringContainer("cp:lastModifiedBy", options.lastModifiedBy));
    }
    if (options.revision) {
      this.root.push(new StringContainer("cp:revision", String(options.revision)));
    }
    this.root.push(new TimestampElement("dcterms:created"));
    this.root.push(new TimestampElement("dcterms:modified"));
  }
};
var TimestampElementProperties = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { type: "xsi:type" });
  }
};
var TimestampElement = class extends XmlComponent {
  constructor(name) {
    super(name);
    this.root.push(
      new TimestampElementProperties({
        type: "dcterms:W3CDTF"
      })
    );
    this.root.push(dateTimeValue(/* @__PURE__ */ new Date()));
  }
};
var CustomPropertiesAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
};
var CustomPropertyAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      fmtid: "fmtid",
      pid: "pid",
      name: "name"
    });
  }
};
var CustomProperty = class extends XmlComponent {
  constructor(id, properties) {
    super("property");
    this.root.push(
      new CustomPropertyAttributes({
        fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        pid: id.toString(),
        name: properties.name
      })
    );
    this.root.push(new CustomPropertyValue(properties.value));
  }
};
var CustomPropertyValue = class extends XmlComponent {
  constructor(value) {
    super("vt:lpwstr");
    this.root.push(value);
  }
};
var CustomProperties = class extends XmlComponent {
  constructor(properties) {
    super("Properties");
    __publicField(this, "nextId");
    __publicField(this, "properties", []);
    this.root.push(
      new CustomPropertiesAttributes({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    );
    this.nextId = 2;
    for (const property of properties) {
      this.addCustomProperty(property);
    }
  }
  prepForXml(context) {
    this.properties.forEach((x2) => this.root.push(x2));
    return super.prepForXml(context);
  }
  addCustomProperty(property) {
    this.properties.push(new CustomProperty(this.nextId++, property));
  }
};
var createFontRelationship = ({ id, fontKey, subsetted }, name) => new BuilderElement({
  name,
  attributes: __spreadValues({
    id: { key: "r:id", value: id }
  }, fontKey ? { fontKey: { key: "w:fontKey", value: `{${fontKey}}` } } : {}),
  children: [...subsetted ? [new OnOffElement("w:subsetted", subsetted)] : []]
});
var createFont = ({
  name,
  altName,
  panose1,
  charset,
  family,
  notTrueType,
  pitch,
  sig,
  embedRegular,
  embedBold,
  embedItalic,
  embedBoldItalic
}) => (
  // http://www.datypic.com/sc/ooxml/e-w_font-1.html
  new BuilderElement({
    name: "w:font",
    attributes: {
      name: { key: "w:name", value: name }
    },
    children: [
      // http://www.datypic.com/sc/ooxml/e-w_altName-1.html
      ...altName ? [createStringElement("w:altName", altName)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html
      ...panose1 ? [createStringElement("w:panose1", panose1)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_charset-1.html
      ...charset ? [createStringElement("w:charset", charset)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_family-1.html
      ...[createStringElement("w:family", family)],
      // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html
      ...notTrueType ? [new OnOffElement("w:notTrueType", notTrueType)] : [],
      ...[createStringElement("w:pitch", pitch)],
      // http://www.datypic.com/sc/ooxml/e-w_sig-1.html
      ...sig ? [
        new BuilderElement({
          name: "w:sig",
          attributes: {
            usb0: { key: "w:usb0", value: sig.usb0 },
            usb1: { key: "w:usb1", value: sig.usb1 },
            usb2: { key: "w:usb2", value: sig.usb2 },
            usb3: { key: "w:usb3", value: sig.usb3 },
            csb0: { key: "w:csb0", value: sig.csb0 },
            csb1: { key: "w:csb1", value: sig.csb1 }
          }
        })
      ] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html
      ...embedRegular ? [createFontRelationship(embedRegular, "w:embedRegular")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html
      ...embedBold ? [createFontRelationship(embedBold, "w:embedBold")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html
      ...embedItalic ? [createFontRelationship(embedItalic, "w:embedItalic")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html
      ...embedBoldItalic ? [createFontRelationship(embedBoldItalic, "w:embedBoldItalic")] : []
    ]
  })
);
var createRegularFont = ({
  name,
  index,
  fontKey,
  characterSet
}) => createFont({
  name,
  sig: {
    usb0: "E0002AFF",
    usb1: "C000247B",
    usb2: "00000009",
    usb3: "00000000",
    csb0: "000001FF",
    csb1: "00000000"
  },
  charset: characterSet,
  family: "auto",
  pitch: "variable",
  embedRegular: {
    fontKey,
    id: `rId${index}`
  }
});
var createFontTable = (fonts) => (
  // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html
  // http://www.datypic.com/sc/ooxml/e-w_fonts.html
  new BuilderElement({
    name: "w:fonts",
    attributes: {
      mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
      r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
      w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
      w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
      w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
      w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
      w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
      w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
      w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
      w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
      Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
    },
    children: fonts.map(
      (font, i2) => createRegularFont({
        name: font.name,
        index: i2 + 1,
        fontKey: font.fontKey
      })
    )
  })
);
var FontWrapper = class {
  constructor(options) {
    __publicField(this, "fontTable");
    __publicField(this, "relationships");
    __publicField(this, "fontOptionsWithKey", []);
    this.options = options;
    this.fontOptionsWithKey = options.map((o) => __spreadProps(__spreadValues({}, o), { fontKey: uniqueUuid() }));
    this.fontTable = createFontTable(this.fontOptionsWithKey);
    this.relationships = new Relationships();
    for (let i2 = 0; i2 < options.length; i2++) {
      this.relationships.createRelationship(
        i2 + 1,
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font",
        `fonts/${options[i2].name}.odttf`
      );
    }
  }
  get View() {
    return this.fontTable;
  }
  get Relationships() {
    return this.relationships;
  }
};
var FooterAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type"
    });
  }
};
var Footer$1 = class Footer extends InitializableXmlComponent {
  constructor(referenceNumber, initContent) {
    super("w:ftr", initContent);
    __publicField(this, "refId");
    this.refId = referenceNumber;
    if (!initContent) {
      this.root.push(
        new FooterAttributes({
          wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
          o: "urn:schemas-microsoft-com:office:office",
          r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
          v: "urn:schemas-microsoft-com:vml",
          wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          w10: "urn:schemas-microsoft-com:office:word",
          w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          w14: "http://schemas.microsoft.com/office/word/2010/wordml",
          w15: "http://schemas.microsoft.com/office/word/2012/wordml",
          wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          wne: "http://schemas.microsoft.com/office/word/2006/wordml",
          wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
        })
      );
    }
  }
  get ReferenceId() {
    return this.refId;
  }
  add(item) {
    this.root.push(item);
  }
};
var FooterWrapper = class {
  constructor(media, referenceId, initContent) {
    __publicField(this, "footer");
    __publicField(this, "relationships");
    this.media = media;
    this.footer = new Footer$1(referenceId, initContent);
    this.relationships = new Relationships();
  }
  add(item) {
    this.footer.add(item);
  }
  addChildElement(childElement) {
    this.footer.addChildElement(childElement);
  }
  get View() {
    return this.footer;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
};
var FootnoteAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      id: "w:id"
    });
  }
};
var FootnoteRef = class extends XmlComponent {
  constructor() {
    super("w:footnoteRef");
  }
};
var FootnoteRefRun = class extends Run {
  constructor() {
    super({
      style: "FootnoteReference"
    });
    this.root.push(new FootnoteRef());
  }
};
var FootnoteType = {
  SEPERATOR: "separator",
  CONTINUATION_SEPERATOR: "continuationSeparator"
};
var Footnote = class extends XmlComponent {
  constructor(options) {
    super("w:footnote");
    this.root.push(
      new FootnoteAttributes({
        type: options.type,
        id: options.id
      })
    );
    for (let i2 = 0; i2 < options.children.length; i2++) {
      const child = options.children[i2];
      if (i2 === 0) {
        child.addRunToFront(new FootnoteRefRun());
      }
      this.root.push(child);
    }
  }
};
var ContinuationSeperator = class extends XmlComponent {
  constructor() {
    super("w:continuationSeparator");
  }
};
var ContinuationSeperatorRun = class extends Run {
  constructor() {
    super({});
    this.root.push(new ContinuationSeperator());
  }
};
var Seperator = class extends XmlComponent {
  constructor() {
    super("w:separator");
  }
};
var SeperatorRun = class extends Run {
  constructor() {
    super({});
    this.root.push(new Seperator());
  }
};
var FootnotesAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
};
var FootNotes = class extends XmlComponent {
  constructor() {
    super("w:footnotes");
    this.root.push(
      new FootnotesAttributes({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    const begin = new Footnote({
      id: -1,
      type: FootnoteType.SEPERATOR,
      children: [
        new Paragraph({
          spacing: {
            after: 0,
            line: 240,
            lineRule: LineRuleType.AUTO
          },
          children: [new SeperatorRun()]
        })
      ]
    });
    this.root.push(begin);
    const spacing = new Footnote({
      id: 0,
      type: FootnoteType.CONTINUATION_SEPERATOR,
      children: [
        new Paragraph({
          spacing: {
            after: 0,
            line: 240,
            lineRule: LineRuleType.AUTO
          },
          children: [new ContinuationSeperatorRun()]
        })
      ]
    });
    this.root.push(spacing);
  }
  createFootNote(id, paragraph) {
    const footnote = new Footnote({
      id,
      children: paragraph
    });
    this.root.push(footnote);
  }
};
var FootnotesWrapper = class {
  constructor() {
    __publicField(this, "footnotess");
    __publicField(this, "relationships");
    this.footnotess = new FootNotes();
    this.relationships = new Relationships();
  }
  get View() {
    return this.footnotess;
  }
  get Relationships() {
    return this.relationships;
  }
};
var HeaderAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      w16cid: "xmlns:w16cid",
      w16se: "xmlns:w16se"
    });
  }
};
var Header$1 = class Header extends InitializableXmlComponent {
  constructor(referenceNumber, initContent) {
    super("w:hdr", initContent);
    __publicField(this, "refId");
    this.refId = referenceNumber;
    if (!initContent) {
      this.root.push(
        new HeaderAttributes({
          wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
          o: "urn:schemas-microsoft-com:office:office",
          r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
          v: "urn:schemas-microsoft-com:vml",
          wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          w10: "urn:schemas-microsoft-com:office:word",
          w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          w14: "http://schemas.microsoft.com/office/word/2010/wordml",
          w15: "http://schemas.microsoft.com/office/word/2012/wordml",
          wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          wne: "http://schemas.microsoft.com/office/word/2006/wordml",
          wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
          cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
        })
      );
    }
  }
  get ReferenceId() {
    return this.refId;
  }
  add(item) {
    this.root.push(item);
  }
};
var HeaderWrapper = class {
  constructor(media, referenceId, initContent) {
    __publicField(this, "header");
    __publicField(this, "relationships");
    this.media = media;
    this.header = new Header$1(referenceId, initContent);
    this.relationships = new Relationships();
  }
  add(item) {
    this.header.add(item);
    return this;
  }
  addChildElement(childElement) {
    this.header.addChildElement(childElement);
  }
  get View() {
    return this.header;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
};
var Media = class {
  constructor() {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
  }
  addImage(key, mediaData) {
    this.map.set(key, mediaData);
  }
  get Array() {
    return Array.from(this.map.values());
  }
};
var LevelFormat = {
  DECIMAL: "decimal",
  UPPER_ROMAN: "upperRoman",
  LOWER_ROMAN: "lowerRoman",
  UPPER_LETTER: "upperLetter",
  LOWER_LETTER: "lowerLetter",
  ORDINAL: "ordinal",
  CARDINAL_TEXT: "cardinalText",
  ORDINAL_TEXT: "ordinalText",
  HEX: "hex",
  CHICAGO: "chicago",
  IDEOGRAPH__DIGITAL: "ideographDigital",
  JAPANESE_COUNTING: "japaneseCounting",
  AIUEO: "aiueo",
  IROHA: "iroha",
  DECIMAL_FULL_WIDTH: "decimalFullWidth",
  DECIMAL_HALF_WIDTH: "decimalHalfWidth",
  JAPANESE_LEGAL: "japaneseLegal",
  JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
  DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
  DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
  AIUEO_FULL_WIDTH: "aiueoFullWidth",
  IROHA_FULL_WIDTH: "irohaFullWidth",
  DECIMAL_ZERO: "decimalZero",
  BULLET: "bullet",
  GANADA: "ganada",
  CHOSUNG: "chosung",
  DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
  DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
  DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
  IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
  IDEOGRAPH_TRADITIONAL: "ideographTraditional",
  IDEOGRAPH_ZODIAC: "ideographZodiac",
  IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
  TAIWANESE_COUNTING: "taiwaneseCounting",
  IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
  TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
  TAIWANESE_DIGITAL: "taiwaneseDigital",
  CHINESE_COUNTING: "chineseCounting",
  CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
  CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
  KOREAN_DIGITAL: "koreanDigital",
  KOREAN_COUNTING: "koreanCounting",
  KOREAN_LEGAL: "koreanLegal",
  KOREAN_DIGITAL2: "koreanDigital2",
  VIETNAMESE_COUNTING: "vietnameseCounting",
  RUSSIAN_LOWER: "russianLower",
  RUSSIAN_UPPER: "russianUpper",
  NONE: "none",
  NUMBER_IN_DASH: "numberInDash",
  HEBREW1: "hebrew1",
  HEBREW2: "hebrew2",
  ARABIC_ALPHA: "arabicAlpha",
  ARABIC_ABJAD: "arabicAbjad",
  HINDI_VOWELS: "hindiVowels",
  HINDI_CONSONANTS: "hindiConsonants",
  HINDI_NUMBERS: "hindiNumbers",
  HINDI_COUNTING: "hindiCounting",
  THAI_LETTERS: "thaiLetters",
  THAI_NUMBERS: "thaiNumbers",
  THAI_COUNTING: "thaiCounting",
  BAHT_TEXT: "bahtText",
  DOLLAR_TEXT: "dollarText",
  CUSTOM: "custom"
};
var LevelAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      ilvl: "w:ilvl",
      tentative: "w15:tentative"
    });
  }
};
var NumberFormat = class extends XmlComponent {
  constructor(value) {
    super("w:numFmt");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var LevelText = class extends XmlComponent {
  constructor(value) {
    super("w:lvlText");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var LevelJc = class extends XmlComponent {
  constructor(value) {
    super("w:lvlJc");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var Suffix = class extends XmlComponent {
  constructor(value) {
    super("w:suff");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var IsLegalNumberingStyle = class extends XmlComponent {
  constructor() {
    super("w:isLgl");
  }
};
var LevelBase = class extends XmlComponent {
  constructor({
    level,
    format,
    text,
    alignment = AlignmentType.START,
    start = 1,
    style,
    suffix,
    isLegalNumberingStyle
  }) {
    super("w:lvl");
    __publicField(this, "paragraphProperties");
    __publicField(this, "runProperties");
    this.root.push(new NumberValueElement("w:start", decimalNumber(start)));
    if (format) {
      this.root.push(new NumberFormat(format));
    }
    if (suffix) {
      this.root.push(new Suffix(suffix));
    }
    if (isLegalNumberingStyle) {
      this.root.push(new IsLegalNumberingStyle());
    }
    if (text) {
      this.root.push(new LevelText(text));
    }
    this.root.push(new LevelJc(alignment));
    this.paragraphProperties = new ParagraphProperties(style && style.paragraph);
    this.runProperties = new RunProperties(style && style.run);
    this.root.push(this.paragraphProperties);
    this.root.push(this.runProperties);
    if (level > 9) {
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    }
    this.root.push(
      new LevelAttributes({
        ilvl: decimalNumber(level),
        tentative: 1
      })
    );
  }
};
var Level = class extends LevelBase {
  // This is the level that sits under abstractNum. We make a
  // handful of properties required
};
var MultiLevelType = class extends XmlComponent {
  constructor(value) {
    super("w:multiLevelType");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var AbstractNumberingAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      abstractNumId: "w:abstractNumId",
      restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
    });
  }
};
var AbstractNumbering = class extends XmlComponent {
  constructor(id, levelOptions) {
    super("w:abstractNum");
    __publicField(this, "id");
    this.root.push(
      new AbstractNumberingAttributes({
        abstractNumId: decimalNumber(id),
        restartNumberingAfterBreak: 0
      })
    );
    this.root.push(new MultiLevelType("hybridMultilevel"));
    this.id = id;
    for (const option of levelOptions) {
      this.root.push(new Level(option));
    }
  }
};
var AbstractNumId = class extends XmlComponent {
  constructor(value) {
    super("w:abstractNumId");
    this.root.push(
      new Attributes({
        val: value
      })
    );
  }
};
var NumAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { numId: "w:numId" });
  }
};
var ConcreteNumbering = class extends XmlComponent {
  constructor(options) {
    super("w:num");
    __publicField(this, "numId");
    __publicField(this, "reference");
    __publicField(this, "instance");
    this.numId = options.numId;
    this.reference = options.reference;
    this.instance = options.instance;
    this.root.push(
      new NumAttributes({
        numId: decimalNumber(options.numId)
      })
    );
    this.root.push(new AbstractNumId(decimalNumber(options.abstractNumId)));
    if (options.overrideLevels && options.overrideLevels.length) {
      for (const level of options.overrideLevels) {
        this.root.push(new LevelOverride(level.num, level.start));
      }
    }
  }
};
var LevelOverrideAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { ilvl: "w:ilvl" });
  }
};
var LevelOverride = class extends XmlComponent {
  constructor(levelNum, start) {
    super("w:lvlOverride");
    this.root.push(new LevelOverrideAttributes({ ilvl: levelNum }));
    if (start !== void 0) {
      this.root.push(new StartOverride(start));
    }
  }
};
var StartOverrideAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var StartOverride = class extends XmlComponent {
  constructor(start) {
    super("w:startOverride");
    this.root.push(new StartOverrideAttributes({ val: start }));
  }
};
var Numbering = class extends XmlComponent {
  constructor(options) {
    super("w:numbering");
    __publicField(this, "abstractNumberingMap", /* @__PURE__ */ new Map());
    __publicField(this, "concreteNumberingMap", /* @__PURE__ */ new Map());
    __publicField(this, "referenceConfigMap", /* @__PURE__ */ new Map());
    __publicField(this, "abstractNumUniqueNumericId", abstractNumUniqueNumericIdGen());
    __publicField(this, "concreteNumUniqueNumericId", concreteNumUniqueNumericIdGen());
    this.root.push(
      new DocumentAttributes(
        ["wpc", "mc", "o", "r", "m", "v", "wp14", "wp", "w10", "w", "w14", "w15", "wpg", "wpi", "wne", "wps"],
        "w14 w15 wp14"
      )
    );
    const abstractNumbering = new AbstractNumbering(this.abstractNumUniqueNumericId(), [
      {
        level: 0,
        format: LevelFormat.BULLET,
        text: "\u25CF",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 1,
        format: LevelFormat.BULLET,
        text: "\u25CB",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: convertInchesToTwip(1), hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 2,
        format: LevelFormat.BULLET,
        text: "\u25A0",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 2160, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 3,
        format: LevelFormat.BULLET,
        text: "\u25CF",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 2880, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 4,
        format: LevelFormat.BULLET,
        text: "\u25CB",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 3600, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 5,
        format: LevelFormat.BULLET,
        text: "\u25A0",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 4320, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 6,
        format: LevelFormat.BULLET,
        text: "\u25CF",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 5040, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 7,
        format: LevelFormat.BULLET,
        text: "\u25CF",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 5760, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 8,
        format: LevelFormat.BULLET,
        text: "\u25CF",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 6480, hanging: convertInchesToTwip(0.25) }
          }
        }
      }
    ]);
    this.concreteNumberingMap.set(
      "default-bullet-numbering",
      new ConcreteNumbering({
        numId: 1,
        abstractNumId: abstractNumbering.id,
        reference: "default-bullet-numbering",
        instance: 0,
        overrideLevels: [
          {
            num: 0,
            start: 1
          }
        ]
      })
    );
    this.abstractNumberingMap.set("default-bullet-numbering", abstractNumbering);
    for (const con of options.config) {
      this.abstractNumberingMap.set(con.reference, new AbstractNumbering(this.abstractNumUniqueNumericId(), con.levels));
      this.referenceConfigMap.set(con.reference, con.levels);
    }
  }
  prepForXml(context) {
    for (const numbering of this.abstractNumberingMap.values()) {
      this.root.push(numbering);
    }
    for (const numbering of this.concreteNumberingMap.values()) {
      this.root.push(numbering);
    }
    return super.prepForXml(context);
  }
  createConcreteNumberingInstance(reference, instance) {
    const abstractNumbering = this.abstractNumberingMap.get(reference);
    if (!abstractNumbering) {
      return;
    }
    const fullReference = `${reference}-${instance}`;
    if (this.concreteNumberingMap.has(fullReference)) {
      return;
    }
    const referenceConfigLevels = this.referenceConfigMap.get(reference);
    const firstLevelStartNumber = referenceConfigLevels && referenceConfigLevels[0].start;
    const concreteNumberingSettings = {
      numId: this.concreteNumUniqueNumericId(),
      abstractNumId: abstractNumbering.id,
      reference,
      instance,
      overrideLevels: [
        firstLevelStartNumber && Number.isInteger(firstLevelStartNumber) ? {
          num: 0,
          start: firstLevelStartNumber
        } : {
          num: 0,
          start: 1
        }
      ]
    };
    this.concreteNumberingMap.set(fullReference, new ConcreteNumbering(concreteNumberingSettings));
  }
  get ConcreteNumbering() {
    return Array.from(this.concreteNumberingMap.values());
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get ReferenceConfig() {
    return Array.from(this.referenceConfigMap.values());
  }
};
var CompatibilitySettingAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      version: "w:val",
      name: "w:name",
      uri: "w:uri"
    });
  }
};
var CompatibilitySetting = class extends XmlComponent {
  constructor(version) {
    super("w:compatSetting");
    this.root.push(
      new CompatibilitySettingAttributes({
        version,
        uri: "http://schemas.microsoft.com/office/word",
        name: "compatibilityMode"
      })
    );
  }
};
var Compatibility = class extends XmlComponent {
  constructor(options) {
    super("w:compat");
    if (options.version) {
      this.root.push(new CompatibilitySetting(options.version));
    }
    if (options.useSingleBorderforContiguousCells) {
      this.root.push(new OnOffElement("w:useSingleBorderforContiguousCells", options.useSingleBorderforContiguousCells));
    }
    if (options.wordPerfectJustification) {
      this.root.push(new OnOffElement("w:wpJustification", options.wordPerfectJustification));
    }
    if (options.noTabStopForHangingIndent) {
      this.root.push(new OnOffElement("w:noTabHangInd", options.noTabStopForHangingIndent));
    }
    if (options.noLeading) {
      this.root.push(new OnOffElement("w:noLeading", options.noLeading));
    }
    if (options.spaceForUnderline) {
      this.root.push(new OnOffElement("w:spaceForUL", options.spaceForUnderline));
    }
    if (options.noColumnBalance) {
      this.root.push(new OnOffElement("w:noColumnBalance", options.noColumnBalance));
    }
    if (options.balanceSingleByteDoubleByteWidth) {
      this.root.push(new OnOffElement("w:balanceSingleByteDoubleByteWidth", options.balanceSingleByteDoubleByteWidth));
    }
    if (options.noExtraLineSpacing) {
      this.root.push(new OnOffElement("w:noExtraLineSpacing", options.noExtraLineSpacing));
    }
    if (options.doNotLeaveBackslashAlone) {
      this.root.push(new OnOffElement("w:doNotLeaveBackslashAlone", options.doNotLeaveBackslashAlone));
    }
    if (options.underlineTrailingSpaces) {
      this.root.push(new OnOffElement("w:ulTrailSpace", options.underlineTrailingSpaces));
    }
    if (options.doNotExpandShiftReturn) {
      this.root.push(new OnOffElement("w:doNotExpandShiftReturn", options.doNotExpandShiftReturn));
    }
    if (options.spacingInWholePoints) {
      this.root.push(new OnOffElement("w:spacingInWholePoints", options.spacingInWholePoints));
    }
    if (options.lineWrapLikeWord6) {
      this.root.push(new OnOffElement("w:lineWrapLikeWord6", options.lineWrapLikeWord6));
    }
    if (options.printBodyTextBeforeHeader) {
      this.root.push(new OnOffElement("w:printBodyTextBeforeHeader", options.printBodyTextBeforeHeader));
    }
    if (options.printColorsBlack) {
      this.root.push(new OnOffElement("w:printColBlack", options.printColorsBlack));
    }
    if (options.spaceWidth) {
      this.root.push(new OnOffElement("w:wpSpaceWidth", options.spaceWidth));
    }
    if (options.showBreaksInFrames) {
      this.root.push(new OnOffElement("w:showBreaksInFrames", options.showBreaksInFrames));
    }
    if (options.subFontBySize) {
      this.root.push(new OnOffElement("w:subFontBySize", options.subFontBySize));
    }
    if (options.suppressBottomSpacing) {
      this.root.push(new OnOffElement("w:suppressBottomSpacing", options.suppressBottomSpacing));
    }
    if (options.suppressTopSpacing) {
      this.root.push(new OnOffElement("w:suppressTopSpacing", options.suppressTopSpacing));
    }
    if (options.suppressSpacingAtTopOfPage) {
      this.root.push(new OnOffElement("w:suppressSpacingAtTopOfPage", options.suppressSpacingAtTopOfPage));
    }
    if (options.suppressTopSpacingWP) {
      this.root.push(new OnOffElement("w:suppressTopSpacingWP", options.suppressTopSpacingWP));
    }
    if (options.suppressSpBfAfterPgBrk) {
      this.root.push(new OnOffElement("w:suppressSpBfAfterPgBrk", options.suppressSpBfAfterPgBrk));
    }
    if (options.swapBordersFacingPages) {
      this.root.push(new OnOffElement("w:swapBordersFacingPages", options.swapBordersFacingPages));
    }
    if (options.convertMailMergeEsc) {
      this.root.push(new OnOffElement("w:convMailMergeEsc", options.convertMailMergeEsc));
    }
    if (options.truncateFontHeightsLikeWP6) {
      this.root.push(new OnOffElement("w:truncateFontHeightsLikeWP6", options.truncateFontHeightsLikeWP6));
    }
    if (options.macWordSmallCaps) {
      this.root.push(new OnOffElement("w:mwSmallCaps", options.macWordSmallCaps));
    }
    if (options.usePrinterMetrics) {
      this.root.push(new OnOffElement("w:usePrinterMetrics", options.usePrinterMetrics));
    }
    if (options.doNotSuppressParagraphBorders) {
      this.root.push(new OnOffElement("w:doNotSuppressParagraphBorders", options.doNotSuppressParagraphBorders));
    }
    if (options.wrapTrailSpaces) {
      this.root.push(new OnOffElement("w:wrapTrailSpaces", options.wrapTrailSpaces));
    }
    if (options.footnoteLayoutLikeWW8) {
      this.root.push(new OnOffElement("w:footnoteLayoutLikeWW8", options.footnoteLayoutLikeWW8));
    }
    if (options.shapeLayoutLikeWW8) {
      this.root.push(new OnOffElement("w:shapeLayoutLikeWW8", options.shapeLayoutLikeWW8));
    }
    if (options.alignTablesRowByRow) {
      this.root.push(new OnOffElement("w:alignTablesRowByRow", options.alignTablesRowByRow));
    }
    if (options.forgetLastTabAlignment) {
      this.root.push(new OnOffElement("w:forgetLastTabAlignment", options.forgetLastTabAlignment));
    }
    if (options.adjustLineHeightInTable) {
      this.root.push(new OnOffElement("w:adjustLineHeightInTable", options.adjustLineHeightInTable));
    }
    if (options.autoSpaceLikeWord95) {
      this.root.push(new OnOffElement("w:autoSpaceLikeWord95", options.autoSpaceLikeWord95));
    }
    if (options.noSpaceRaiseLower) {
      this.root.push(new OnOffElement("w:noSpaceRaiseLower", options.noSpaceRaiseLower));
    }
    if (options.doNotUseHTMLParagraphAutoSpacing) {
      this.root.push(new OnOffElement("w:doNotUseHTMLParagraphAutoSpacing", options.doNotUseHTMLParagraphAutoSpacing));
    }
    if (options.layoutRawTableWidth) {
      this.root.push(new OnOffElement("w:layoutRawTableWidth", options.layoutRawTableWidth));
    }
    if (options.layoutTableRowsApart) {
      this.root.push(new OnOffElement("w:layoutTableRowsApart", options.layoutTableRowsApart));
    }
    if (options.useWord97LineBreakRules) {
      this.root.push(new OnOffElement("w:useWord97LineBreakRules", options.useWord97LineBreakRules));
    }
    if (options.doNotBreakWrappedTables) {
      this.root.push(new OnOffElement("w:doNotBreakWrappedTables", options.doNotBreakWrappedTables));
    }
    if (options.doNotSnapToGridInCell) {
      this.root.push(new OnOffElement("w:doNotSnapToGridInCell", options.doNotSnapToGridInCell));
    }
    if (options.selectFieldWithFirstOrLastCharacter) {
      this.root.push(new OnOffElement("w:selectFldWithFirstOrLastChar", options.selectFieldWithFirstOrLastCharacter));
    }
    if (options.applyBreakingRules) {
      this.root.push(new OnOffElement("w:applyBreakingRules", options.applyBreakingRules));
    }
    if (options.doNotWrapTextWithPunctuation) {
      this.root.push(new OnOffElement("w:doNotWrapTextWithPunct", options.doNotWrapTextWithPunctuation));
    }
    if (options.doNotUseEastAsianBreakRules) {
      this.root.push(new OnOffElement("w:doNotUseEastAsianBreakRules", options.doNotUseEastAsianBreakRules));
    }
    if (options.useWord2002TableStyleRules) {
      this.root.push(new OnOffElement("w:useWord2002TableStyleRules", options.useWord2002TableStyleRules));
    }
    if (options.growAutofit) {
      this.root.push(new OnOffElement("w:growAutofit", options.growAutofit));
    }
    if (options.useFELayout) {
      this.root.push(new OnOffElement("w:useFELayout", options.useFELayout));
    }
    if (options.useNormalStyleForList) {
      this.root.push(new OnOffElement("w:useNormalStyleForList", options.useNormalStyleForList));
    }
    if (options.doNotUseIndentAsNumberingTabStop) {
      this.root.push(new OnOffElement("w:doNotUseIndentAsNumberingTabStop", options.doNotUseIndentAsNumberingTabStop));
    }
    if (options.useAlternateEastAsianLineBreakRules) {
      this.root.push(new OnOffElement("w:useAltKinsokuLineBreakRules", options.useAlternateEastAsianLineBreakRules));
    }
    if (options.allowSpaceOfSameStyleInTable) {
      this.root.push(new OnOffElement("w:allowSpaceOfSameStyleInTable", options.allowSpaceOfSameStyleInTable));
    }
    if (options.doNotSuppressIndentation) {
      this.root.push(new OnOffElement("w:doNotSuppressIndentation", options.doNotSuppressIndentation));
    }
    if (options.doNotAutofitConstrainedTables) {
      this.root.push(new OnOffElement("w:doNotAutofitConstrainedTables", options.doNotAutofitConstrainedTables));
    }
    if (options.autofitToFirstFixedWidthCell) {
      this.root.push(new OnOffElement("w:autofitToFirstFixedWidthCell", options.autofitToFirstFixedWidthCell));
    }
    if (options.underlineTabInNumberingList) {
      this.root.push(new OnOffElement("w:underlineTabInNumList", options.underlineTabInNumberingList));
    }
    if (options.displayHangulFixedWidth) {
      this.root.push(new OnOffElement("w:displayHangulFixedWidth", options.displayHangulFixedWidth));
    }
    if (options.splitPgBreakAndParaMark) {
      this.root.push(new OnOffElement("w:splitPgBreakAndParaMark", options.splitPgBreakAndParaMark));
    }
    if (options.doNotVerticallyAlignCellWithSp) {
      this.root.push(new OnOffElement("w:doNotVertAlignCellWithSp", options.doNotVerticallyAlignCellWithSp));
    }
    if (options.doNotBreakConstrainedForcedTable) {
      this.root.push(new OnOffElement("w:doNotBreakConstrainedForcedTable", options.doNotBreakConstrainedForcedTable));
    }
    if (options.ignoreVerticalAlignmentInTextboxes) {
      this.root.push(new OnOffElement("w:doNotVertAlignInTxbx", options.ignoreVerticalAlignmentInTextboxes));
    }
    if (options.useAnsiKerningPairs) {
      this.root.push(new OnOffElement("w:useAnsiKerningPairs", options.useAnsiKerningPairs));
    }
    if (options.cachedColumnBalance) {
      this.root.push(new OnOffElement("w:cachedColBalance", options.cachedColumnBalance));
    }
  }
};
var SettingsAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
};
var Settings = class extends XmlComponent {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super("w:settings");
    this.root.push(
      new SettingsAttributes({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    this.root.push(new OnOffElement("w:displayBackgroundShape", true));
    if (options.trackRevisions !== void 0) {
      this.root.push(new OnOffElement("w:trackRevisions", options.trackRevisions));
    }
    if (options.evenAndOddHeaders !== void 0) {
      this.root.push(new OnOffElement("w:evenAndOddHeaders", options.evenAndOddHeaders));
    }
    if (options.updateFields !== void 0) {
      this.root.push(new OnOffElement("w:updateFields", options.updateFields));
    }
    if (options.defaultTabStop !== void 0) {
      this.root.push(new NumberValueElement("w:defaultTabStop", options.defaultTabStop));
    }
    if (((_a = options.hyphenation) == null ? void 0 : _a.autoHyphenation) !== void 0) {
      this.root.push(new OnOffElement("w:autoHyphenation", options.hyphenation.autoHyphenation));
    }
    if (((_b = options.hyphenation) == null ? void 0 : _b.hyphenationZone) !== void 0) {
      this.root.push(new NumberValueElement("w:hyphenationZone", options.hyphenation.hyphenationZone));
    }
    if (((_c = options.hyphenation) == null ? void 0 : _c.consecutiveHyphenLimit) !== void 0) {
      this.root.push(new NumberValueElement("w:consecutiveHyphenLimit", options.hyphenation.consecutiveHyphenLimit));
    }
    if (((_d = options.hyphenation) == null ? void 0 : _d.doNotHyphenateCaps) !== void 0) {
      this.root.push(new OnOffElement("w:doNotHyphenateCaps", options.hyphenation.doNotHyphenateCaps));
    }
    this.root.push(
      new Compatibility(__spreadProps(__spreadValues({}, (_e = options.compatibility) != null ? _e : {}), {
        version: (_h = (_g = (_f = options.compatibility) == null ? void 0 : _f.version) != null ? _g : options.compatibilityModeVersion) != null ? _h : 15
      }))
    );
  }
};
var ComponentAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
};
var Name = class extends XmlComponent {
  constructor(value) {
    super("w:name");
    this.root.push(new ComponentAttributes({ val: value }));
  }
};
var UiPriority = class extends XmlComponent {
  constructor(value) {
    super("w:uiPriority");
    this.root.push(new ComponentAttributes({ val: decimalNumber(value) }));
  }
};
var StyleAttributes = class extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      styleId: "w:styleId",
      default: "w:default",
      customStyle: "w:customStyle"
    });
  }
};
var Style2 = class extends XmlComponent {
  constructor(attributes, options) {
    super("w:style");
    this.root.push(new StyleAttributes(attributes));
    if (options.name) {
      this.root.push(new Name(options.name));
    }
    if (options.basedOn) {
      this.root.push(new StringValueElement("w:basedOn", options.basedOn));
    }
    if (options.next) {
      this.root.push(new StringValueElement("w:next", options.next));
    }
    if (options.link) {
      this.root.push(new StringValueElement("w:link", options.link));
    }
    if (options.uiPriority !== void 0) {
      this.root.push(new UiPriority(options.uiPriority));
    }
    if (options.semiHidden !== void 0) {
      this.root.push(new OnOffElement("w:semiHidden", options.semiHidden));
    }
    if (options.unhideWhenUsed !== void 0) {
      this.root.push(new OnOffElement("w:unhideWhenUsed", options.unhideWhenUsed));
    }
    if (options.quickFormat !== void 0) {
      this.root.push(new OnOffElement("w:qFormat", options.quickFormat));
    }
  }
};
var StyleForParagraph = class extends Style2 {
  constructor(options) {
    super({ type: "paragraph", styleId: options.id }, options);
    __publicField(this, "paragraphProperties");
    __publicField(this, "runProperties");
    this.paragraphProperties = new ParagraphProperties(options.paragraph);
    this.runProperties = new RunProperties(options.run);
    this.root.push(this.paragraphProperties);
    this.root.push(this.runProperties);
  }
};
var StyleForCharacter = class extends Style2 {
  constructor(options) {
    super(
      { type: "character", styleId: options.id },
      __spreadValues({
        uiPriority: 99,
        unhideWhenUsed: true
      }, options)
    );
    __publicField(this, "runProperties");
    this.runProperties = new RunProperties(options.run);
    this.root.push(this.runProperties);
  }
};
var HeadingStyle = class extends StyleForParagraph {
  constructor(options) {
    super(__spreadValues({
      basedOn: "Normal",
      next: "Normal",
      quickFormat: true
    }, options));
  }
};
var TitleStyle = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Title",
      name: "Title"
    }, options));
  }
};
var Heading1Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading1",
      name: "Heading 1"
    }, options));
  }
};
var Heading2Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading2",
      name: "Heading 2"
    }, options));
  }
};
var Heading3Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading3",
      name: "Heading 3"
    }, options));
  }
};
var Heading4Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading4",
      name: "Heading 4"
    }, options));
  }
};
var Heading5Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading5",
      name: "Heading 5"
    }, options));
  }
};
var Heading6Style = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Heading6",
      name: "Heading 6"
    }, options));
  }
};
var StrongStyle = class extends HeadingStyle {
  constructor(options) {
    super(__spreadValues({
      id: "Strong",
      name: "Strong"
    }, options));
  }
};
var ListParagraph = class extends StyleForParagraph {
  constructor(options) {
    super(__spreadValues({
      id: "ListParagraph",
      name: "List Paragraph",
      basedOn: "Normal",
      quickFormat: true
    }, options));
  }
};
var FootnoteText = class extends StyleForParagraph {
  constructor(options) {
    super(__spreadValues({
      id: "FootnoteText",
      name: "footnote text",
      link: "FootnoteTextChar",
      basedOn: "Normal",
      uiPriority: 99,
      semiHidden: true,
      unhideWhenUsed: true,
      paragraph: {
        spacing: {
          after: 0,
          line: 240,
          lineRule: LineRuleType.AUTO
        }
      },
      run: {
        size: 20
      }
    }, options));
  }
};
var FootnoteReferenceStyle = class extends StyleForCharacter {
  constructor(options) {
    super(__spreadValues({
      id: "FootnoteReference",
      name: "footnote reference",
      basedOn: "DefaultParagraphFont",
      semiHidden: true,
      run: {
        superScript: true
      }
    }, options));
  }
};
var FootnoteTextChar = class extends StyleForCharacter {
  constructor(options) {
    super(__spreadValues({
      id: "FootnoteTextChar",
      name: "Footnote Text Char",
      basedOn: "DefaultParagraphFont",
      link: "FootnoteText",
      semiHidden: true,
      run: {
        size: 20
      }
    }, options));
  }
};
var HyperlinkStyle = class extends StyleForCharacter {
  constructor(options) {
    super(__spreadValues({
      id: "Hyperlink",
      name: "Hyperlink",
      basedOn: "DefaultParagraphFont",
      run: {
        color: "0563C1",
        underline: {
          type: UnderlineType.SINGLE
        }
      }
    }, options));
  }
};
var Styles = class extends XmlComponent {
  constructor(options) {
    super("w:styles");
    if (options.initialStyles) {
      this.root.push(options.initialStyles);
    }
    if (options.importedStyles) {
      for (const style of options.importedStyles) {
        this.root.push(style);
      }
    }
    if (options.paragraphStyles) {
      for (const style of options.paragraphStyles) {
        this.root.push(new StyleForParagraph(style));
      }
    }
    if (options.characterStyles) {
      for (const style of options.characterStyles) {
        this.root.push(new StyleForCharacter(style));
      }
    }
  }
};
var ParagraphPropertiesDefaults = class extends XmlComponent {
  constructor(options) {
    super("w:pPrDefault");
    this.root.push(new ParagraphProperties(options));
  }
};
var RunPropertiesDefaults = class extends XmlComponent {
  constructor(options) {
    super("w:rPrDefault");
    this.root.push(new RunProperties(options));
  }
};
var DocumentDefaults = class extends XmlComponent {
  constructor(options) {
    super("w:docDefaults");
    __publicField(this, "runPropertiesDefaults");
    __publicField(this, "paragraphPropertiesDefaults");
    this.runPropertiesDefaults = new RunPropertiesDefaults(options.run);
    this.paragraphPropertiesDefaults = new ParagraphPropertiesDefaults(options.paragraph);
    this.root.push(this.runPropertiesDefaults);
    this.root.push(this.paragraphPropertiesDefaults);
  }
};
var ExternalStylesFactory = class {
  /**
   * Creates new Style based on the given styles.
   * Parses the styles and convert them to XmlComponent.
   * Example content from styles.xml:
   * <?xml version="1.0">
   * <w:styles xmlns:mc="some schema" ...>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading1">
   *           <w:name w:val="heading 1"/>
   *           .....
   *   </w:style>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading2">
   *           <w:name w:val="heading 2"/>
   *           .....
   *   </w:style>
   *
   *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>
   *
   * </w:styles>
   *
   * @param externalStyles context from styles.xml
   */
  newInstance(xmlData) {
    const xmlObj = libExports.xml2js(xmlData, { compact: false });
    let stylesXmlElement;
    for (const xmlElm of xmlObj.elements || []) {
      if (xmlElm.name === "w:styles") {
        stylesXmlElement = xmlElm;
      }
    }
    if (stylesXmlElement === void 0) {
      throw new Error("can not find styles element");
    }
    const stylesElements = stylesXmlElement.elements || [];
    const importedStyle = new Styles({
      initialStyles: new ImportedRootElementAttributes(stylesXmlElement.attributes),
      importedStyles: stylesElements.map((childElm) => convertToXmlComponent(childElm))
    });
    return importedStyle;
  }
};
var DefaultStylesFactory = class {
  newInstance(options = {}) {
    var _a;
    const documentAttributes = new DocumentAttributes(["mc", "r", "w", "w14", "w15"], "w14 w15");
    return {
      initialStyles: documentAttributes,
      importedStyles: [
        new DocumentDefaults((_a = options.document) != null ? _a : {}),
        new TitleStyle(__spreadValues({
          run: {
            size: 56
          }
        }, options.title)),
        new Heading1Style(__spreadValues({
          run: {
            color: "2E74B5",
            size: 32
          }
        }, options.heading1)),
        new Heading2Style(__spreadValues({
          run: {
            color: "2E74B5",
            size: 26
          }
        }, options.heading2)),
        new Heading3Style(__spreadValues({
          run: {
            color: "1F4D78",
            size: 24
          }
        }, options.heading3)),
        new Heading4Style(__spreadValues({
          run: {
            color: "2E74B5",
            italics: true
          }
        }, options.heading4)),
        new Heading5Style(__spreadValues({
          run: {
            color: "2E74B5"
          }
        }, options.heading5)),
        new Heading6Style(__spreadValues({
          run: {
            color: "1F4D78"
          }
        }, options.heading6)),
        new StrongStyle(__spreadValues({
          run: {
            bold: true
          }
        }, options.strong)),
        new ListParagraph(options.listParagraph || {}),
        new HyperlinkStyle(options.hyperlink || {}),
        new FootnoteReferenceStyle(options.footnoteReference || {}),
        new FootnoteText(options.footnoteText || {}),
        new FootnoteTextChar(options.footnoteTextChar || {})
      ]
    };
  }
};
var File = class {
  constructor(options) {
    __publicField(this, "currentRelationshipId", 1);
    __publicField(this, "documentWrapper");
    __publicField(this, "headers", []);
    __publicField(this, "footers", []);
    __publicField(this, "coreProperties");
    __publicField(this, "numbering");
    __publicField(this, "media");
    __publicField(this, "fileRelationships");
    __publicField(this, "footnotesWrapper");
    __publicField(this, "settings");
    __publicField(this, "contentTypes");
    __publicField(this, "customProperties");
    __publicField(this, "appProperties");
    __publicField(this, "styles");
    __publicField(this, "comments");
    __publicField(this, "fontWrapper");
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    this.coreProperties = new CoreProperties(__spreadProps(__spreadValues({}, options), {
      creator: (_a = options.creator) != null ? _a : "Un-named",
      revision: (_b = options.revision) != null ? _b : 1,
      lastModifiedBy: (_c = options.lastModifiedBy) != null ? _c : "Un-named"
    }));
    this.numbering = new Numbering(options.numbering ? options.numbering : { config: [] });
    this.comments = new Comments((_d = options.comments) != null ? _d : { children: [] });
    this.fileRelationships = new Relationships();
    this.customProperties = new CustomProperties((_e = options.customProperties) != null ? _e : []);
    this.appProperties = new AppProperties();
    this.footnotesWrapper = new FootnotesWrapper();
    this.contentTypes = new ContentTypes();
    this.documentWrapper = new DocumentWrapper({ background: options.background });
    this.settings = new Settings({
      compatibilityModeVersion: options.compatabilityModeVersion,
      compatibility: options.compatibility,
      evenAndOddHeaders: options.evenAndOddHeaderAndFooters ? true : false,
      trackRevisions: (_f = options.features) == null ? void 0 : _f.trackRevisions,
      updateFields: (_g = options.features) == null ? void 0 : _g.updateFields,
      defaultTabStop: options.defaultTabStop,
      hyphenation: {
        autoHyphenation: (_h = options.hyphenation) == null ? void 0 : _h.autoHyphenation,
        hyphenationZone: (_i = options.hyphenation) == null ? void 0 : _i.hyphenationZone,
        consecutiveHyphenLimit: (_j = options.hyphenation) == null ? void 0 : _j.consecutiveHyphenLimit,
        doNotHyphenateCaps: (_k = options.hyphenation) == null ? void 0 : _k.doNotHyphenateCaps
      }
    });
    this.media = new Media();
    if (options.externalStyles !== void 0) {
      const stylesFactory = new ExternalStylesFactory();
      this.styles = stylesFactory.newInstance(options.externalStyles);
    } else if (options.styles) {
      const stylesFactory = new DefaultStylesFactory();
      const defaultStyles = stylesFactory.newInstance(options.styles.default);
      this.styles = new Styles(__spreadValues(__spreadValues({}, defaultStyles), options.styles));
    } else {
      const stylesFactory = new DefaultStylesFactory();
      this.styles = new Styles(stylesFactory.newInstance());
    }
    this.addDefaultRelationships();
    for (const section of options.sections) {
      this.addSection(section);
    }
    if (options.footnotes) {
      for (const key in options.footnotes) {
        this.footnotesWrapper.View.createFootNote(parseFloat(key), options.footnotes[key].children);
      }
    }
    this.fontWrapper = new FontWrapper((_l = options.fonts) != null ? _l : []);
  }
  addSection({ headers: headers2 = {}, footers = {}, children, properties }) {
    this.documentWrapper.View.Body.addSection(__spreadProps(__spreadValues({}, properties), {
      headerWrapperGroup: {
        default: headers2.default ? this.createHeader(headers2.default) : void 0,
        first: headers2.first ? this.createHeader(headers2.first) : void 0,
        even: headers2.even ? this.createHeader(headers2.even) : void 0
      },
      footerWrapperGroup: {
        default: footers.default ? this.createFooter(footers.default) : void 0,
        first: footers.first ? this.createFooter(footers.first) : void 0,
        even: footers.even ? this.createFooter(footers.even) : void 0
      }
    }));
    for (const child of children) {
      this.documentWrapper.View.add(child);
    }
  }
  createHeader(header) {
    const wrapper = new HeaderWrapper(this.media, this.currentRelationshipId++);
    for (const child of header.options.children) {
      wrapper.add(child);
    }
    this.addHeaderToDocument(wrapper);
    return wrapper;
  }
  createFooter(footer) {
    const wrapper = new FooterWrapper(this.media, this.currentRelationshipId++);
    for (const child of footer.options.children) {
      wrapper.add(child);
    }
    this.addFooterToDocument(wrapper);
    return wrapper;
  }
  addHeaderToDocument(header, type2 = HeaderFooterReferenceType.DEFAULT) {
    this.headers.push({ header, type: type2 });
    this.documentWrapper.Relationships.createRelationship(
      header.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
      `header${this.headers.length}.xml`
    );
    this.contentTypes.addHeader(this.headers.length);
  }
  addFooterToDocument(footer, type2 = HeaderFooterReferenceType.DEFAULT) {
    this.footers.push({ footer, type: type2 });
    this.documentWrapper.Relationships.createRelationship(
      footer.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
      `footer${this.footers.length}.xml`
    );
    this.contentTypes.addFooter(this.footers.length);
  }
  addDefaultRelationships() {
    this.fileRelationships.createRelationship(
      1,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      "word/document.xml"
    );
    this.fileRelationships.createRelationship(
      2,
      "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      "docProps/core.xml"
    );
    this.fileRelationships.createRelationship(
      3,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      "docProps/app.xml"
    );
    this.fileRelationships.createRelationship(
      4,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
      "docProps/custom.xml"
    );
    this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      "styles.xml"
    );
    this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
      "numbering.xml"
    );
    this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
      "footnotes.xml"
    );
    this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
      "settings.xml"
    );
    this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      "comments.xml"
    );
  }
  get Document() {
    return this.documentWrapper;
  }
  get Styles() {
    return this.styles;
  }
  get CoreProperties() {
    return this.coreProperties;
  }
  get Numbering() {
    return this.numbering;
  }
  get Media() {
    return this.media;
  }
  get FileRelationships() {
    return this.fileRelationships;
  }
  get Headers() {
    return this.headers.map((item) => item.header);
  }
  get Footers() {
    return this.footers.map((item) => item.footer);
  }
  get ContentTypes() {
    return this.contentTypes;
  }
  get CustomProperties() {
    return this.customProperties;
  }
  get AppProperties() {
    return this.appProperties;
  }
  get FootNotes() {
    return this.footnotesWrapper;
  }
  get Settings() {
    return this.settings;
  }
  get Comments() {
    return this.comments;
  }
  get FontTable() {
    return this.fontWrapper;
  }
};
var streamBrowserifyExports = requireStreamBrowserify();
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
var hasRequiredJszip_min;
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module, exports) {
    !(function(e2) {
      module.exports = e2();
    })(function() {
      return (function s2(a, o, h2) {
        function u(r2, e22) {
          if (!o[r2]) {
            if (!a[r2]) {
              var t2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e22 && t2) return t2(r2, true);
              if (l) return l(r2, true);
              var n = new Error("Cannot find module '" + r2 + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i2 = o[r2] = { exports: {} };
            a[r2][0].call(i2.exports, function(e3) {
              var t22 = a[r2][1][e3];
              return u(t22 || e3);
            }, i2, i2.exports, s2, a, o, h2);
          }
          return o[r2].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h2.length; e2++) u(h2[e2]);
        return u;
      })({ 1: [function(e2, t2, r2) {
        var d = e2("./utils"), c = e2("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e22) {
          for (var t22, r22, n, i2, s2, a, o, h2 = [], u = 0, l = e22.length, f3 = l, c2 = "string" !== d.getTypeOf(e22); u < e22.length; ) f3 = l - u, n = c2 ? (t22 = e22[u++], r22 = u < l ? e22[u++] : 0, u < l ? e22[u++] : 0) : (t22 = e22.charCodeAt(u++), r22 = u < l ? e22.charCodeAt(u++) : 0, u < l ? e22.charCodeAt(u++) : 0), i2 = t22 >> 2, s2 = (3 & t22) << 4 | r22 >> 4, a = 1 < f3 ? (15 & r22) << 2 | n >> 6 : 64, o = 2 < f3 ? 63 & n : 64, h2.push(p.charAt(i2) + p.charAt(s2) + p.charAt(a) + p.charAt(o));
          return h2.join("");
        }, r2.decode = function(e22) {
          var t22, r22, n, i2, s2, a, o = 0, h2 = 0, u = "data:";
          if (e22.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f3 = 3 * (e22 = e22.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e22.charAt(e22.length - 1) === p.charAt(64) && f3--, e22.charAt(e22.length - 2) === p.charAt(64) && f3--, f3 % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f3) : new Array(0 | f3); o < e22.length; ) t22 = p.indexOf(e22.charAt(o++)) << 2 | (i2 = p.indexOf(e22.charAt(o++))) >> 4, r22 = (15 & i2) << 4 | (s2 = p.indexOf(e22.charAt(o++))) >> 2, n = (3 & s2) << 6 | (a = p.indexOf(e22.charAt(o++))), l[h2++] = t22, 64 !== s2 && (l[h2++] = r22), 64 !== a && (l[h2++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
        var n = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a = e2("./stream/DataLengthProbe");
        function o(e22, t22, r22, n2, i22) {
          this.compressedSize = e22, this.uncompressedSize = t22, this.crc32 = r22, this.compression = n2, this.compressedContent = i22;
        }
        o.prototype = { getContentWorker: function() {
          var e22 = new i2(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t22 = this;
          return e22.on("end", function() {
            if (this.streamInfo.data_length !== t22.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e22;
        }, getCompressedWorker: function() {
          return new i2(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e22, t22, r22) {
          return e22.pipe(new s2()).pipe(new a("uncompressedSize")).pipe(t22.compressWorker(r22)).pipe(new a("compressedSize")).withStreamInfo("compression", t22);
        }, t2.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
        var n = e2("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r2.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
        var n = e2("./utils");
        var o = (function() {
          for (var e22, t22 = [], r22 = 0; r22 < 256; r22++) {
            e22 = r22;
            for (var n2 = 0; n2 < 8; n2++) e22 = 1 & e22 ? 3988292384 ^ e22 >>> 1 : e22 >>> 1;
            t22[r22] = e22;
          }
          return t22;
        })();
        t2.exports = function(e22, t22) {
          return void 0 !== e22 && e22.length ? "string" !== n.getTypeOf(e22) ? (function(e3, t3, r22, n2) {
            var i2 = o, s2 = n2 + r22;
            e3 ^= -1;
            for (var a = n2; a < s2; a++) e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          })(0 | t22, e22, e22.length, 0) : (function(e3, t3, r22, n2) {
            var i2 = o, s2 = n2 + r22;
            e3 ^= -1;
            for (var a = n2; a < s2; a++) e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          })(0 | t22, e22, e22.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e2, t2, r2) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e2, t2, r2) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), a = e2("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h2(e22, t22) {
          a.call(this, "FlateWorker/" + e22), this._pako = null, this._pakoAction = e22, this._pakoOptions = t22, this.meta = {};
        }
        r2.magic = "\b\0", s2.inherits(h2, a), h2.prototype.processChunk = function(e22) {
          this.meta = e22.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o, e22.data), false);
        }, h2.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t22 = this;
          this._pako.onData = function(e22) {
            t22.push({ data: e22, meta: t22.meta });
          };
        }, r2.compressWorker = function(e22) {
          return new h2("Deflate", e22);
        }, r2.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
        function A2(e22, t22) {
          var r22, n2 = "";
          for (r22 = 0; r22 < t22; r22++) n2 += String.fromCharCode(255 & e22), e22 >>>= 8;
          return n2;
        }
        function n(e22, t22, r22, n2, i22, s22) {
          var a, o, h2 = e22.file, u = e22.compression, l = s22 !== O.utf8encode, f3 = I.transformTo("string", s22(h2.name)), c = I.transformTo("string", O.utf8encode(h2.name)), d = h2.comment, p = I.transformTo("string", s22(d)), m2 = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h2.name.length, g = m2.length !== d.length, b = "", v = "", y = "", w = h2.dir, k = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t22 && !r22 || (x2.crc32 = e22.crc32, x2.compressedSize = e22.compressedSize, x2.uncompressedSize = e22.uncompressedSize);
          var S2 = 0;
          t22 && (S2 |= 8), l || !_ && !g || (S2 |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i22 ? (C = 798, z |= (function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          })(h2.unixPermissions, w)) : (C = 20, z |= (function(e3) {
            return 63 & (e3 || 0);
          })(h2.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A2(1, 1) + A2(B(f3), 4) + c, b += "up" + A2(v.length, 2) + v), g && (y = A2(1, 1) + A2(B(p), 4) + m2, b += "uc" + A2(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A2(S2, 2), E += u.magic, E += A2(a, 2), E += A2(o, 2), E += A2(x2.crc32, 4), E += A2(x2.compressedSize, 4), E += A2(x2.uncompressedSize, 4), E += A2(f3.length, 2), E += A2(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f3 + b, dirRecord: R.CENTRAL_FILE_HEADER + A2(C, 2) + E + A2(p.length, 2) + "\0\0\0\0" + A2(z, 4) + A2(n2, 4) + f3 + b + p };
        }
        var I = e2("../utils"), i2 = e2("../stream/GenericWorker"), O = e2("../utf8"), B = e2("../crc32"), R = e2("../signature");
        function s2(e22, t22, r22, n2) {
          i2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t22, this.zipPlatform = r22, this.encodeFileName = n2, this.streamFiles = e22, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s2, i2), s2.prototype.push = function(e22) {
          var t22 = e22.meta.percent || 0, r22 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e22) : (this.bytesWritten += e22.data.length, i2.prototype.push.call(this, { data: e22.data, meta: { currentFile: this.currentFile, percent: r22 ? (t22 + 100 * (r22 - n2 - 1)) / r22 : 100 } }));
        }, s2.prototype.openedSource = function(e22) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e22.file.name;
          var t22 = this.streamFiles && !e22.file.dir;
          if (t22) {
            var r22 = n(e22, t22, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r22.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s2.prototype.closedSource = function(e22) {
          this.accumulate = false;
          var t22 = this.streamFiles && !e22.file.dir, r22 = n(e22, t22, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r22.dirRecord), t22) this.push({ data: (function(e3) {
            return R.DATA_DESCRIPTOR + A2(e3.crc32, 4) + A2(e3.compressedSize, 4) + A2(e3.uncompressedSize, 4);
          })(e22), meta: { percent: 100 } });
          else for (this.push({ data: r22.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s2.prototype.flush = function() {
          for (var e22 = this.bytesWritten, t22 = 0; t22 < this.dirRecords.length; t22++) this.push({ data: this.dirRecords[t22], meta: { percent: 100 } });
          var r22 = this.bytesWritten - e22, n2 = (function(e3, t3, r3, n3, i22) {
            var s22 = I.transformTo("string", i22(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e3, 2) + A2(e3, 2) + A2(t3, 4) + A2(r3, 4) + A2(s22.length, 2) + s22;
          })(this.dirRecords.length, r22, e22, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s2.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s2.prototype.registerPrevious = function(e22) {
          this._sources.push(e22);
          var t22 = this;
          return e22.on("data", function(e3) {
            t22.processChunk(e3);
          }), e22.on("end", function() {
            t22.closedSource(t22.previous.streamInfo), t22._sources.length ? t22.prepareNextSource() : t22.end();
          }), e22.on("error", function(e3) {
            t22.error(e3);
          }), this;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s2.prototype.error = function(e22) {
          var t22 = this._sources;
          if (!i2.prototype.error.call(this, e22)) return false;
          for (var r22 = 0; r22 < t22.length; r22++) try {
            t22[r22].error(e22);
          } catch (e3) {
          }
          return true;
        }, s2.prototype.lock = function() {
          i2.prototype.lock.call(this);
          for (var e22 = this._sources, t22 = 0; t22 < e22.length; t22++) e22[t22].lock();
        }, t2.exports = s2;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
        var u = e2("../compressions"), n = e2("./ZipFileWorker");
        r2.generateWorker = function(e22, a, t22) {
          var o = new n(a.streamFiles, t22, a.platform, a.encodeFileName), h2 = 0;
          try {
            e22.forEach(function(e3, t3) {
              h2++;
              var r22 = (function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              })(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i2 = t3.dir, s2 = t3.date;
              t3._compressWorker(r22, n2).withStreamInfo("file", { name: e3, dir: i2, date: s2, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h2;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e22 = new n();
            for (var t22 in this) "function" != typeof this[t22] && (e22[t22] = this[t22]);
            return e22;
          };
        }
        (n.prototype = e2("./object")).loadAsync = e2("./load"), n.support = e2("./support"), n.defaults = e2("./defaults"), n.version = "3.10.1", n.loadAsync = function(e22, t22) {
          return new n().loadAsync(e22, t22);
        }, n.external = e2("./external"), t2.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
        var u = e2("./utils"), i2 = e2("./external"), n = e2("./utf8"), s2 = e2("./zipEntries"), a = e2("./stream/Crc32Probe"), l = e2("./nodejsUtils");
        function f3(n2) {
          return new i2.Promise(function(e22, t22) {
            var r22 = n2.decompressed.getContentWorker().pipe(new a());
            r22.on("error", function(e3) {
              t22(e3);
            }).on("end", function() {
              r22.streamInfo.crc32 !== n2.decompressed.crc32 ? t22(new Error("Corrupted zip : CRC32 mismatch")) : e22();
            }).resume();
          });
        }
        t2.exports = function(e22, o) {
          var h2 = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e22) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e22, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t22 = new s2(o);
            return t22.load(e3), t22;
          }).then(function(e3) {
            var t22 = [i2.Promise.resolve(e3)], r22 = e3.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r22.length; n2++) t22.push(f3(r22[n2]));
            return i2.Promise.all(t22);
          }).then(function(e3) {
            for (var t22 = e3.shift(), r22 = t22.files, n2 = 0; n2 < r22.length; n2++) {
              var i22 = r22[n2], s22 = i22.fileNameStr, a2 = u.resolve(i22.fileNameStr);
              h2.file(a2, i22.decompressed, { binary: true, optimizedBinaryString: true, date: i22.date, dir: i22.dir, comment: i22.fileCommentStr.length ? i22.fileCommentStr : null, unixPermissions: i22.unixPermissions, dosPermissions: i22.dosPermissions, createFolders: o.createFolders }), i22.dir || (h2.file(a2).unsafeOriginalName = s22);
            }
            return t22.zipComment.length && (h2.comment = t22.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
        var n = e2("../utils"), i2 = e2("../stream/GenericWorker");
        function s2(e22, t22) {
          i2.call(this, "Nodejs stream input adapter for " + e22), this._upstreamEnded = false, this._bindStream(t22);
        }
        n.inherits(s2, i2), s2.prototype._bindStream = function(e22) {
          var t22 = this;
          (this._stream = e22).pause(), e22.on("data", function(e3) {
            t22.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t22.isPaused ? this.generatedError = e3 : t22.error(e3);
          }).on("end", function() {
            t22.isPaused ? t22._upstreamEnded = true : t22.end();
          });
        }, s2.prototype.pause = function() {
          return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s2;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
        var i2 = e2("readable-stream").Readable;
        function n(e22, t22, r22) {
          i2.call(this, t22), this._helper = e22;
          var n2 = this;
          e22.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r22 && r22(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e2("../utils").inherits(n, i2), n.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e22, t22) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e22, t22);
          if ("number" == typeof e22) throw new Error('The "data" argument must not be a number');
          return new Buffer(e22, t22);
        }, allocBuffer: function(e22) {
          if (Buffer.alloc) return Buffer.alloc(e22);
          var t22 = new Buffer(e22);
          return t22.fill(0), t22;
        }, isBuffer: function(e22) {
          return Buffer.isBuffer(e22);
        }, isStream: function(e22) {
          return e22 && "function" == typeof e22.on && "function" == typeof e22.pause && "function" == typeof e22.resume;
        } };
      }, {}], 15: [function(e2, t2, r2) {
        function s2(e22, t22, r22) {
          var n2, i22 = u.getTypeOf(t22), s22 = u.extend(r22 || {}, f3);
          s22.date = s22.date || /* @__PURE__ */ new Date(), null !== s22.compression && (s22.compression = s22.compression.toUpperCase()), "string" == typeof s22.unixPermissions && (s22.unixPermissions = parseInt(s22.unixPermissions, 8)), s22.unixPermissions && 16384 & s22.unixPermissions && (s22.dir = true), s22.dosPermissions && 16 & s22.dosPermissions && (s22.dir = true), s22.dir && (e22 = g(e22)), s22.createFolders && (n2 = _(e22)) && b.call(this, n2, true);
          var a2 = "string" === i22 && false === s22.binary && false === s22.base64;
          r22 && void 0 !== r22.binary || (s22.binary = !a2), (t22 instanceof c && 0 === t22.uncompressedSize || s22.dir || !t22 || 0 === t22.length) && (s22.base64 = false, s22.binary = true, t22 = "", s22.compression = "STORE", i22 = "string");
          var o2 = null;
          o2 = t22 instanceof c || t22 instanceof l ? t22 : p.isNode && p.isStream(t22) ? new m2(e22, t22) : u.prepareContent(e22, t22, s22.binary, s22.optimizedBinaryString, s22.base64);
          var h22 = new d(e22, o2, s22);
          this.files[e22] = h22;
        }
        var i2 = e2("./utf8"), u = e2("./utils"), l = e2("./stream/GenericWorker"), a = e2("./stream/StreamHelper"), f3 = e2("./defaults"), c = e2("./compressedObject"), d = e2("./zipObject"), o = e2("./generate"), p = e2("./nodejsUtils"), m2 = e2("./nodejs/NodejsStreamInputAdapter"), _ = function(e22) {
          "/" === e22.slice(-1) && (e22 = e22.substring(0, e22.length - 1));
          var t22 = e22.lastIndexOf("/");
          return 0 < t22 ? e22.substring(0, t22) : "";
        }, g = function(e22) {
          return "/" !== e22.slice(-1) && (e22 += "/"), e22;
        }, b = function(e22, t22) {
          return t22 = void 0 !== t22 ? t22 : f3.createFolders, e22 = g(e22), this.files[e22] || s2.call(this, e22, null, { dir: true, createFolders: t22 }), this.files[e22];
        };
        function h2(e22) {
          return "[object RegExp]" === Object.prototype.toString.call(e22);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e22) {
          var t22, r22, n2;
          for (t22 in this.files) n2 = this.files[t22], (r22 = t22.slice(this.root.length, t22.length)) && t22.slice(0, this.root.length) === this.root && e22(r22, n2);
        }, filter: function(r22) {
          var n2 = [];
          return this.forEach(function(e22, t22) {
            r22(e22, t22) && n2.push(t22);
          }), n2;
        }, file: function(e22, t22, r22) {
          if (1 !== arguments.length) return e22 = this.root + e22, s2.call(this, e22, t22, r22), this;
          if (h2(e22)) {
            var n2 = e22;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i22 = this.files[this.root + e22];
          return i22 && !i22.dir ? i22 : null;
        }, folder: function(r22) {
          if (!r22) return this;
          if (h2(r22)) return this.filter(function(e3, t3) {
            return t3.dir && r22.test(e3);
          });
          var e22 = this.root + r22, t22 = b.call(this, e22), n2 = this.clone();
          return n2.root = t22.name, n2;
        }, remove: function(r22) {
          r22 = this.root + r22;
          var e22 = this.files[r22];
          if (e22 || ("/" !== r22.slice(-1) && (r22 += "/"), e22 = this.files[r22]), e22 && !e22.dir) delete this.files[r22];
          else for (var t22 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r22.length) === r22;
          }), n2 = 0; n2 < t22.length; n2++) delete this.files[t22[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e22) {
          var t22, r22 = {};
          try {
            if ((r22 = u.extend(e22 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r22.type.toLowerCase(), r22.compression = r22.compression.toUpperCase(), "binarystring" === r22.type && (r22.type = "string"), !r22.type) throw new Error("No output type specified.");
            u.checkSupport(r22.type), "darwin" !== r22.platform && "freebsd" !== r22.platform && "linux" !== r22.platform && "sunos" !== r22.platform || (r22.platform = "UNIX"), "win32" === r22.platform && (r22.platform = "DOS");
            var n2 = r22.comment || this.comment || "";
            t22 = o.generateWorker(this, r22, n2);
          } catch (e3) {
            (t22 = new l("error")).error(e3);
          }
          return new a(t22, r22.type || "string", r22.mimeType);
        }, generateAsync: function(e22, t22) {
          return this.generateInternalStream(e22).accumulate(t22);
        }, generateNodeStream: function(e22, t22) {
          return (e22 = e22 || {}).type || (e22.type = "nodebuffer"), this.generateInternalStream(e22).toNodejsStream(t22);
        } };
        t2.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
        t2.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t2, r2) {
        var n = e2("./DataReader");
        function i2(e22) {
          n.call(this, e22);
          for (var t22 = 0; t22 < this.data.length; t22++) e22[t22] = 255 & e22[t22];
        }
        e2("../utils").inherits(i2, n), i2.prototype.byteAt = function(e22) {
          return this.data[this.zero + e22];
        }, i2.prototype.lastIndexOfSignature = function(e22) {
          for (var t22 = e22.charCodeAt(0), r22 = e22.charCodeAt(1), n2 = e22.charCodeAt(2), i22 = e22.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2) if (this.data[s2] === t22 && this.data[s2 + 1] === r22 && this.data[s2 + 2] === n2 && this.data[s2 + 3] === i22) return s2 - this.zero;
          return -1;
        }, i2.prototype.readAndCheckSignature = function(e22) {
          var t22 = e22.charCodeAt(0), r22 = e22.charCodeAt(1), n2 = e22.charCodeAt(2), i22 = e22.charCodeAt(3), s2 = this.readData(4);
          return t22 === s2[0] && r22 === s2[1] && n2 === s2[2] && i22 === s2[3];
        }, i2.prototype.readData = function(e22) {
          if (this.checkOffset(e22), 0 === e22) return [];
          var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
          return this.index += e22, t22;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
        var n = e2("../utils");
        function i2(e22) {
          this.data = e22, this.length = e22.length, this.index = 0, this.zero = 0;
        }
        i2.prototype = { checkOffset: function(e22) {
          this.checkIndex(this.index + e22);
        }, checkIndex: function(e22) {
          if (this.length < this.zero + e22 || e22 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e22 + "). Corrupted zip ?");
        }, setIndex: function(e22) {
          this.checkIndex(e22), this.index = e22;
        }, skip: function(e22) {
          this.setIndex(this.index + e22);
        }, byteAt: function() {
        }, readInt: function(e22) {
          var t22, r22 = 0;
          for (this.checkOffset(e22), t22 = this.index + e22 - 1; t22 >= this.index; t22--) r22 = (r22 << 8) + this.byteAt(t22);
          return this.index += e22, r22;
        }, readString: function(e22) {
          return n.transformTo("string", this.readData(e22));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e22 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e22 >> 25 & 127), (e22 >> 21 & 15) - 1, e22 >> 16 & 31, e22 >> 11 & 31, e22 >> 5 & 63, (31 & e22) << 1));
        } }, t2.exports = i2;
      }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
        var n = e2("./Uint8ArrayReader");
        function i2(e22) {
          n.call(this, e22);
        }
        e2("../utils").inherits(i2, n), i2.prototype.readData = function(e22) {
          this.checkOffset(e22);
          var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
          return this.index += e22, t22;
        }, t2.exports = i2;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
        var n = e2("./DataReader");
        function i2(e22) {
          n.call(this, e22);
        }
        e2("../utils").inherits(i2, n), i2.prototype.byteAt = function(e22) {
          return this.data.charCodeAt(this.zero + e22);
        }, i2.prototype.lastIndexOfSignature = function(e22) {
          return this.data.lastIndexOf(e22) - this.zero;
        }, i2.prototype.readAndCheckSignature = function(e22) {
          return e22 === this.readData(4);
        }, i2.prototype.readData = function(e22) {
          this.checkOffset(e22);
          var t22 = this.data.slice(this.zero + this.index, this.zero + this.index + e22);
          return this.index += e22, t22;
        }, t2.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
        var n = e2("./ArrayReader");
        function i2(e22) {
          n.call(this, e22);
        }
        e2("../utils").inherits(i2, n), i2.prototype.readData = function(e22) {
          if (this.checkOffset(e22), 0 === e22) return new Uint8Array(0);
          var t22 = this.data.subarray(this.zero + this.index, this.zero + this.index + e22);
          return this.index += e22, t22;
        }, t2.exports = i2;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
        var n = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), a = e2("./StringReader"), o = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
        t2.exports = function(e22) {
          var t22 = n.getTypeOf(e22);
          return n.checkSupport(t22), "string" !== t22 || i2.uint8array ? "nodebuffer" === t22 ? new o(e22) : i2.uint8array ? new h2(n.transformTo("uint8array", e22)) : new s2(n.transformTo("array", e22)) : new a(e22);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t2, r2) {
        var n = e2("./GenericWorker"), i2 = e2("../utils");
        function s2(e22) {
          n.call(this, "ConvertWorker to " + e22), this.destType = e22;
        }
        i2.inherits(s2, n), s2.prototype.processChunk = function(e22) {
          this.push({ data: i2.transformTo(this.destType, e22.data), meta: e22.meta });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
        var n = e2("./GenericWorker"), i2 = e2("../crc32");
        function s2() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e2("../utils").inherits(s2, n), s2.prototype.processChunk = function(e22) {
          this.streamInfo.crc32 = i2(e22.data, this.streamInfo.crc32 || 0), this.push(e22);
        }, t2.exports = s2;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
        var n = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e22) {
          i2.call(this, "DataLengthProbe for " + e22), this.propName = e22, this.withStreamInfo(e22, 0);
        }
        n.inherits(s2, i2), s2.prototype.processChunk = function(e22) {
          if (e22) {
            var t22 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t22 + e22.data.length;
          }
          i2.prototype.processChunk.call(this, e22);
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
        var n = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e22) {
          i2.call(this, "DataWorker");
          var t22 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e22.then(function(e3) {
            t22.dataIsReady = true, t22.data = e3, t22.max = e3 && e3.length || 0, t22.type = n.getTypeOf(e3), t22.isPaused || t22._tickAndRepeat();
          }, function(e3) {
            t22.error(e3);
          });
        }
        n.inherits(s2, i2), s2.prototype.cleanUp = function() {
          i2.prototype.cleanUp.call(this), this.data = null;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s2.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s2.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e22 = null, t22 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e22 = this.data.substring(this.index, t22);
              break;
            case "uint8array":
              e22 = this.data.subarray(this.index, t22);
              break;
            case "array":
            case "nodebuffer":
              e22 = this.data.slice(this.index, t22);
          }
          return this.index = t22, this.push({ data: e22, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
        function n(e22) {
          this.name = e22 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e22) {
          this.emit("data", e22);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e22) {
            this.emit("error", e22);
          }
          return true;
        }, error: function(e22) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e22 : (this.isFinished = true, this.emit("error", e22), this.previous && this.previous.error(e22), this.cleanUp()), true);
        }, on: function(e22, t22) {
          return this._listeners[e22].push(t22), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e22, t22) {
          if (this._listeners[e22]) for (var r22 = 0; r22 < this._listeners[e22].length; r22++) this._listeners[e22][r22].call(this, t22);
        }, pipe: function(e22) {
          return e22.registerPrevious(this);
        }, registerPrevious: function(e22) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e22.streamInfo, this.mergeStreamInfo(), this.previous = e22;
          var t22 = this;
          return e22.on("data", function(e3) {
            t22.processChunk(e3);
          }), e22.on("end", function() {
            t22.end();
          }), e22.on("error", function(e3) {
            t22.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e22 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e22 = true), this.previous && this.previous.resume(), !e22;
        }, flush: function() {
        }, processChunk: function(e22) {
          this.push(e22);
        }, withStreamInfo: function(e22, t22) {
          return this.extraStreamInfo[e22] = t22, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e22 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e22) && (this.streamInfo[e22] = this.extraStreamInfo[e22]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e22 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e22 : e22;
        } }, t2.exports = n;
      }, {}], 29: [function(e2, t2, r2) {
        var h2 = e2("../utils"), i2 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u = e2("../base64"), n = e2("../support"), a = e2("../external"), o = null;
        if (n.nodestream) try {
          o = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e22) {
        }
        function l(e22, o2) {
          return new a.Promise(function(t22, r22) {
            var n2 = [], i22 = e22._internalType, s22 = e22._outputType, a2 = e22._mimeType;
            e22.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r22(e3);
            }).on("end", function() {
              try {
                var e3 = (function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h2.transformTo(e4, t3);
                  }
                })(s22, (function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                })(i22, n2), a2);
                t22(e3);
              } catch (e4) {
                r22(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f3(e22, t22, r22) {
          var n2 = t22;
          switch (t22) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t22, this._mimeType = r22, h2.checkSupport(n2), this._worker = e22.pipe(new i2(n2)), e22.lock();
          } catch (e3) {
            this._worker = new s2("error"), this._worker.error(e3);
          }
        }
        f3.prototype = { accumulate: function(e22) {
          return l(this, e22);
        }, on: function(e22, t22) {
          var r22 = this;
          return "data" === e22 ? this._worker.on(e22, function(e3) {
            t22.call(r22, e3.data, e3.meta);
          }) : this._worker.on(e22, function() {
            h2.delay(t22, arguments, r22);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e22) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e22);
        } }, t2.exports = f3;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r2.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e22) {
            try {
              var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i2.append(n), r2.blob = 0 === i2.getBlob("application/zip").size;
            } catch (e3) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e2("readable-stream").Readable;
        } catch (e22) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
        for (var o = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n = e2("./stream/GenericWorker"), u = new Array(256), i2 = 0; i2 < 256; i2++) u[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s2.utf8encode = function(e22) {
          return h2.nodebuffer ? r2.newBufferFrom(e22, "utf-8") : (function(e3) {
            var t22, r22, n2, i22, s22, a2 = e3.length, o2 = 0;
            for (i22 = 0; i22 < a2; i22++) 55296 == (64512 & (r22 = e3.charCodeAt(i22))) && i22 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i22 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i22++), o2 += r22 < 128 ? 1 : r22 < 2048 ? 2 : r22 < 65536 ? 3 : 4;
            for (t22 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i22 = s22 = 0; s22 < o2; i22++) 55296 == (64512 & (r22 = e3.charCodeAt(i22))) && i22 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i22 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i22++), r22 < 128 ? t22[s22++] = r22 : (r22 < 2048 ? t22[s22++] = 192 | r22 >>> 6 : (r22 < 65536 ? t22[s22++] = 224 | r22 >>> 12 : (t22[s22++] = 240 | r22 >>> 18, t22[s22++] = 128 | r22 >>> 12 & 63), t22[s22++] = 128 | r22 >>> 6 & 63), t22[s22++] = 128 | 63 & r22);
            return t22;
          })(e22);
        }, s2.utf8decode = function(e22) {
          return h2.nodebuffer ? o.transformTo("nodebuffer", e22).toString("utf-8") : (function(e3) {
            var t22, r22, n2, i22, s22 = e3.length, a2 = new Array(2 * s22);
            for (t22 = r22 = 0; t22 < s22; ) if ((n2 = e3[t22++]) < 128) a2[r22++] = n2;
            else if (4 < (i22 = u[n2])) a2[r22++] = 65533, t22 += i22 - 1;
            else {
              for (n2 &= 2 === i22 ? 31 : 3 === i22 ? 15 : 7; 1 < i22 && t22 < s22; ) n2 = n2 << 6 | 63 & e3[t22++], i22--;
              1 < i22 ? a2[r22++] = 65533 : n2 < 65536 ? a2[r22++] = n2 : (n2 -= 65536, a2[r22++] = 55296 | n2 >> 10 & 1023, a2[r22++] = 56320 | 1023 & n2);
            }
            return a2.length !== r22 && (a2.subarray ? a2 = a2.subarray(0, r22) : a2.length = r22), o.applyFromCharCode(a2);
          })(e22 = o.transformTo(h2.uint8array ? "uint8array" : "array", e22));
        }, o.inherits(a, n), a.prototype.processChunk = function(e22) {
          var t22 = o.transformTo(h2.uint8array ? "uint8array" : "array", e22.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r22 = t22;
              (t22 = new Uint8Array(r22.length + this.leftOver.length)).set(this.leftOver, 0), t22.set(r22, this.leftOver.length);
            } else t22 = this.leftOver.concat(t22);
            this.leftOver = null;
          }
          var n2 = (function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          })(t22), i22 = t22;
          n2 !== t22.length && (h2.uint8array ? (i22 = t22.subarray(0, n2), this.leftOver = t22.subarray(n2, t22.length)) : (i22 = t22.slice(0, n2), this.leftOver = t22.slice(n2, t22.length))), this.push({ data: s2.utf8decode(i22), meta: e22.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s2.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e22) {
          this.push({ data: s2.utf8encode(e22.data), meta: e22.meta });
        }, s2.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a) {
        var o = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u = e2("./external");
        function n(e22) {
          return e22;
        }
        function l(e22, t22) {
          for (var r22 = 0; r22 < e22.length; ++r22) t22[r22] = 255 & e22.charCodeAt(r22);
          return t22;
        }
        e2("setimmediate"), a.newBlob = function(t22, r22) {
          a.checkSupport("blob");
          try {
            return new Blob([t22], { type: r22 });
          } catch (e22) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t22), n2.getBlob(r22);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i2 = { stringifyByChunk: function(e22, t22, r22) {
          var n2 = [], i22 = 0, s22 = e22.length;
          if (s22 <= r22) return String.fromCharCode.apply(null, e22);
          for (; i22 < s22; ) "array" === t22 || "nodebuffer" === t22 ? n2.push(String.fromCharCode.apply(null, e22.slice(i22, Math.min(i22 + r22, s22)))) : n2.push(String.fromCharCode.apply(null, e22.subarray(i22, Math.min(i22 + r22, s22)))), i22 += r22;
          return n2.join("");
        }, stringifyByChar: function(e22) {
          for (var t22 = "", r22 = 0; r22 < e22.length; r22++) t22 += String.fromCharCode(e22[r22]);
          return t22;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e22) {
            return false;
          }
        })(), nodebuffer: (function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e22) {
            return false;
          }
        })() } };
        function s2(e22) {
          var t22 = 65536, r22 = a.getTypeOf(e22), n2 = true;
          if ("uint8array" === r22 ? n2 = i2.applyCanBeUsed.uint8array : "nodebuffer" === r22 && (n2 = i2.applyCanBeUsed.nodebuffer), n2) for (; 1 < t22; ) try {
            return i2.stringifyByChunk(e22, r22, t22);
          } catch (e3) {
            t22 = Math.floor(t22 / 2);
          }
          return i2.stringifyByChar(e22);
        }
        function f3(e22, t22) {
          for (var r22 = 0; r22 < e22.length; r22++) t22[r22] = e22[r22];
          return t22;
        }
        a.applyFromCharCode = s2;
        var c = {};
        c.string = { string: n, array: function(e22) {
          return l(e22, new Array(e22.length));
        }, arraybuffer: function(e22) {
          return c.string.uint8array(e22).buffer;
        }, uint8array: function(e22) {
          return l(e22, new Uint8Array(e22.length));
        }, nodebuffer: function(e22) {
          return l(e22, r2.allocBuffer(e22.length));
        } }, c.array = { string: s2, array: n, arraybuffer: function(e22) {
          return new Uint8Array(e22).buffer;
        }, uint8array: function(e22) {
          return new Uint8Array(e22);
        }, nodebuffer: function(e22) {
          return r2.newBufferFrom(e22);
        } }, c.arraybuffer = { string: function(e22) {
          return s2(new Uint8Array(e22));
        }, array: function(e22) {
          return f3(new Uint8Array(e22), new Array(e22.byteLength));
        }, arraybuffer: n, uint8array: function(e22) {
          return new Uint8Array(e22);
        }, nodebuffer: function(e22) {
          return r2.newBufferFrom(new Uint8Array(e22));
        } }, c.uint8array = { string: s2, array: function(e22) {
          return f3(e22, new Array(e22.length));
        }, arraybuffer: function(e22) {
          return e22.buffer;
        }, uint8array: n, nodebuffer: function(e22) {
          return r2.newBufferFrom(e22);
        } }, c.nodebuffer = { string: s2, array: function(e22) {
          return f3(e22, new Array(e22.length));
        }, arraybuffer: function(e22) {
          return c.nodebuffer.uint8array(e22).buffer;
        }, uint8array: function(e22) {
          return f3(e22, new Uint8Array(e22.length));
        }, nodebuffer: n }, a.transformTo = function(e22, t22) {
          if (t22 = t22 || "", !e22) return t22;
          a.checkSupport(e22);
          var r22 = a.getTypeOf(t22);
          return c[r22][e22](t22);
        }, a.resolve = function(e22) {
          for (var t22 = e22.split("/"), r22 = [], n2 = 0; n2 < t22.length; n2++) {
            var i22 = t22[n2];
            "." === i22 || "" === i22 && 0 !== n2 && n2 !== t22.length - 1 || (".." === i22 ? r22.pop() : r22.push(i22));
          }
          return r22.join("/");
        }, a.getTypeOf = function(e22) {
          return "string" == typeof e22 ? "string" : "[object Array]" === Object.prototype.toString.call(e22) ? "array" : o.nodebuffer && r2.isBuffer(e22) ? "nodebuffer" : o.uint8array && e22 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e22 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e22) {
          if (!o[e22.toLowerCase()]) throw new Error(e22 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e22) {
          var t22, r22, n2 = "";
          for (r22 = 0; r22 < (e22 || "").length; r22++) n2 += "\\x" + ((t22 = e22.charCodeAt(r22)) < 16 ? "0" : "") + t22.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e22, t22, r22) {
          setImmediate(function() {
            e22.apply(r22 || null, t22 || []);
          });
        }, a.inherits = function(e22, t22) {
          function r22() {
          }
          r22.prototype = t22.prototype, e22.prototype = new r22();
        }, a.extend = function() {
          var e22, t22, r22 = {};
          for (e22 = 0; e22 < arguments.length; e22++) for (t22 in arguments[e22]) Object.prototype.hasOwnProperty.call(arguments[e22], t22) && void 0 === r22[t22] && (r22[t22] = arguments[e22][t22]);
          return r22;
        }, a.prepareContent = function(r22, e22, n2, i22, s22) {
          return u.Promise.resolve(e22).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t22, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t22(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t22 = a.getTypeOf(e3);
            return t22 ? ("arraybuffer" === t22 ? e3 = a.transformTo("uint8array", e3) : "string" === t22 && (s22 ? e3 = h2.decode(e3) : n2 && true !== i22 && (e3 = (function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            })(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r22 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
        var n = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), a = e2("./zipEntry"), o = e2("./support");
        function h2(e22) {
          this.files = [], this.loadOptions = e22;
        }
        h2.prototype = { checkSignature: function(e22) {
          if (!this.reader.readAndCheckSignature(e22)) {
            this.reader.index -= 4;
            var t22 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t22) + ", expected " + i2.pretty(e22) + ")");
          }
        }, isSignature: function(e22, t22) {
          var r22 = this.reader.index;
          this.reader.setIndex(e22);
          var n2 = this.reader.readString(4) === t22;
          return this.reader.setIndex(r22), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e22 = this.reader.readData(this.zipCommentLength), t22 = o.uint8array ? "uint8array" : "array", r22 = i2.transformTo(t22, e22);
          this.zipComment = this.loadOptions.decodeFileName(r22);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e22, t22, r22, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e22 = this.reader.readInt(2), t22 = this.reader.readInt(4), r22 = this.reader.readData(t22), this.zip64ExtensibleData[e22] = { id: e22, length: t22, value: r22 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e22, t22;
          for (e22 = 0; e22 < this.files.length; e22++) t22 = this.files[e22], this.reader.setIndex(t22.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t22.readLocalPart(this.reader), t22.handleUTF8(), t22.processAttributes();
        }, readCentralDir: function() {
          var e22;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); ) (e22 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e22);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e22 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
          if (e22 < 0) throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e22);
          var t22 = e22;
          if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e22 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e22), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r22 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r22 += 20, r22 += 12 + this.zip64EndOfCentralSize);
          var n2 = t22 - r22;
          if (0 < n2) this.isSignature(t22, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e22) {
          this.reader = n(e22);
        }, load: function(e22) {
          this.prepareReader(e22), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
        var n = e2("./reader/readerFor"), s2 = e2("./utils"), i2 = e2("./compressedObject"), a = e2("./crc32"), o = e2("./utf8"), h2 = e2("./compressions"), u = e2("./support");
        function l(e22, t22) {
          this.options = e22, this.loadOptions = t22;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e22) {
          var t22, r22;
          if (e22.skip(22), this.fileNameLength = e22.readInt(2), r22 = e22.readInt(2), this.fileName = e22.readData(this.fileNameLength), e22.skip(r22), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t22 = (function(e3) {
            for (var t3 in h2) if (Object.prototype.hasOwnProperty.call(h2, t3) && h2[t3].magic === e3) return h2[t3];
            return null;
          })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
          this.decompressed = new i2(this.compressedSize, this.uncompressedSize, this.crc32, t22, e22.readData(this.compressedSize));
        }, readCentralPart: function(e22) {
          this.versionMadeBy = e22.readInt(2), e22.skip(2), this.bitFlag = e22.readInt(2), this.compressionMethod = e22.readString(2), this.date = e22.readDate(), this.crc32 = e22.readInt(4), this.compressedSize = e22.readInt(4), this.uncompressedSize = e22.readInt(4);
          var t22 = e22.readInt(2);
          if (this.extraFieldsLength = e22.readInt(2), this.fileCommentLength = e22.readInt(2), this.diskNumberStart = e22.readInt(2), this.internalFileAttributes = e22.readInt(2), this.externalFileAttributes = e22.readInt(4), this.localHeaderOffset = e22.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e22.skip(t22), this.readExtraFields(e22), this.parseZIP64ExtraField(e22), this.fileComment = e22.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e22 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e22 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e22 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e22 = n(this.extraFields[1].value);
            this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e22.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e22.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e22.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e22.readInt(4));
          }
        }, readExtraFields: function(e22) {
          var t22, r22, n2, i22 = e22.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e22.index + 4 < i22; ) t22 = e22.readInt(2), r22 = e22.readInt(2), n2 = e22.readData(r22), this.extraFields[t22] = { id: t22, length: r22, value: n2 };
          e22.setIndex(i22);
        }, handleUTF8: function() {
          var e22 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t22 = this.findExtraFieldUnicodePath();
            if (null !== t22) this.fileNameStr = t22;
            else {
              var r22 = s2.transformTo(e22, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r22);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i22 = s2.transformTo(e22, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i22);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e22 = this.extraFields[28789];
          if (e22) {
            var t22 = n(e22.value);
            return 1 !== t22.readInt(1) ? null : a(this.fileName) !== t22.readInt(4) ? null : o.utf8decode(t22.readData(e22.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e22 = this.extraFields[25461];
          if (e22) {
            var t22 = n(e22.value);
            return 1 !== t22.readInt(1) ? null : a(this.fileComment) !== t22.readInt(4) ? null : o.utf8decode(t22.readData(e22.length - 5));
          }
          return null;
        } }, t2.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
        function n(e22, t22, r22) {
          this.name = e22, this.dir = r22.dir, this.date = r22.date, this.comment = r22.comment, this.unixPermissions = r22.unixPermissions, this.dosPermissions = r22.dosPermissions, this._data = t22, this._dataBinary = r22.binary, this.options = { compression: r22.compression, compressionOptions: r22.compressionOptions };
        }
        var s2 = e2("./stream/StreamHelper"), i2 = e2("./stream/DataWorker"), a = e2("./utf8"), o = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
        n.prototype = { internalStream: function(e22) {
          var t22 = null, r22 = "string";
          try {
            if (!e22) throw new Error("No output type specified.");
            var n2 = "string" === (r22 = e22.toLowerCase()) || "text" === r22;
            "binarystring" !== r22 && "text" !== r22 || (r22 = "string"), t22 = this._decompressWorker();
            var i22 = !this._dataBinary;
            i22 && !n2 && (t22 = t22.pipe(new a.Utf8EncodeWorker())), !i22 && n2 && (t22 = t22.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t22 = new h2("error")).error(e3);
          }
          return new s2(t22, r22, "");
        }, async: function(e22, t22) {
          return this.internalStream(e22).accumulate(t22);
        }, nodeStream: function(e22, t22) {
          return this.internalStream(e22 || "nodebuffer").toNodejsStream(t22);
        }, _compressWorker: function(e22, t22) {
          if (this._data instanceof o && this._data.compression.magic === e22.magic) return this._data.getCompressedWorker();
          var r22 = this._decompressWorker();
          return this._dataBinary || (r22 = r22.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r22, e22, t22);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i2(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f3 = 0; f3 < u.length; f3++) n.prototype[u[f3]] = l;
        t2.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l, t2) {
        (function(t22) {
          var r2, n, e22 = t22.MutationObserver || t22.WebKitMutationObserver;
          if (e22) {
            var i2 = 0, s2 = new e22(u), a = t22.document.createTextNode("");
            s2.observe(a, { characterData: true }), r2 = function() {
              a.data = i2 = ++i2 % 2;
            };
          } else if (t22.setImmediate || void 0 === t22.MessageChannel) r2 = "document" in t22 && "onreadystatechange" in t22.document.createElement("script") ? function() {
            var e3 = t22.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t22.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
          else {
            var o = new t22.MessageChannel();
            o.port1.onmessage = u, r2 = function() {
              o.port2.postMessage(0);
            };
          }
          var h2 = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r22 = h2.length; r22; ) {
              for (t3 = h2, h2 = [], e3 = -1; ++e3 < r22; ) t3[e3]();
              r22 = h2.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h2.push(e3) || n || r2();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t2, r2) {
        var i2 = e2("immediate");
        function u() {
        }
        var l = {}, s2 = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e22) {
          if ("function" != typeof e22) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e22 !== u && d(this, e22);
        }
        function h2(e22, t22, r22) {
          this.promise = e22, "function" == typeof t22 && (this.onFulfilled = t22, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r22 && (this.onRejected = r22, this.callRejected = this.otherCallRejected);
        }
        function f3(t22, r22, n2) {
          i2(function() {
            var e22;
            try {
              e22 = r22(n2);
            } catch (e3) {
              return l.reject(t22, e3);
            }
            e22 === t22 ? l.reject(t22, new TypeError("Cannot resolve promise with itself")) : l.resolve(t22, e22);
          });
        }
        function c(e22) {
          var t22 = e22 && e22.then;
          if (e22 && ("object" == typeof e22 || "function" == typeof e22) && "function" == typeof t22) return function() {
            t22.apply(e22, arguments);
          };
        }
        function d(t22, e22) {
          var r22 = false;
          function n2(e3) {
            r22 || (r22 = true, l.reject(t22, e3));
          }
          function i22(e3) {
            r22 || (r22 = true, l.resolve(t22, e3));
          }
          var s22 = p(function() {
            e22(i22, n2);
          });
          "error" === s22.status && n2(s22.value);
        }
        function p(e22, t22) {
          var r22 = {};
          try {
            r22.value = e22(t22), r22.status = "success";
          } catch (e3) {
            r22.status = "error", r22.value = e3;
          }
          return r22;
        }
        (t2.exports = o).prototype.finally = function(t22) {
          if ("function" != typeof t22) return this;
          var r22 = this.constructor;
          return this.then(function(e22) {
            return r22.resolve(t22()).then(function() {
              return e22;
            });
          }, function(e22) {
            return r22.resolve(t22()).then(function() {
              throw e22;
            });
          });
        }, o.prototype.catch = function(e22) {
          return this.then(null, e22);
        }, o.prototype.then = function(e22, t22) {
          if ("function" != typeof e22 && this.state === a || "function" != typeof t22 && this.state === s2) return this;
          var r22 = new this.constructor(u);
          this.state !== n ? f3(r22, this.state === a ? e22 : t22, this.outcome) : this.queue.push(new h2(r22, e22, t22));
          return r22;
        }, h2.prototype.callFulfilled = function(e22) {
          l.resolve(this.promise, e22);
        }, h2.prototype.otherCallFulfilled = function(e22) {
          f3(this.promise, this.onFulfilled, e22);
        }, h2.prototype.callRejected = function(e22) {
          l.reject(this.promise, e22);
        }, h2.prototype.otherCallRejected = function(e22) {
          f3(this.promise, this.onRejected, e22);
        }, l.resolve = function(e22, t22) {
          var r22 = p(c, t22);
          if ("error" === r22.status) return l.reject(e22, r22.value);
          var n2 = r22.value;
          if (n2) d(e22, n2);
          else {
            e22.state = a, e22.outcome = t22;
            for (var i22 = -1, s22 = e22.queue.length; ++i22 < s22; ) e22.queue[i22].callFulfilled(t22);
          }
          return e22;
        }, l.reject = function(e22, t22) {
          e22.state = s2, e22.outcome = t22;
          for (var r22 = -1, n2 = e22.queue.length; ++r22 < n2; ) e22.queue[r22].callRejected(t22);
          return e22;
        }, o.resolve = function(e22) {
          if (e22 instanceof this) return e22;
          return l.resolve(new this(u), e22);
        }, o.reject = function(e22) {
          var t22 = new this(u);
          return l.reject(t22, e22);
        }, o.all = function(e22) {
          var r22 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e22)) return this.reject(new TypeError("must be an array"));
          var n2 = e22.length, i22 = false;
          if (!n2) return this.resolve([]);
          var s22 = new Array(n2), a2 = 0, t22 = -1, o2 = new this(u);
          for (; ++t22 < n2; ) h22(e22[t22], t22);
          return o2;
          function h22(e3, t3) {
            r22.resolve(e3).then(function(e4) {
              s22[t3] = e4, ++a2 !== n2 || i22 || (i22 = true, l.resolve(o2, s22));
            }, function(e4) {
              i22 || (i22 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e22) {
          var t22 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e22)) return this.reject(new TypeError("must be an array"));
          var r22 = e22.length, n2 = false;
          if (!r22) return this.resolve([]);
          var i22 = -1, s22 = new this(u);
          for (; ++i22 < r22; ) a2 = e22[i22], t22.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s22, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s22, e3));
          });
          var a2;
          return s22;
        };
      }, { immediate: 36 }], 38: [function(e2, t2, r2) {
        var n = {};
        (0, e2("./lib/utils/common").assign)(n, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
        var a = e2("./zlib/deflate"), o = e2("./utils/common"), h2 = e2("./utils/strings"), i2 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u = Object.prototype.toString, l = 0, f3 = -1, c = 0, d = 8;
        function p(e22) {
          if (!(this instanceof p)) return new p(e22);
          this.options = o.assign({ level: f3, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e22 || {});
          var t22 = this.options;
          t22.raw && 0 < t22.windowBits ? t22.windowBits = -t22.windowBits : t22.gzip && 0 < t22.windowBits && t22.windowBits < 16 && (t22.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
          var r22 = a.deflateInit2(this.strm, t22.level, t22.method, t22.windowBits, t22.memLevel, t22.strategy);
          if (r22 !== l) throw new Error(i2[r22]);
          if (t22.header && a.deflateSetHeader(this.strm, t22.header), t22.dictionary) {
            var n2;
            if (n2 = "string" == typeof t22.dictionary ? h2.string2buf(t22.dictionary) : "[object ArrayBuffer]" === u.call(t22.dictionary) ? new Uint8Array(t22.dictionary) : t22.dictionary, (r22 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i2[r22]);
            this._dict_set = true;
          }
        }
        function n(e22, t22) {
          var r22 = new p(t22);
          if (r22.push(e22, true), r22.err) throw r22.msg || i2[r22.err];
          return r22.result;
        }
        p.prototype.push = function(e22, t22) {
          var r22, n2, i22 = this.strm, s22 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t22 === ~~t22 ? t22 : true === t22 ? 4 : 0, "string" == typeof e22 ? i22.input = h2.string2buf(e22) : "[object ArrayBuffer]" === u.call(e22) ? i22.input = new Uint8Array(e22) : i22.input = e22, i22.next_in = 0, i22.avail_in = i22.input.length;
          do {
            if (0 === i22.avail_out && (i22.output = new o.Buf8(s22), i22.next_out = 0, i22.avail_out = s22), 1 !== (r22 = a.deflate(i22, n2)) && r22 !== l) return this.onEnd(r22), !(this.ended = true);
            0 !== i22.avail_out && (0 !== i22.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o.shrinkBuf(i22.output, i22.next_out))) : this.onData(o.shrinkBuf(i22.output, i22.next_out)));
          } while ((0 < i22.avail_in || 0 === i22.avail_out) && 1 !== r22);
          return 4 === n2 ? (r22 = a.deflateEnd(this.strm), this.onEnd(r22), this.ended = true, r22 === l) : 2 !== n2 || (this.onEnd(l), !(i22.avail_out = 0));
        }, p.prototype.onData = function(e22) {
          this.chunks.push(e22);
        }, p.prototype.onEnd = function(e22) {
          e22 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e22, this.msg = this.strm.msg;
        }, r2.Deflate = p, r2.deflate = n, r2.deflateRaw = function(e22, t22) {
          return (t22 = t22 || {}).raw = true, n(e22, t22);
        }, r2.gzip = function(e22, t22) {
          return (t22 = t22 || {}).gzip = true, n(e22, t22);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
        var c = e2("./zlib/inflate"), d = e2("./utils/common"), p = e2("./utils/strings"), m2 = e2("./zlib/constants"), n = e2("./zlib/messages"), i2 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e22) {
          if (!(this instanceof a)) return new a(e22);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e22 || {});
          var t22 = this.options;
          t22.raw && 0 <= t22.windowBits && t22.windowBits < 16 && (t22.windowBits = -t22.windowBits, 0 === t22.windowBits && (t22.windowBits = -15)), !(0 <= t22.windowBits && t22.windowBits < 16) || e22 && e22.windowBits || (t22.windowBits += 32), 15 < t22.windowBits && t22.windowBits < 48 && 0 == (15 & t22.windowBits) && (t22.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i2(), this.strm.avail_out = 0;
          var r22 = c.inflateInit2(this.strm, t22.windowBits);
          if (r22 !== m2.Z_OK) throw new Error(n[r22]);
          this.header = new s2(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e22, t22) {
          var r22 = new a(t22);
          if (r22.push(e22, true), r22.err) throw r22.msg || n[r22.err];
          return r22.result;
        }
        a.prototype.push = function(e22, t22) {
          var r22, n2, i22, s22, a2, o2, h2 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f3 = false;
          if (this.ended) return false;
          n2 = t22 === ~~t22 ? t22 : true === t22 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e22 ? h2.input = p.binstring2buf(e22) : "[object ArrayBuffer]" === _.call(e22) ? h2.input = new Uint8Array(e22) : h2.input = e22, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d.Buf8(u), h2.next_out = 0, h2.avail_out = u), (r22 = c.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r22 = c.inflateSetDictionary(this.strm, o2)), r22 === m2.Z_BUF_ERROR && true === f3 && (r22 = m2.Z_OK, f3 = false), r22 !== m2.Z_STREAM_END && r22 !== m2.Z_OK) return this.onEnd(r22), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r22 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n2 !== m2.Z_FINISH && n2 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i22 = p.utf8border(h2.output, h2.next_out), s22 = h2.next_out - i22, a2 = p.buf2string(h2.output, i22), h2.next_out = s22, h2.avail_out = u - s22, s22 && d.arraySet(h2.output, h2.output, i22, s22, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f3 = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r22 !== m2.Z_STREAM_END);
          return r22 === m2.Z_STREAM_END && (n2 = m2.Z_FINISH), n2 === m2.Z_FINISH ? (r22 = c.inflateEnd(this.strm), this.onEnd(r22), this.ended = true, r22 === m2.Z_OK) : n2 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
        }, a.prototype.onData = function(e22) {
          this.chunks.push(e22);
        }, a.prototype.onEnd = function(e22) {
          e22 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e22, this.msg = this.strm.msg;
        }, r2.Inflate = a, r2.inflate = o, r2.inflateRaw = function(e22, t22) {
          return (t22 = t22 || {}).raw = true, o(e22, t22);
        }, r2.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e22) {
          for (var t22 = Array.prototype.slice.call(arguments, 1); t22.length; ) {
            var r22 = t22.shift();
            if (r22) {
              if ("object" != typeof r22) throw new TypeError(r22 + "must be non-object");
              for (var n2 in r22) r22.hasOwnProperty(n2) && (e22[n2] = r22[n2]);
            }
          }
          return e22;
        }, r2.shrinkBuf = function(e22, t22) {
          return e22.length === t22 ? e22 : e22.subarray ? e22.subarray(0, t22) : (e22.length = t22, e22);
        };
        var i2 = { arraySet: function(e22, t22, r22, n2, i22) {
          if (t22.subarray && e22.subarray) e22.set(t22.subarray(r22, r22 + n2), i22);
          else for (var s22 = 0; s22 < n2; s22++) e22[i22 + s22] = t22[r22 + s22];
        }, flattenChunks: function(e22) {
          var t22, r22, n2, i22, s22, a;
          for (t22 = n2 = 0, r22 = e22.length; t22 < r22; t22++) n2 += e22[t22].length;
          for (a = new Uint8Array(n2), t22 = i22 = 0, r22 = e22.length; t22 < r22; t22++) s22 = e22[t22], a.set(s22, i22), i22 += s22.length;
          return a;
        } }, s2 = { arraySet: function(e22, t22, r22, n2, i22) {
          for (var s22 = 0; s22 < n2; s22++) e22[i22 + s22] = t22[r22 + s22];
        }, flattenChunks: function(e22) {
          return [].concat.apply([], e22);
        } };
        r2.setTyped = function(e22) {
          e22 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
        }, r2.setTyped(n);
      }, {}], 42: [function(e2, t2, r2) {
        var h2 = e2("./common"), i2 = true, s2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e22) {
          i2 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e22) {
          s2 = false;
        }
        for (var u = new h2.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e22, t22) {
          if (t22 < 65537 && (e22.subarray && s2 || !e22.subarray && i2)) return String.fromCharCode.apply(null, h2.shrinkBuf(e22, t22));
          for (var r22 = "", n2 = 0; n2 < t22; n2++) r22 += String.fromCharCode(e22[n2]);
          return r22;
        }
        u[254] = u[254] = 1, r2.string2buf = function(e22) {
          var t22, r22, n2, i22, s22, a = e22.length, o = 0;
          for (i22 = 0; i22 < a; i22++) 55296 == (64512 & (r22 = e22.charCodeAt(i22))) && i22 + 1 < a && 56320 == (64512 & (n2 = e22.charCodeAt(i22 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i22++), o += r22 < 128 ? 1 : r22 < 2048 ? 2 : r22 < 65536 ? 3 : 4;
          for (t22 = new h2.Buf8(o), i22 = s22 = 0; s22 < o; i22++) 55296 == (64512 & (r22 = e22.charCodeAt(i22))) && i22 + 1 < a && 56320 == (64512 & (n2 = e22.charCodeAt(i22 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i22++), r22 < 128 ? t22[s22++] = r22 : (r22 < 2048 ? t22[s22++] = 192 | r22 >>> 6 : (r22 < 65536 ? t22[s22++] = 224 | r22 >>> 12 : (t22[s22++] = 240 | r22 >>> 18, t22[s22++] = 128 | r22 >>> 12 & 63), t22[s22++] = 128 | r22 >>> 6 & 63), t22[s22++] = 128 | 63 & r22);
          return t22;
        }, r2.buf2binstring = function(e22) {
          return l(e22, e22.length);
        }, r2.binstring2buf = function(e22) {
          for (var t22 = new h2.Buf8(e22.length), r22 = 0, n2 = t22.length; r22 < n2; r22++) t22[r22] = e22.charCodeAt(r22);
          return t22;
        }, r2.buf2string = function(e22, t22) {
          var r22, n2, i22, s22, a = t22 || e22.length, o = new Array(2 * a);
          for (r22 = n2 = 0; r22 < a; ) if ((i22 = e22[r22++]) < 128) o[n2++] = i22;
          else if (4 < (s22 = u[i22])) o[n2++] = 65533, r22 += s22 - 1;
          else {
            for (i22 &= 2 === s22 ? 31 : 3 === s22 ? 15 : 7; 1 < s22 && r22 < a; ) i22 = i22 << 6 | 63 & e22[r22++], s22--;
            1 < s22 ? o[n2++] = 65533 : i22 < 65536 ? o[n2++] = i22 : (i22 -= 65536, o[n2++] = 55296 | i22 >> 10 & 1023, o[n2++] = 56320 | 1023 & i22);
          }
          return l(o, n2);
        }, r2.utf8border = function(e22, t22) {
          var r22;
          for ((t22 = t22 || e22.length) > e22.length && (t22 = e22.length), r22 = t22 - 1; 0 <= r22 && 128 == (192 & e22[r22]); ) r22--;
          return r22 < 0 ? t22 : 0 === r22 ? t22 : r22 + u[e22[r22]] > t22 ? r22 : t22;
        };
      }, { "./common": 41 }], 43: [function(e2, t2, r2) {
        t2.exports = function(e22, t22, r22, n) {
          for (var i2 = 65535 & e22 | 0, s2 = e22 >>> 16 & 65535 | 0, a = 0; 0 !== r22; ) {
            for (r22 -= a = 2e3 < r22 ? 2e3 : r22; s2 = s2 + (i2 = i2 + t22[n++] | 0) | 0, --a; ) ;
            i2 %= 65521, s2 %= 65521;
          }
          return i2 | s2 << 16 | 0;
        };
      }, {}], 44: [function(e2, t2, r2) {
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t2, r2) {
        var o = (function() {
          for (var e22, t22 = [], r22 = 0; r22 < 256; r22++) {
            e22 = r22;
            for (var n = 0; n < 8; n++) e22 = 1 & e22 ? 3988292384 ^ e22 >>> 1 : e22 >>> 1;
            t22[r22] = e22;
          }
          return t22;
        })();
        t2.exports = function(e22, t22, r22, n) {
          var i2 = o, s2 = n + r22;
          e22 ^= -1;
          for (var a = n; a < s2; a++) e22 = e22 >>> 8 ^ i2[255 & (e22 ^ t22[a])];
          return -1 ^ e22;
        };
      }, {}], 46: [function(e2, t2, r2) {
        var h2, c = e2("../utils/common"), u = e2("./trees"), d = e2("./adler32"), p = e2("./crc32"), n = e2("./messages"), l = 0, f3 = 4, m2 = 0, _ = -2, g = -1, b = 4, i2 = 2, v = 8, y = 9, s2 = 286, a = 30, o = 19, w = 2 * s2 + 1, k = 15, x2 = 3, S2 = 258, z = S2 + x2 + 1, C = 42, E = 113, A2 = 1, I = 2, O = 3, B = 4;
        function R(e22, t22) {
          return e22.msg = n[t22], t22;
        }
        function T(e22) {
          return (e22 << 1) - (4 < e22 ? 9 : 0);
        }
        function D(e22) {
          for (var t22 = e22.length; 0 <= --t22; ) e22[t22] = 0;
        }
        function F2(e22) {
          var t22 = e22.state, r22 = t22.pending;
          r22 > e22.avail_out && (r22 = e22.avail_out), 0 !== r22 && (c.arraySet(e22.output, t22.pending_buf, t22.pending_out, r22, e22.next_out), e22.next_out += r22, t22.pending_out += r22, e22.total_out += r22, e22.avail_out -= r22, t22.pending -= r22, 0 === t22.pending && (t22.pending_out = 0));
        }
        function N(e22, t22) {
          u._tr_flush_block(e22, 0 <= e22.block_start ? e22.block_start : -1, e22.strstart - e22.block_start, t22), e22.block_start = e22.strstart, F2(e22.strm);
        }
        function U(e22, t22) {
          e22.pending_buf[e22.pending++] = t22;
        }
        function P(e22, t22) {
          e22.pending_buf[e22.pending++] = t22 >>> 8 & 255, e22.pending_buf[e22.pending++] = 255 & t22;
        }
        function L(e22, t22) {
          var r22, n2, i22 = e22.max_chain_length, s22 = e22.strstart, a2 = e22.prev_length, o2 = e22.nice_match, h22 = e22.strstart > e22.w_size - z ? e22.strstart - (e22.w_size - z) : 0, u2 = e22.window, l2 = e22.w_mask, f22 = e22.prev, c2 = e22.strstart + S2, d2 = u2[s22 + a2 - 1], p2 = u2[s22 + a2];
          e22.prev_length >= e22.good_match && (i22 >>= 2), o2 > e22.lookahead && (o2 = e22.lookahead);
          do {
            if (u2[(r22 = t22) + a2] === p2 && u2[r22 + a2 - 1] === d2 && u2[r22] === u2[s22] && u2[++r22] === u2[s22 + 1]) {
              s22 += 2, r22++;
              do {
              } while (u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && u2[++s22] === u2[++r22] && s22 < c2);
              if (n2 = S2 - (c2 - s22), s22 = c2 - S2, a2 < n2) {
                if (e22.match_start = t22, o2 <= (a2 = n2)) break;
                d2 = u2[s22 + a2 - 1], p2 = u2[s22 + a2];
              }
            }
          } while ((t22 = f22[t22 & l2]) > h22 && 0 != --i22);
          return a2 <= e22.lookahead ? a2 : e22.lookahead;
        }
        function j(e22) {
          var t22, r22, n2, i22, s22, a2, o2, h22, u2, l2, f22 = e22.w_size;
          do {
            if (i22 = e22.window_size - e22.lookahead - e22.strstart, e22.strstart >= f22 + (f22 - z)) {
              for (c.arraySet(e22.window, e22.window, f22, f22, 0), e22.match_start -= f22, e22.strstart -= f22, e22.block_start -= f22, t22 = r22 = e22.hash_size; n2 = e22.head[--t22], e22.head[t22] = f22 <= n2 ? n2 - f22 : 0, --r22; ) ;
              for (t22 = r22 = f22; n2 = e22.prev[--t22], e22.prev[t22] = f22 <= n2 ? n2 - f22 : 0, --r22; ) ;
              i22 += f22;
            }
            if (0 === e22.strm.avail_in) break;
            if (a2 = e22.strm, o2 = e22.window, h22 = e22.strstart + e22.lookahead, u2 = i22, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r22 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h22), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h22) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h22)), a2.next_in += l2, a2.total_in += l2, l2), e22.lookahead += r22, e22.lookahead + e22.insert >= x2) for (s22 = e22.strstart - e22.insert, e22.ins_h = e22.window[s22], e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[s22 + 1]) & e22.hash_mask; e22.insert && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[s22 + x2 - 1]) & e22.hash_mask, e22.prev[s22 & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = s22, s22++, e22.insert--, !(e22.lookahead + e22.insert < x2)); ) ;
          } while (e22.lookahead < z && 0 !== e22.strm.avail_in);
        }
        function Z2(e22, t22) {
          for (var r22, n2; ; ) {
            if (e22.lookahead < z) {
              if (j(e22), e22.lookahead < z && t22 === l) return A2;
              if (0 === e22.lookahead) break;
            }
            if (r22 = 0, e22.lookahead >= x2 && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x2 - 1]) & e22.hash_mask, r22 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), 0 !== r22 && e22.strstart - r22 <= e22.w_size - z && (e22.match_length = L(e22, r22)), e22.match_length >= x2) if (n2 = u._tr_tally(e22, e22.strstart - e22.match_start, e22.match_length - x2), e22.lookahead -= e22.match_length, e22.match_length <= e22.max_lazy_match && e22.lookahead >= x2) {
              for (e22.match_length--; e22.strstart++, e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x2 - 1]) & e22.hash_mask, r22 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart, 0 != --e22.match_length; ) ;
              e22.strstart++;
            } else e22.strstart += e22.match_length, e22.match_length = 0, e22.ins_h = e22.window[e22.strstart], e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + 1]) & e22.hash_mask;
            else n2 = u._tr_tally(e22, 0, e22.window[e22.strstart]), e22.lookahead--, e22.strstart++;
            if (n2 && (N(e22, false), 0 === e22.strm.avail_out)) return A2;
          }
          return e22.insert = e22.strstart < x2 - 1 ? e22.strstart : x2 - 1, t22 === f3 ? (N(e22, true), 0 === e22.strm.avail_out ? O : B) : e22.last_lit && (N(e22, false), 0 === e22.strm.avail_out) ? A2 : I;
        }
        function W(e22, t22) {
          for (var r22, n2, i22; ; ) {
            if (e22.lookahead < z) {
              if (j(e22), e22.lookahead < z && t22 === l) return A2;
              if (0 === e22.lookahead) break;
            }
            if (r22 = 0, e22.lookahead >= x2 && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x2 - 1]) & e22.hash_mask, r22 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), e22.prev_length = e22.match_length, e22.prev_match = e22.match_start, e22.match_length = x2 - 1, 0 !== r22 && e22.prev_length < e22.max_lazy_match && e22.strstart - r22 <= e22.w_size - z && (e22.match_length = L(e22, r22), e22.match_length <= 5 && (1 === e22.strategy || e22.match_length === x2 && 4096 < e22.strstart - e22.match_start) && (e22.match_length = x2 - 1)), e22.prev_length >= x2 && e22.match_length <= e22.prev_length) {
              for (i22 = e22.strstart + e22.lookahead - x2, n2 = u._tr_tally(e22, e22.strstart - 1 - e22.prev_match, e22.prev_length - x2), e22.lookahead -= e22.prev_length - 1, e22.prev_length -= 2; ++e22.strstart <= i22 && (e22.ins_h = (e22.ins_h << e22.hash_shift ^ e22.window[e22.strstart + x2 - 1]) & e22.hash_mask, r22 = e22.prev[e22.strstart & e22.w_mask] = e22.head[e22.ins_h], e22.head[e22.ins_h] = e22.strstart), 0 != --e22.prev_length; ) ;
              if (e22.match_available = 0, e22.match_length = x2 - 1, e22.strstart++, n2 && (N(e22, false), 0 === e22.strm.avail_out)) return A2;
            } else if (e22.match_available) {
              if ((n2 = u._tr_tally(e22, 0, e22.window[e22.strstart - 1])) && N(e22, false), e22.strstart++, e22.lookahead--, 0 === e22.strm.avail_out) return A2;
            } else e22.match_available = 1, e22.strstart++, e22.lookahead--;
          }
          return e22.match_available && (n2 = u._tr_tally(e22, 0, e22.window[e22.strstart - 1]), e22.match_available = 0), e22.insert = e22.strstart < x2 - 1 ? e22.strstart : x2 - 1, t22 === f3 ? (N(e22, true), 0 === e22.strm.avail_out ? O : B) : e22.last_lit && (N(e22, false), 0 === e22.strm.avail_out) ? A2 : I;
        }
        function M(e22, t22, r22, n2, i22) {
          this.good_length = e22, this.max_lazy = t22, this.nice_length = r22, this.max_chain = n2, this.func = i22;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s2 + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s2 + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e22) {
          var t22;
          return e22 && e22.state ? (e22.total_in = e22.total_out = 0, e22.data_type = i2, (t22 = e22.state).pending = 0, t22.pending_out = 0, t22.wrap < 0 && (t22.wrap = -t22.wrap), t22.status = t22.wrap ? C : E, e22.adler = 2 === t22.wrap ? 0 : 1, t22.last_flush = l, u._tr_init(t22), m2) : R(e22, _);
        }
        function K(e22) {
          var t22 = G(e22);
          return t22 === m2 && (function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h2[e3.level].max_lazy, e3.good_match = h2[e3.level].good_length, e3.nice_match = h2[e3.level].nice_length, e3.max_chain_length = h2[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x2 - 1, e3.match_available = 0, e3.ins_h = 0;
          })(e22.state), t22;
        }
        function Y(e22, t22, r22, n2, i22, s22) {
          if (!e22) return _;
          var a2 = 1;
          if (t22 === g && (t22 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i22 < 1 || y < i22 || r22 !== v || n2 < 8 || 15 < n2 || t22 < 0 || 9 < t22 || s22 < 0 || b < s22) return R(e22, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e22.state = o2).strm = e22, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i22 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x2 - 1) / x2), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i22 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t22, o2.strategy = s22, o2.method = r22, K(e22);
        }
        h2 = [new M(0, 0, 0, 0, function(e22, t22) {
          var r22 = 65535;
          for (r22 > e22.pending_buf_size - 5 && (r22 = e22.pending_buf_size - 5); ; ) {
            if (e22.lookahead <= 1) {
              if (j(e22), 0 === e22.lookahead && t22 === l) return A2;
              if (0 === e22.lookahead) break;
            }
            e22.strstart += e22.lookahead, e22.lookahead = 0;
            var n2 = e22.block_start + r22;
            if ((0 === e22.strstart || e22.strstart >= n2) && (e22.lookahead = e22.strstart - n2, e22.strstart = n2, N(e22, false), 0 === e22.strm.avail_out)) return A2;
            if (e22.strstart - e22.block_start >= e22.w_size - z && (N(e22, false), 0 === e22.strm.avail_out)) return A2;
          }
          return e22.insert = 0, t22 === f3 ? (N(e22, true), 0 === e22.strm.avail_out ? O : B) : (e22.strstart > e22.block_start && (N(e22, false), e22.strm.avail_out), A2);
        }), new M(4, 4, 8, 4, Z2), new M(4, 5, 16, 8, Z2), new M(4, 6, 32, 32, Z2), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r2.deflateInit = function(e22, t22) {
          return Y(e22, t22, v, 15, 8, 0);
        }, r2.deflateInit2 = Y, r2.deflateReset = K, r2.deflateResetKeep = G, r2.deflateSetHeader = function(e22, t22) {
          return e22 && e22.state ? 2 !== e22.state.wrap ? _ : (e22.state.gzhead = t22, m2) : _;
        }, r2.deflate = function(e22, t22) {
          var r22, n2, i22, s22;
          if (!e22 || !e22.state || 5 < t22 || t22 < 0) return e22 ? R(e22, _) : _;
          if (n2 = e22.state, !e22.output || !e22.input && 0 !== e22.avail_in || 666 === n2.status && t22 !== f3) return R(e22, 0 === e22.avail_out ? -5 : _);
          if (n2.strm = e22, r22 = n2.last_flush, n2.last_flush = t22, n2.status === C) if (2 === n2.wrap) e22.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e22.adler >>> 16), P(n2, 65535 & e22.adler)), e22.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i22 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), F2(e22), i22 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i22 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), F2(e22), i22 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s22 = 1;
                break;
              }
              s22 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s22);
            } while (0 !== s22);
            n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), 0 === s22 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i22 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), F2(e22), i22 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s22 = 1;
                break;
              }
              s22 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s22);
            } while (0 !== s22);
            n2.gzhead.hcrc && n2.pending > i22 && (e22.adler = p(e22.adler, n2.pending_buf, n2.pending - i22, i22)), 0 === s22 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F2(e22), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e22.adler), U(n2, e22.adler >> 8 & 255), e22.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F2(e22), 0 === e22.avail_out) return n2.last_flush = -1, m2;
          } else if (0 === e22.avail_in && T(t22) <= T(r22) && t22 !== f3) return R(e22, -5);
          if (666 === n2.status && 0 !== e22.avail_in) return R(e22, -5);
          if (0 !== e22.avail_in || 0 !== n2.lookahead || t22 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? (function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l) return A2;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A2;
              }
              return e3.insert = 0, t3 === f3 ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
            })(n2, t22) : 3 === n2.strategy ? (function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S2) {
                  if (j(e3), e3.lookahead <= S2 && t3 === l) return A2;
                  if (0 === e3.lookahead) break;
                }
                if (e3.match_length = 0, e3.lookahead >= x2 && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S2;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S2 - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x2 ? (r3 = u._tr_tally(e3, 1, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A2;
              }
              return e3.insert = 0, t3 === f3 ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
            })(n2, t22) : h2[n2.level].func(n2, t22);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A2 || o2 === O) return 0 === e22.avail_out && (n2.last_flush = -1), m2;
            if (o2 === I && (1 === t22 ? u._tr_align(n2) : 5 !== t22 && (u._tr_stored_block(n2, 0, 0, false), 3 === t22 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F2(e22), 0 === e22.avail_out)) return n2.last_flush = -1, m2;
          }
          return t22 !== f3 ? m2 : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e22.adler), U(n2, e22.adler >> 8 & 255), U(n2, e22.adler >> 16 & 255), U(n2, e22.adler >> 24 & 255), U(n2, 255 & e22.total_in), U(n2, e22.total_in >> 8 & 255), U(n2, e22.total_in >> 16 & 255), U(n2, e22.total_in >> 24 & 255)) : (P(n2, e22.adler >>> 16), P(n2, 65535 & e22.adler)), F2(e22), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m2 : 1);
        }, r2.deflateEnd = function(e22) {
          var t22;
          return e22 && e22.state ? (t22 = e22.state.status) !== C && 69 !== t22 && 73 !== t22 && 91 !== t22 && 103 !== t22 && t22 !== E && 666 !== t22 ? R(e22, _) : (e22.state = null, t22 === E ? R(e22, -3) : m2) : _;
        }, r2.deflateSetDictionary = function(e22, t22) {
          var r22, n2, i22, s22, a2, o2, h22, u2, l2 = t22.length;
          if (!e22 || !e22.state) return _;
          if (2 === (s22 = (r22 = e22.state).wrap) || 1 === s22 && r22.status !== C || r22.lookahead) return _;
          for (1 === s22 && (e22.adler = d(e22.adler, t22, l2, 0)), r22.wrap = 0, l2 >= r22.w_size && (0 === s22 && (D(r22.head), r22.strstart = 0, r22.block_start = 0, r22.insert = 0), u2 = new c.Buf8(r22.w_size), c.arraySet(u2, t22, l2 - r22.w_size, r22.w_size, 0), t22 = u2, l2 = r22.w_size), a2 = e22.avail_in, o2 = e22.next_in, h22 = e22.input, e22.avail_in = l2, e22.next_in = 0, e22.input = t22, j(r22); r22.lookahead >= x2; ) {
            for (n2 = r22.strstart, i22 = r22.lookahead - (x2 - 1); r22.ins_h = (r22.ins_h << r22.hash_shift ^ r22.window[n2 + x2 - 1]) & r22.hash_mask, r22.prev[n2 & r22.w_mask] = r22.head[r22.ins_h], r22.head[r22.ins_h] = n2, n2++, --i22; ) ;
            r22.strstart = n2, r22.lookahead = x2 - 1, j(r22);
          }
          return r22.strstart += r22.lookahead, r22.block_start = r22.strstart, r22.insert = r22.lookahead, r22.lookahead = 0, r22.match_length = r22.prev_length = x2 - 1, r22.match_available = 0, e22.next_in = o2, e22.input = h22, e22.avail_in = a2, r22.wrap = s22, m2;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t2, r2) {
        t2.exports = function(e22, t22) {
          var r22, n, i2, s2, a, o, h2, u, l, f3, c, d, p, m2, _, g, b, v, y, w, k, x2, S2, z, C;
          r22 = e22.state, n = e22.next_in, z = e22.input, i2 = n + (e22.avail_in - 5), s2 = e22.next_out, C = e22.output, a = s2 - (t22 - e22.avail_out), o = s2 + (e22.avail_out - 257), h2 = r22.dmax, u = r22.wsize, l = r22.whave, f3 = r22.wnext, c = r22.window, d = r22.hold, p = r22.bits, m2 = r22.lencode, _ = r22.distcode, g = (1 << r22.lenbits) - 1, b = (1 << r22.distbits) - 1;
          e: do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m2[d & g];
            t: for (; ; ) {
              if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s2++] = 65535 & v;
              else {
                if (!(16 & y)) {
                  if (0 == (64 & y)) {
                    v = m2[(65535 & v) + (d & (1 << y) - 1)];
                    continue t;
                  }
                  if (32 & y) {
                    r22.mode = 12;
                    break e;
                  }
                  e22.msg = "invalid literal/length code", r22.mode = 30;
                  break e;
                }
                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                r: for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                    if (0 == (64 & y)) {
                      v = _[(65535 & v) + (d & (1 << y) - 1)];
                      continue r;
                    }
                    e22.msg = "invalid distance code", r22.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h2 < (k += d & (1 << y) - 1)) {
                    e22.msg = "invalid distance too far back", r22.mode = 30;
                    break e;
                  }
                  if (d >>>= y, p -= y, (y = s2 - a) < k) {
                    if (l < (y = k - y) && r22.sane) {
                      e22.msg = "invalid distance too far back", r22.mode = 30;
                      break e;
                    }
                    if (S2 = c, (x2 = 0) === f3) {
                      if (x2 += u - y, y < w) {
                        for (w -= y; C[s2++] = c[x2++], --y; ) ;
                        x2 = s2 - k, S2 = C;
                      }
                    } else if (f3 < y) {
                      if (x2 += u + f3 - y, (y -= f3) < w) {
                        for (w -= y; C[s2++] = c[x2++], --y; ) ;
                        if (x2 = 0, f3 < w) {
                          for (w -= y = f3; C[s2++] = c[x2++], --y; ) ;
                          x2 = s2 - k, S2 = C;
                        }
                      }
                    } else if (x2 += f3 - y, y < w) {
                      for (w -= y; C[s2++] = c[x2++], --y; ) ;
                      x2 = s2 - k, S2 = C;
                    }
                    for (; 2 < w; ) C[s2++] = S2[x2++], C[s2++] = S2[x2++], C[s2++] = S2[x2++], w -= 3;
                    w && (C[s2++] = S2[x2++], 1 < w && (C[s2++] = S2[x2++]));
                  } else {
                    for (x2 = s2 - k; C[s2++] = C[x2++], C[s2++] = C[x2++], C[s2++] = C[x2++], 2 < (w -= 3); ) ;
                    w && (C[s2++] = C[x2++], 1 < w && (C[s2++] = C[x2++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i2 && s2 < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e22.next_in = n, e22.next_out = s2, e22.avail_in = n < i2 ? i2 - n + 5 : 5 - (n - i2), e22.avail_out = s2 < o ? o - s2 + 257 : 257 - (s2 - o), r22.hold = d, r22.bits = p;
        };
      }, {}], 49: [function(e2, t2, r2) {
        var I = e2("../utils/common"), O = e2("./adler32"), B = e2("./crc32"), R = e2("./inffast"), T = e2("./inftrees"), D = 1, F2 = 2, N = 0, U = -2, P = 1, n = 852, i2 = 592;
        function L(e22) {
          return (e22 >>> 24 & 255) + (e22 >>> 8 & 65280) + ((65280 & e22) << 8) + ((255 & e22) << 24);
        }
        function s2() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e22) {
          var t22;
          return e22 && e22.state ? (t22 = e22.state, e22.total_in = e22.total_out = t22.total = 0, e22.msg = "", t22.wrap && (e22.adler = 1 & t22.wrap), t22.mode = P, t22.last = 0, t22.havedict = 0, t22.dmax = 32768, t22.head = null, t22.hold = 0, t22.bits = 0, t22.lencode = t22.lendyn = new I.Buf32(n), t22.distcode = t22.distdyn = new I.Buf32(i2), t22.sane = 1, t22.back = -1, N) : U;
        }
        function o(e22) {
          var t22;
          return e22 && e22.state ? ((t22 = e22.state).wsize = 0, t22.whave = 0, t22.wnext = 0, a(e22)) : U;
        }
        function h2(e22, t22) {
          var r22, n2;
          return e22 && e22.state ? (n2 = e22.state, t22 < 0 ? (r22 = 0, t22 = -t22) : (r22 = 1 + (t22 >> 4), t22 < 48 && (t22 &= 15)), t22 && (t22 < 8 || 15 < t22) ? U : (null !== n2.window && n2.wbits !== t22 && (n2.window = null), n2.wrap = r22, n2.wbits = t22, o(e22))) : U;
        }
        function u(e22, t22) {
          var r22, n2;
          return e22 ? (n2 = new s2(), (e22.state = n2).window = null, (r22 = h2(e22, t22)) !== N && (e22.state = null), r22) : U;
        }
        var l, f3, c = true;
        function j(e22) {
          if (c) {
            var t22;
            for (l = new I.Buf32(512), f3 = new I.Buf32(32), t22 = 0; t22 < 144; ) e22.lens[t22++] = 8;
            for (; t22 < 256; ) e22.lens[t22++] = 9;
            for (; t22 < 280; ) e22.lens[t22++] = 7;
            for (; t22 < 288; ) e22.lens[t22++] = 8;
            for (T(D, e22.lens, 0, 288, l, 0, e22.work, { bits: 9 }), t22 = 0; t22 < 32; ) e22.lens[t22++] = 5;
            T(F2, e22.lens, 0, 32, f3, 0, e22.work, { bits: 5 }), c = false;
          }
          e22.lencode = l, e22.lenbits = 9, e22.distcode = f3, e22.distbits = 5;
        }
        function Z2(e22, t22, r22, n2) {
          var i22, s22 = e22.state;
          return null === s22.window && (s22.wsize = 1 << s22.wbits, s22.wnext = 0, s22.whave = 0, s22.window = new I.Buf8(s22.wsize)), n2 >= s22.wsize ? (I.arraySet(s22.window, t22, r22 - s22.wsize, s22.wsize, 0), s22.wnext = 0, s22.whave = s22.wsize) : (n2 < (i22 = s22.wsize - s22.wnext) && (i22 = n2), I.arraySet(s22.window, t22, r22 - n2, i22, s22.wnext), (n2 -= i22) ? (I.arraySet(s22.window, t22, r22 - n2, n2, 0), s22.wnext = n2, s22.whave = s22.wsize) : (s22.wnext += i22, s22.wnext === s22.wsize && (s22.wnext = 0), s22.whave < s22.wsize && (s22.whave += i22))), 0;
        }
        r2.inflateReset = o, r2.inflateReset2 = h2, r2.inflateResetKeep = a, r2.inflateInit = function(e22) {
          return u(e22, 15);
        }, r2.inflateInit2 = u, r2.inflate = function(e22, t22) {
          var r22, n2, i22, s22, a2, o2, h22, u2, l2, f22, c2, d, p, m2, _, g, b, v, y, w, k, x2, S2, z, C = 0, E = new I.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e22 || !e22.state || !e22.output || !e22.input && 0 !== e22.avail_in) return U;
          12 === (r22 = e22.state).mode && (r22.mode = 13), a2 = e22.next_out, i22 = e22.output, h22 = e22.avail_out, s22 = e22.next_in, n2 = e22.input, o2 = e22.avail_in, u2 = r22.hold, l2 = r22.bits, f22 = o2, c2 = h22, x2 = N;
          e: for (; ; ) switch (r22.mode) {
            case P:
              if (0 === r22.wrap) {
                r22.mode = 13;
                break;
              }
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if (2 & r22.wrap && 35615 === u2) {
                E[r22.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r22.check = B(r22.check, E, 2, 0), l2 = u2 = 0, r22.mode = 2;
                break;
              }
              if (r22.flags = 0, r22.head && (r22.head.done = false), !(1 & r22.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e22.msg = "incorrect header check", r22.mode = 30;
                break;
              }
              if (8 != (15 & u2)) {
                e22.msg = "unknown compression method", r22.mode = 30;
                break;
              }
              if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r22.wbits) r22.wbits = k;
              else if (k > r22.wbits) {
                e22.msg = "invalid window size", r22.mode = 30;
                break;
              }
              r22.dmax = 1 << k, e22.adler = r22.check = 1, r22.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
              break;
            case 2:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if (r22.flags = u2, 8 != (255 & r22.flags)) {
                e22.msg = "unknown compression method", r22.mode = 30;
                break;
              }
              if (57344 & r22.flags) {
                e22.msg = "unknown header flags set", r22.mode = 30;
                break;
              }
              r22.head && (r22.head.text = u2 >> 8 & 1), 512 & r22.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r22.check = B(r22.check, E, 2, 0)), l2 = u2 = 0, r22.mode = 3;
            case 3:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              r22.head && (r22.head.time = u2), 512 & r22.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r22.check = B(r22.check, E, 4, 0)), l2 = u2 = 0, r22.mode = 4;
            case 4:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              r22.head && (r22.head.xflags = 255 & u2, r22.head.os = u2 >> 8), 512 & r22.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r22.check = B(r22.check, E, 2, 0)), l2 = u2 = 0, r22.mode = 5;
            case 5:
              if (1024 & r22.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                r22.length = u2, r22.head && (r22.head.extra_len = u2), 512 & r22.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r22.check = B(r22.check, E, 2, 0)), l2 = u2 = 0;
              } else r22.head && (r22.head.extra = null);
              r22.mode = 6;
            case 6:
              if (1024 & r22.flags && (o2 < (d = r22.length) && (d = o2), d && (r22.head && (k = r22.head.extra_len - r22.length, r22.head.extra || (r22.head.extra = new Array(r22.head.extra_len)), I.arraySet(r22.head.extra, n2, s22, d, k)), 512 & r22.flags && (r22.check = B(r22.check, n2, d, s22)), o2 -= d, s22 += d, r22.length -= d), r22.length)) break e;
              r22.length = 0, r22.mode = 7;
            case 7:
              if (2048 & r22.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s22 + d++], r22.head && k && r22.length < 65536 && (r22.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r22.flags && (r22.check = B(r22.check, n2, d, s22)), o2 -= d, s22 += d, k) break e;
              } else r22.head && (r22.head.name = null);
              r22.length = 0, r22.mode = 8;
            case 8:
              if (4096 & r22.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s22 + d++], r22.head && k && r22.length < 65536 && (r22.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r22.flags && (r22.check = B(r22.check, n2, d, s22)), o2 -= d, s22 += d, k) break e;
              } else r22.head && (r22.head.comment = null);
              r22.mode = 9;
            case 9:
              if (512 & r22.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                if (u2 !== (65535 & r22.check)) {
                  e22.msg = "header crc mismatch", r22.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r22.head && (r22.head.hcrc = r22.flags >> 9 & 1, r22.head.done = true), e22.adler = r22.check = 0, r22.mode = 12;
              break;
            case 10:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              e22.adler = r22.check = L(u2), l2 = u2 = 0, r22.mode = 11;
            case 11:
              if (0 === r22.havedict) return e22.next_out = a2, e22.avail_out = h22, e22.next_in = s22, e22.avail_in = o2, r22.hold = u2, r22.bits = l2, 2;
              e22.adler = r22.check = 1, r22.mode = 12;
            case 12:
              if (5 === t22 || 6 === t22) break e;
            case 13:
              if (r22.last) {
                u2 >>>= 7 & l2, l2 -= 7 & l2, r22.mode = 27;
                break;
              }
              for (; l2 < 3; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              switch (r22.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                case 0:
                  r22.mode = 14;
                  break;
                case 1:
                  if (j(r22), r22.mode = 20, 6 !== t22) break;
                  u2 >>>= 2, l2 -= 2;
                  break e;
                case 2:
                  r22.mode = 17;
                  break;
                case 3:
                  e22.msg = "invalid block type", r22.mode = 30;
              }
              u2 >>>= 2, l2 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e22.msg = "invalid stored block lengths", r22.mode = 30;
                break;
              }
              if (r22.length = 65535 & u2, l2 = u2 = 0, r22.mode = 15, 6 === t22) break e;
            case 15:
              r22.mode = 16;
            case 16:
              if (d = r22.length) {
                if (o2 < d && (d = o2), h22 < d && (d = h22), 0 === d) break e;
                I.arraySet(i22, n2, s22, d, a2), o2 -= d, s22 += d, h22 -= d, a2 += d, r22.length -= d;
                break;
              }
              r22.mode = 12;
              break;
            case 17:
              for (; l2 < 14; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if (r22.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r22.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r22.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r22.nlen || 30 < r22.ndist) {
                e22.msg = "too many length or distance symbols", r22.mode = 30;
                break;
              }
              r22.have = 0, r22.mode = 18;
            case 18:
              for (; r22.have < r22.ncode; ) {
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                r22.lens[A2[r22.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
              }
              for (; r22.have < 19; ) r22.lens[A2[r22.have++]] = 0;
              if (r22.lencode = r22.lendyn, r22.lenbits = 7, S2 = { bits: r22.lenbits }, x2 = T(0, r22.lens, 0, 19, r22.lencode, 0, r22.work, S2), r22.lenbits = S2.bits, x2) {
                e22.msg = "invalid code lengths set", r22.mode = 30;
                break;
              }
              r22.have = 0, r22.mode = 19;
            case 19:
              for (; r22.have < r22.nlen + r22.ndist; ) {
                for (; g = (C = r22.lencode[u2 & (1 << r22.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                if (b < 16) u2 >>>= _, l2 -= _, r22.lens[r22.have++] = b;
                else {
                  if (16 === b) {
                    for (z = _ + 2; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s22++] << l2, l2 += 8;
                    }
                    if (u2 >>>= _, l2 -= _, 0 === r22.have) {
                      e22.msg = "invalid bit length repeat", r22.mode = 30;
                      break;
                    }
                    k = r22.lens[r22.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                  } else if (17 === b) {
                    for (z = _ + 3; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s22++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                  } else {
                    for (z = _ + 7; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s22++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                  }
                  if (r22.have + d > r22.nlen + r22.ndist) {
                    e22.msg = "invalid bit length repeat", r22.mode = 30;
                    break;
                  }
                  for (; d--; ) r22.lens[r22.have++] = k;
                }
              }
              if (30 === r22.mode) break;
              if (0 === r22.lens[256]) {
                e22.msg = "invalid code -- missing end-of-block", r22.mode = 30;
                break;
              }
              if (r22.lenbits = 9, S2 = { bits: r22.lenbits }, x2 = T(D, r22.lens, 0, r22.nlen, r22.lencode, 0, r22.work, S2), r22.lenbits = S2.bits, x2) {
                e22.msg = "invalid literal/lengths set", r22.mode = 30;
                break;
              }
              if (r22.distbits = 6, r22.distcode = r22.distdyn, S2 = { bits: r22.distbits }, x2 = T(F2, r22.lens, r22.nlen, r22.ndist, r22.distcode, 0, r22.work, S2), r22.distbits = S2.bits, x2) {
                e22.msg = "invalid distances set", r22.mode = 30;
                break;
              }
              if (r22.mode = 20, 6 === t22) break e;
            case 20:
              r22.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h22) {
                e22.next_out = a2, e22.avail_out = h22, e22.next_in = s22, e22.avail_in = o2, r22.hold = u2, r22.bits = l2, R(e22, c2), a2 = e22.next_out, i22 = e22.output, h22 = e22.avail_out, s22 = e22.next_in, n2 = e22.input, o2 = e22.avail_in, u2 = r22.hold, l2 = r22.bits, 12 === r22.mode && (r22.back = -1);
                break;
              }
              for (r22.back = 0; g = (C = r22.lencode[u2 & (1 << r22.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r22.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r22.back += v;
              }
              if (u2 >>>= _, l2 -= _, r22.back += _, r22.length = b, 0 === g) {
                r22.mode = 26;
                break;
              }
              if (32 & g) {
                r22.back = -1, r22.mode = 12;
                break;
              }
              if (64 & g) {
                e22.msg = "invalid literal/length code", r22.mode = 30;
                break;
              }
              r22.extra = 15 & g, r22.mode = 22;
            case 22:
              if (r22.extra) {
                for (z = r22.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                r22.length += u2 & (1 << r22.extra) - 1, u2 >>>= r22.extra, l2 -= r22.extra, r22.back += r22.extra;
              }
              r22.was = r22.length, r22.mode = 23;
            case 23:
              for (; g = (C = r22.distcode[u2 & (1 << r22.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s22++] << l2, l2 += 8;
              }
              if (0 == (240 & g)) {
                for (v = _, y = g, w = b; g = (C = r22.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r22.back += v;
              }
              if (u2 >>>= _, l2 -= _, r22.back += _, 64 & g) {
                e22.msg = "invalid distance code", r22.mode = 30;
                break;
              }
              r22.offset = b, r22.extra = 15 & g, r22.mode = 24;
            case 24:
              if (r22.extra) {
                for (z = r22.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                r22.offset += u2 & (1 << r22.extra) - 1, u2 >>>= r22.extra, l2 -= r22.extra, r22.back += r22.extra;
              }
              if (r22.offset > r22.dmax) {
                e22.msg = "invalid distance too far back", r22.mode = 30;
                break;
              }
              r22.mode = 25;
            case 25:
              if (0 === h22) break e;
              if (d = c2 - h22, r22.offset > d) {
                if ((d = r22.offset - d) > r22.whave && r22.sane) {
                  e22.msg = "invalid distance too far back", r22.mode = 30;
                  break;
                }
                p = d > r22.wnext ? (d -= r22.wnext, r22.wsize - d) : r22.wnext - d, d > r22.length && (d = r22.length), m2 = r22.window;
              } else m2 = i22, p = a2 - r22.offset, d = r22.length;
              for (h22 < d && (d = h22), h22 -= d, r22.length -= d; i22[a2++] = m2[p++], --d; ) ;
              0 === r22.length && (r22.mode = 21);
              break;
            case 26:
              if (0 === h22) break e;
              i22[a2++] = r22.length, h22--, r22.mode = 21;
              break;
            case 27:
              if (r22.wrap) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 |= n2[s22++] << l2, l2 += 8;
                }
                if (c2 -= h22, e22.total_out += c2, r22.total += c2, c2 && (e22.adler = r22.check = r22.flags ? B(r22.check, i22, c2, a2 - c2) : O(r22.check, i22, c2, a2 - c2)), c2 = h22, (r22.flags ? u2 : L(u2)) !== r22.check) {
                  e22.msg = "incorrect data check", r22.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r22.mode = 28;
            case 28:
              if (r22.wrap && r22.flags) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s22++] << l2, l2 += 8;
                }
                if (u2 !== (4294967295 & r22.total)) {
                  e22.msg = "incorrect length check", r22.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r22.mode = 29;
            case 29:
              x2 = 1;
              break e;
            case 30:
              x2 = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U;
          }
          return e22.next_out = a2, e22.avail_out = h22, e22.next_in = s22, e22.avail_in = o2, r22.hold = u2, r22.bits = l2, (r22.wsize || c2 !== e22.avail_out && r22.mode < 30 && (r22.mode < 27 || 4 !== t22)) && Z2(e22, e22.output, e22.next_out, c2 - e22.avail_out) ? (r22.mode = 31, -4) : (f22 -= e22.avail_in, c2 -= e22.avail_out, e22.total_in += f22, e22.total_out += c2, r22.total += c2, r22.wrap && c2 && (e22.adler = r22.check = r22.flags ? B(r22.check, i22, c2, e22.next_out - c2) : O(r22.check, i22, c2, e22.next_out - c2)), e22.data_type = r22.bits + (r22.last ? 64 : 0) + (12 === r22.mode ? 128 : 0) + (20 === r22.mode || 15 === r22.mode ? 256 : 0), (0 == f22 && 0 === c2 || 4 === t22) && x2 === N && (x2 = -5), x2);
        }, r2.inflateEnd = function(e22) {
          if (!e22 || !e22.state) return U;
          var t22 = e22.state;
          return t22.window && (t22.window = null), e22.state = null, N;
        }, r2.inflateGetHeader = function(e22, t22) {
          var r22;
          return e22 && e22.state ? 0 == (2 & (r22 = e22.state).wrap) ? U : ((r22.head = t22).done = false, N) : U;
        }, r2.inflateSetDictionary = function(e22, t22) {
          var r22, n2 = t22.length;
          return e22 && e22.state ? 0 !== (r22 = e22.state).wrap && 11 !== r22.mode ? U : 11 === r22.mode && O(1, t22, n2, 0) !== r22.check ? -3 : Z2(e22, t22, n2, n2) ? (r22.mode = 31, -4) : (r22.havedict = 1, N) : U;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
        var D = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e22, t22, r22, n, i2, s2, a, o) {
          var h2, u, l, f3, c, d, p, m2, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x2 = 0, S2 = 0, z = 0, C = 0, E = 0, A2 = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++) O[b] = 0;
          for (v = 0; v < n; v++) O[t22[r22 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
          if (w < k && (k = w), 0 === w) return i2[s2++] = 20971520, i2[s2++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++) ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
          if (0 < z && (0 === e22 || 1 !== w)) return -1;
          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++) 0 !== t22[r22 + v] && (a[B[t22[r22 + v]]++] = v);
          if (d = 0 === e22 ? (A2 = R = a, 19) : 1 === e22 ? (A2 = F2, I -= 257, R = N, T -= 257, 256) : (A2 = U, R = P, -1), b = y, c = s2, S2 = v = E = 0, l = -1, f3 = (C = 1 << (x2 = k)) - 1, 1 === e22 && 852 < C || 2 === e22 && 592 < C) return 1;
          for (; ; ) {
            for (p = b - S2, _ = a[v] < d ? (m2 = 0, a[v]) : a[v] > d ? (m2 = R[T + a[v]], A2[I + a[v]]) : (m2 = 96, 0), h2 = 1 << b - S2, y = u = 1 << x2; i2[c + (E >> S2) + (u -= h2)] = p << 24 | m2 << 16 | _ | 0, 0 !== u; ) ;
            for (h2 = 1 << b - 1; E & h2; ) h2 >>= 1;
            if (0 !== h2 ? (E &= h2 - 1, E += h2) : E = 0, v++, 0 == --O[b]) {
              if (b === w) break;
              b = t22[r22 + a[v]];
            }
            if (k < b && (E & f3) !== l) {
              for (0 === S2 && (S2 = k), c += y, z = 1 << (x2 = b - S2); x2 + S2 < w && !((z -= O[x2 + S2]) <= 0); ) x2++, z <<= 1;
              if (C += 1 << x2, 1 === e22 && 852 < C || 2 === e22 && 592 < C) return 1;
              i2[l = E & f3] = k << 24 | x2 << 16 | c - s2 | 0;
            }
          }
          return 0 !== E && (i2[c + E] = b - S2 << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t2, r2) {
        var i2 = e2("../utils/common"), o = 0, h2 = 1;
        function n(e22) {
          for (var t22 = e22.length; 0 <= --t22; ) e22[t22] = 0;
        }
        var s2 = 0, a = 29, u = 256, l = u + 1 + a, f3 = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m2 = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f3);
        n(C);
        var E = new Array(512);
        n(E);
        var A2 = new Array(256);
        n(A2);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f3);
        function D(e22, t22, r22, n2, i22) {
          this.static_tree = e22, this.extra_bits = t22, this.extra_base = r22, this.elems = n2, this.max_length = i22, this.has_stree = e22 && e22.length;
        }
        function F2(e22, t22) {
          this.dyn_tree = e22, this.max_code = 0, this.stat_desc = t22;
        }
        function N(e22) {
          return e22 < 256 ? E[e22] : E[256 + (e22 >>> 7)];
        }
        function U(e22, t22) {
          e22.pending_buf[e22.pending++] = 255 & t22, e22.pending_buf[e22.pending++] = t22 >>> 8 & 255;
        }
        function P(e22, t22, r22) {
          e22.bi_valid > d - r22 ? (e22.bi_buf |= t22 << e22.bi_valid & 65535, U(e22, e22.bi_buf), e22.bi_buf = t22 >> d - e22.bi_valid, e22.bi_valid += r22 - d) : (e22.bi_buf |= t22 << e22.bi_valid & 65535, e22.bi_valid += r22);
        }
        function L(e22, t22, r22) {
          P(e22, r22[2 * t22], r22[2 * t22 + 1]);
        }
        function j(e22, t22) {
          for (var r22 = 0; r22 |= 1 & e22, e22 >>>= 1, r22 <<= 1, 0 < --t22; ) ;
          return r22 >>> 1;
        }
        function Z2(e22, t22, r22) {
          var n2, i22, s22 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++) s22[n2] = a2 = a2 + r22[n2 - 1] << 1;
          for (i22 = 0; i22 <= t22; i22++) {
            var o2 = e22[2 * i22 + 1];
            0 !== o2 && (e22[2 * i22] = j(s22[o2]++, o2));
          }
        }
        function W(e22) {
          var t22;
          for (t22 = 0; t22 < l; t22++) e22.dyn_ltree[2 * t22] = 0;
          for (t22 = 0; t22 < f3; t22++) e22.dyn_dtree[2 * t22] = 0;
          for (t22 = 0; t22 < c; t22++) e22.bl_tree[2 * t22] = 0;
          e22.dyn_ltree[2 * m2] = 1, e22.opt_len = e22.static_len = 0, e22.last_lit = e22.matches = 0;
        }
        function M(e22) {
          8 < e22.bi_valid ? U(e22, e22.bi_buf) : 0 < e22.bi_valid && (e22.pending_buf[e22.pending++] = e22.bi_buf), e22.bi_buf = 0, e22.bi_valid = 0;
        }
        function H(e22, t22, r22, n2) {
          var i22 = 2 * t22, s22 = 2 * r22;
          return e22[i22] < e22[s22] || e22[i22] === e22[s22] && n2[t22] <= n2[r22];
        }
        function G(e22, t22, r22) {
          for (var n2 = e22.heap[r22], i22 = r22 << 1; i22 <= e22.heap_len && (i22 < e22.heap_len && H(t22, e22.heap[i22 + 1], e22.heap[i22], e22.depth) && i22++, !H(t22, n2, e22.heap[i22], e22.depth)); ) e22.heap[r22] = e22.heap[i22], r22 = i22, i22 <<= 1;
          e22.heap[r22] = n2;
        }
        function K(e22, t22, r22) {
          var n2, i22, s22, a2, o2 = 0;
          if (0 !== e22.last_lit) for (; n2 = e22.pending_buf[e22.d_buf + 2 * o2] << 8 | e22.pending_buf[e22.d_buf + 2 * o2 + 1], i22 = e22.pending_buf[e22.l_buf + o2], o2++, 0 === n2 ? L(e22, i22, t22) : (L(e22, (s22 = A2[i22]) + u + 1, t22), 0 !== (a2 = w[s22]) && P(e22, i22 -= I[s22], a2), L(e22, s22 = N(--n2), r22), 0 !== (a2 = k[s22]) && P(e22, n2 -= T[s22], a2)), o2 < e22.last_lit; ) ;
          L(e22, m2, t22);
        }
        function Y(e22, t22) {
          var r22, n2, i22, s22 = t22.dyn_tree, a2 = t22.stat_desc.static_tree, o2 = t22.stat_desc.has_stree, h22 = t22.stat_desc.elems, u2 = -1;
          for (e22.heap_len = 0, e22.heap_max = _, r22 = 0; r22 < h22; r22++) 0 !== s22[2 * r22] ? (e22.heap[++e22.heap_len] = u2 = r22, e22.depth[r22] = 0) : s22[2 * r22 + 1] = 0;
          for (; e22.heap_len < 2; ) s22[2 * (i22 = e22.heap[++e22.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e22.depth[i22] = 0, e22.opt_len--, o2 && (e22.static_len -= a2[2 * i22 + 1]);
          for (t22.max_code = u2, r22 = e22.heap_len >> 1; 1 <= r22; r22--) G(e22, s22, r22);
          for (i22 = h22; r22 = e22.heap[1], e22.heap[1] = e22.heap[e22.heap_len--], G(e22, s22, 1), n2 = e22.heap[1], e22.heap[--e22.heap_max] = r22, e22.heap[--e22.heap_max] = n2, s22[2 * i22] = s22[2 * r22] + s22[2 * n2], e22.depth[i22] = (e22.depth[r22] >= e22.depth[n2] ? e22.depth[r22] : e22.depth[n2]) + 1, s22[2 * r22 + 1] = s22[2 * n2 + 1] = i22, e22.heap[1] = i22++, G(e22, s22, 1), 2 <= e22.heap_len; ) ;
          e22.heap[--e22.heap_max] = e22.heap[1], (function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f22 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m22 = 0;
            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m22++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f22 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m22) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m22 -= 2;
              } while (0 < m22);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          })(e22, t22), Z2(s22, u2, e22.bl_count);
        }
        function X(e22, t22, r22) {
          var n2, i22, s22 = -1, a2 = t22[1], o2 = 0, h22 = 7, u2 = 4;
          for (0 === a2 && (h22 = 138, u2 = 3), t22[2 * (r22 + 1) + 1] = 65535, n2 = 0; n2 <= r22; n2++) i22 = a2, a2 = t22[2 * (n2 + 1) + 1], ++o2 < h22 && i22 === a2 || (o2 < u2 ? e22.bl_tree[2 * i22] += o2 : 0 !== i22 ? (i22 !== s22 && e22.bl_tree[2 * i22]++, e22.bl_tree[2 * b]++) : o2 <= 10 ? e22.bl_tree[2 * v]++ : e22.bl_tree[2 * y]++, s22 = i22, u2 = (o2 = 0) === a2 ? (h22 = 138, 3) : i22 === a2 ? (h22 = 6, 3) : (h22 = 7, 4));
        }
        function V(e22, t22, r22) {
          var n2, i22, s22 = -1, a2 = t22[1], o2 = 0, h22 = 7, u2 = 4;
          for (0 === a2 && (h22 = 138, u2 = 3), n2 = 0; n2 <= r22; n2++) if (i22 = a2, a2 = t22[2 * (n2 + 1) + 1], !(++o2 < h22 && i22 === a2)) {
            if (o2 < u2) for (; L(e22, i22, e22.bl_tree), 0 != --o2; ) ;
            else 0 !== i22 ? (i22 !== s22 && (L(e22, i22, e22.bl_tree), o2--), L(e22, b, e22.bl_tree), P(e22, o2 - 3, 2)) : o2 <= 10 ? (L(e22, v, e22.bl_tree), P(e22, o2 - 3, 3)) : (L(e22, y, e22.bl_tree), P(e22, o2 - 11, 7));
            s22 = i22, u2 = (o2 = 0) === a2 ? (h22 = 138, 3) : i22 === a2 ? (h22 = 6, 3) : (h22 = 7, 4);
          }
        }
        n(T);
        var q = false;
        function J(e22, t22, r22, n2) {
          P(e22, (s2 << 1) + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            M(e3), U(e3, r3), U(e3, ~r3), i2.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          })(e22, t22, r22);
        }
        r2._tr_init = function(e22) {
          q || ((function() {
            var e3, t22, r22, n2, i22, s22 = new Array(g + 1);
            for (n2 = r22 = 0; n2 < a - 1; n2++) for (I[n2] = r22, e3 = 0; e3 < 1 << w[n2]; e3++) A2[r22++] = n2;
            for (A2[r22 - 1] = n2, n2 = i22 = 0; n2 < 16; n2++) for (T[n2] = i22, e3 = 0; e3 < 1 << k[n2]; e3++) E[i22++] = n2;
            for (i22 >>= 7; n2 < f3; n2++) for (T[n2] = i22 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i22++] = n2;
            for (t22 = 0; t22 <= g; t22++) s22[t22] = 0;
            for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s22[8]++;
            for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s22[9]++;
            for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s22[7]++;
            for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s22[8]++;
            for (Z2(z, l + 1, s22), e3 = 0; e3 < f3; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f3, g), R = new D(new Array(0), x2, 0, c, p);
          })(), q = true), e22.l_desc = new F2(e22.dyn_ltree, O), e22.d_desc = new F2(e22.dyn_dtree, B), e22.bl_desc = new F2(e22.bl_tree, R), e22.bi_buf = 0, e22.bi_valid = 0, W(e22);
        }, r2._tr_stored_block = J, r2._tr_flush_block = function(e22, t22, r22, n2) {
          var i22, s22, a2 = 0;
          0 < e22.level ? (2 === e22.strm.data_type && (e22.strm.data_type = (function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h2;
            for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h2;
            return o;
          })(e22)), Y(e22, e22.l_desc), Y(e22, e22.d_desc), a2 = (function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S2[t3] + 1]; t3--) ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          })(e22), i22 = e22.opt_len + 3 + 7 >>> 3, (s22 = e22.static_len + 3 + 7 >>> 3) <= i22 && (i22 = s22)) : i22 = s22 = r22 + 5, r22 + 4 <= i22 && -1 !== t22 ? J(e22, t22, r22, n2) : 4 === e22.strategy || s22 === i22 ? (P(e22, 2 + (n2 ? 1 : 0), 3), K(e22, z, C)) : (P(e22, 4 + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S2[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          })(e22, e22.l_desc.max_code + 1, e22.d_desc.max_code + 1, a2 + 1), K(e22, e22.dyn_ltree, e22.dyn_dtree)), W(e22), n2 && M(e22);
        }, r2._tr_tally = function(e22, t22, r22) {
          return e22.pending_buf[e22.d_buf + 2 * e22.last_lit] = t22 >>> 8 & 255, e22.pending_buf[e22.d_buf + 2 * e22.last_lit + 1] = 255 & t22, e22.pending_buf[e22.l_buf + e22.last_lit] = 255 & r22, e22.last_lit++, 0 === t22 ? e22.dyn_ltree[2 * r22]++ : (e22.matches++, t22--, e22.dyn_ltree[2 * (A2[r22] + u + 1)]++, e22.dyn_dtree[2 * N(t22)]++), e22.last_lit === e22.lit_bufsize - 1;
        }, r2._tr_align = function(e22) {
          P(e22, 2, 3), L(e22, m2, z), (function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          })(e22);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t2, r2) {
        (function(e22) {
          !(function(r22, n) {
            if (!r22.setImmediate) {
              var i2, s2, t22, a, o = 1, h2 = {}, u = false, l = r22.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r22);
              e3 = e3 && e3.setTimeout ? e3 : r22, i2 = "[object process]" === {}.toString.call(r22.process) ? function(e4) {
                process$1.nextTick(function() {
                  c(e4);
                });
              } : (function() {
                if (r22.postMessage && !r22.importScripts) {
                  var e4 = true, t3 = r22.onmessage;
                  return r22.onmessage = function() {
                    e4 = false;
                  }, r22.postMessage("", "*"), r22.onmessage = t3, e4;
                }
              })() ? (a = "setImmediate$" + Math.random() + "$", r22.addEventListener ? r22.addEventListener("message", d, false) : r22.attachEvent("onmessage", d), function(e4) {
                r22.postMessage(a + e4, "*");
              }) : r22.MessageChannel ? ((t22 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t22.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s2 = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s2.removeChild(t3), t3 = null;
                }, s2.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h2[o] = n2, i2(o), o++;
              }, e3.clearImmediate = f3;
            }
            function f3(e4) {
              delete h2[e4];
            }
            function c(e4) {
              if (u) setTimeout(c, 0, e4);
              else {
                var t3 = h2[e4];
                if (t3) {
                  u = true;
                  try {
                    !(function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    })(t3);
                  } finally {
                    f3(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r22 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          })("undefined" == typeof self ? void 0 === e22 ? this : e22 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
var jszip_minExports = requireJszip_min();
var JSZip = /* @__PURE__ */ getDefaultExportFromCjs$1(jszip_minExports);
var xml$1 = { exports: {} };
var escapeForXML_1;
var hasRequiredEscapeForXML;
function requireEscapeForXML() {
  if (hasRequiredEscapeForXML) return escapeForXML_1;
  hasRequiredEscapeForXML = 1;
  var XML_CHARACTER_MAP = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
    "<": "&lt;",
    ">": "&gt;"
  };
  function escapeForXML(string) {
    return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
      return XML_CHARACTER_MAP[item];
    }) : string;
  }
  escapeForXML_1 = escapeForXML;
  return escapeForXML_1;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml$1.exports;
  hasRequiredXml = 1;
  var escapeForXML = requireEscapeForXML();
  var Stream3 = requireStreamBrowserify().Stream;
  var DEFAULT_INDENT = "    ";
  function xml2(input, options) {
    if (typeof options !== "object") {
      options = {
        indent: options
      };
    }
    var stream = options.stream ? new Stream3() : null, output = "", interrupted = false, indent = !options.indent ? "" : options.indent === true ? DEFAULT_INDENT : options.indent, instant = true;
    function delay(func) {
      if (!instant) {
        func();
      } else {
        process$1.nextTick(func);
      }
    }
    function append(interrupt, out) {
      if (out !== void 0) {
        output += out;
      }
      if (interrupt && !interrupted) {
        stream = stream || new Stream3();
        interrupted = true;
      }
      if (interrupt && interrupted) {
        var data2 = output;
        delay(function() {
          stream.emit("data", data2);
        });
        output = "";
      }
    }
    function add(value, last) {
      format(append, resolve(value, indent, indent ? 1 : 0), last);
    }
    function end() {
      if (stream) {
        var data2 = output;
        delay(function() {
          stream.emit("data", data2);
          stream.emit("end");
          stream.readable = false;
          stream.emit("close");
        });
      }
    }
    function addXmlDeclaration(declaration) {
      var encoding = declaration.encoding || "UTF-8", attr = { version: "1.0", encoding };
      if (declaration.standalone) {
        attr.standalone = declaration.standalone;
      }
      add({ "?xml": { _attr: attr } });
      output = output.replace("/>", "?>");
    }
    delay(function() {
      instant = false;
    });
    if (options.declaration) {
      addXmlDeclaration(options.declaration);
    }
    if (input && input.forEach) {
      input.forEach(function(value, i2) {
        var last;
        if (i2 + 1 === input.length)
          last = end;
        add(value, last);
      });
    } else {
      add(input, end);
    }
    if (stream) {
      stream.readable = true;
      return stream;
    }
    return output;
  }
  function element() {
    var input = Array.prototype.slice.call(arguments), self2 = {
      _elem: resolve(input)
    };
    self2.push = function(input2) {
      if (!this.append) {
        throw new Error("not assigned to a parent!");
      }
      var that = this;
      var indent = this._elem.indent;
      format(
        this.append,
        resolve(
          input2,
          indent,
          this._elem.icount + (indent ? 1 : 0)
        ),
        function() {
          that.append(true);
        }
      );
    };
    self2.close = function(input2) {
      if (input2 !== void 0) {
        this.push(input2);
      }
      if (this.end) {
        this.end();
      }
    };
    return self2;
  }
  function create_indent(character, count) {
    return new Array(count || 0).join(character || "");
  }
  function resolve(data2, indent, indent_count) {
    indent_count = indent_count || 0;
    var indent_spaces = create_indent(indent, indent_count);
    var name;
    var values = data2;
    var interrupt = false;
    if (typeof data2 === "object") {
      var keys = Object.keys(data2);
      name = keys[0];
      values = data2[name];
      if (values && values._elem) {
        values._elem.name = name;
        values._elem.icount = indent_count;
        values._elem.indent = indent;
        values._elem.indents = indent_spaces;
        values._elem.interrupt = values;
        return values._elem;
      }
    }
    var attributes = [], content = [];
    var isStringContent;
    function get_attributes(obj) {
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        attributes.push(attribute(key, obj[key]));
      });
    }
    switch (typeof values) {
      case "object":
        if (values === null) break;
        if (values._attr) {
          get_attributes(values._attr);
        }
        if (values._cdata) {
          content.push(
            ("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
          );
        }
        if (values.forEach) {
          isStringContent = false;
          content.push("");
          values.forEach(function(value) {
            if (typeof value == "object") {
              var _name = Object.keys(value)[0];
              if (_name == "_attr") {
                get_attributes(value._attr);
              } else {
                content.push(resolve(
                  value,
                  indent,
                  indent_count + 1
                ));
              }
            } else {
              content.pop();
              isStringContent = true;
              content.push(escapeForXML(value));
            }
          });
          if (!isStringContent) {
            content.push("");
          }
        }
        break;
      default:
        content.push(escapeForXML(values));
    }
    return {
      name,
      interrupt,
      attributes,
      content,
      icount: indent_count,
      indents: indent_spaces,
      indent
    };
  }
  function format(append, elem, end) {
    if (typeof elem != "object") {
      return append(false, elem);
    }
    var len = elem.interrupt ? 1 : elem.content.length;
    function proceed() {
      while (elem.content.length) {
        var value = elem.content.shift();
        if (value === void 0) continue;
        if (interrupt(value)) return;
        format(append, value);
      }
      append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
      if (end) {
        end();
      }
    }
    function interrupt(value) {
      if (value.interrupt) {
        value.interrupt.append = append;
        value.interrupt.end = proceed;
        value.interrupt = false;
        append(true);
        return true;
      }
      return false;
    }
    append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
    if (!len) {
      return append(false, elem.indent ? "\n" : "");
    }
    if (!interrupt(elem)) {
      proceed();
    }
  }
  function attribute(key, value) {
    return key + '="' + escapeForXML(value) + '"';
  }
  xml$1.exports = xml2;
  xml$1.exports.element = xml$1.exports.Element = element;
  return xml$1.exports;
}
var xmlExports = requireXml();
var xml = /* @__PURE__ */ getDefaultExportFromCjs$1(xmlExports);
var obfuscatedStartOffset = 0;
var obfuscatedEndOffset = 32;
var guidSize = 32;
var obfuscate = (buf, fontKey) => {
  const guid = fontKey.replace(/-/g, "");
  if (guid.length !== guidSize) {
    throw new Error(`Error: Cannot extract GUID from font filename: ${fontKey}`);
  }
  const hexStrings = guid.replace(/(..)/g, "$1 ").trim().split(" ");
  const hexNumbers = hexStrings.map((hexString) => parseInt(hexString, 16));
  hexNumbers.reverse();
  const bytesToObfuscate = buf.slice(obfuscatedStartOffset, obfuscatedEndOffset);
  const obfuscatedBytes = bytesToObfuscate.map((byte, i2) => byte ^ hexNumbers[i2 % hexNumbers.length]);
  const out = new Uint8Array(obfuscatedStartOffset + obfuscatedBytes.length + Math.max(0, buf.length - obfuscatedEndOffset));
  out.set(buf.slice(0, obfuscatedStartOffset));
  out.set(obfuscatedBytes, obfuscatedStartOffset);
  out.set(buf.slice(obfuscatedEndOffset), obfuscatedStartOffset + obfuscatedBytes.length);
  return out;
};
var Formatter = class {
  format(input, context = { stack: [] }) {
    const output = input.prepForXml(context);
    if (output) {
      return output;
    } else {
      throw Error("XMLComponent did not format correctly");
    }
  }
};
var ImageReplacer = class {
  replace(xmlData, mediaData, offset) {
    let currentXmlData = xmlData;
    mediaData.forEach((image, i2) => {
      currentXmlData = currentXmlData.replace(new RegExp(`{${image.fileName}}`, "g"), (offset + i2).toString());
    });
    return currentXmlData;
  }
  getMediaData(xmlData, media) {
    return media.Array.filter((image) => xmlData.search(`{${image.fileName}}`) > 0);
  }
};
var NumberingReplacer = class {
  replace(xmlData, concreteNumberings) {
    let currentXmlData = xmlData;
    for (const concreteNumbering of concreteNumberings) {
      currentXmlData = currentXmlData.replace(
        new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, "g"),
        concreteNumbering.numId.toString()
      );
    }
    return currentXmlData;
  }
};
var Compiler = class {
  constructor() {
    __publicField(this, "formatter");
    __publicField(this, "imageReplacer");
    __publicField(this, "numberingReplacer");
    this.formatter = new Formatter();
    this.imageReplacer = new ImageReplacer();
    this.numberingReplacer = new NumberingReplacer();
  }
  compile(file, prettifyXml, overrides = []) {
    const zip = new JSZip();
    const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);
    const map = new Map(Object.entries(xmlifiedFileMapping));
    for (const [, obj] of map) {
      if (Array.isArray(obj)) {
        for (const subFile of obj) {
          zip.file(subFile.path, subFile.data);
        }
      } else {
        zip.file(obj.path, obj.data);
      }
    }
    for (const subFile of overrides) {
      zip.file(subFile.path, subFile.data);
    }
    for (const data2 of file.Media.Array) {
      if (data2.type !== "svg") {
        zip.file(`word/media/${data2.fileName}`, data2.data);
      } else {
        zip.file(`word/media/${data2.fileName}`, data2.data);
        zip.file(`word/media/${data2.fallback.fileName}`, data2.fallback.data);
      }
    }
    for (const { data: buffer2, name, fontKey } of file.FontTable.fontOptionsWithKey) {
      const [nameWithoutExtension] = name.split(".");
      zip.file(`word/fonts/${nameWithoutExtension}.odttf`, obfuscate(buffer2, fontKey));
    }
    return zip;
  }
  xmlifyFile(file, prettify) {
    const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;
    const documentXmlData = xml(
      this.formatter.format(file.Document.View, {
        viewWrapper: file.Document,
        file,
        stack: []
      }),
      {
        indent: prettify,
        declaration: {
          standalone: "yes",
          encoding: "UTF-8"
        }
      }
    );
    const commentRelationshipCount = file.Comments.Relationships.RelationshipCount + 1;
    const commentXmlData = xml(
      this.formatter.format(file.Comments, {
        viewWrapper: {
          View: file.Comments,
          Relationships: file.Comments.Relationships
        },
        file,
        stack: []
      }),
      {
        indent: prettify,
        declaration: {
          standalone: "yes",
          encoding: "UTF-8"
        }
      }
    );
    const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);
    const commentMediaDatas = this.imageReplacer.getMediaData(commentXmlData, file.Media);
    return {
      Relationships: {
        data: (() => {
          documentMediaDatas.forEach((mediaData, i2) => {
            file.Document.Relationships.createRelationship(
              documentRelationshipCount + i2,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
              `media/${mediaData.fileName}`
            );
          });
          file.Document.Relationships.createRelationship(
            file.Document.Relationships.RelationshipCount + 1,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
            "fontTable.xml"
          );
          return xml(
            this.formatter.format(file.Document.Relationships, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
        })(),
        path: "word/_rels/document.xml.rels"
      },
      Document: {
        data: (() => {
          const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);
          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
          return referenedXmlData;
        })(),
        path: "word/document.xml"
      },
      Styles: {
        data: (() => {
          const xmlStyles = xml(
            this.formatter.format(file.Styles, {
              viewWrapper: file.Document,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          );
          const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);
          return referencedXmlStyles;
        })(),
        path: "word/styles.xml"
      },
      Properties: {
        data: xml(
          this.formatter.format(file.CoreProperties, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/core.xml"
      },
      Numbering: {
        data: xml(
          this.formatter.format(file.Numbering, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/numbering.xml"
      },
      FileRelationships: {
        data: xml(
          this.formatter.format(file.FileRelationships, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "_rels/.rels"
      },
      HeaderRelationships: file.Headers.map((headerWrapper, index) => {
        const xmlData = xml(
          this.formatter.format(headerWrapper.View, {
            viewWrapper: headerWrapper,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
        mediaDatas.forEach((mediaData, i2) => {
          headerWrapper.Relationships.createRelationship(
            i2,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${mediaData.fileName}`
          );
        });
        return {
          data: xml(
            this.formatter.format(headerWrapper.Relationships, {
              viewWrapper: headerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/header${index + 1}.xml.rels`
        };
      }),
      FooterRelationships: file.Footers.map((footerWrapper, index) => {
        const xmlData = xml(
          this.formatter.format(footerWrapper.View, {
            viewWrapper: footerWrapper,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
        mediaDatas.forEach((mediaData, i2) => {
          footerWrapper.Relationships.createRelationship(
            i2,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${mediaData.fileName}`
          );
        });
        return {
          data: xml(
            this.formatter.format(footerWrapper.Relationships, {
              viewWrapper: footerWrapper,
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/footer${index + 1}.xml.rels`
        };
      }),
      Headers: file.Headers.map((headerWrapper, index) => {
        const tempXmlData = xml(
          this.formatter.format(headerWrapper.View, {
            viewWrapper: headerWrapper,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
        return {
          data: referenedXmlData,
          path: `word/header${index + 1}.xml`
        };
      }),
      Footers: file.Footers.map((footerWrapper, index) => {
        const tempXmlData = xml(
          this.formatter.format(footerWrapper.View, {
            viewWrapper: footerWrapper,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
        return {
          data: referenedXmlData,
          path: `word/footer${index + 1}.xml`
        };
      }),
      ContentTypes: {
        data: xml(
          this.formatter.format(file.ContentTypes, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "[Content_Types].xml"
      },
      CustomProperties: {
        data: xml(
          this.formatter.format(file.CustomProperties, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/custom.xml"
      },
      AppProperties: {
        data: xml(
          this.formatter.format(file.AppProperties, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/app.xml"
      },
      FootNotes: {
        data: xml(
          this.formatter.format(file.FootNotes.View, {
            viewWrapper: file.FootNotes,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/footnotes.xml"
      },
      FootNotesRelationships: {
        data: xml(
          this.formatter.format(file.FootNotes.Relationships, {
            viewWrapper: file.FootNotes,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/_rels/footnotes.xml.rels"
      },
      Settings: {
        data: xml(
          this.formatter.format(file.Settings, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/settings.xml"
      },
      Comments: {
        data: (() => {
          const xmlData = this.imageReplacer.replace(commentXmlData, commentMediaDatas, commentRelationshipCount);
          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
          return referenedXmlData;
        })(),
        path: "word/comments.xml"
      },
      CommentsRelationships: {
        data: (() => {
          commentMediaDatas.forEach((mediaData, i2) => {
            file.Comments.Relationships.createRelationship(
              commentRelationshipCount + i2,
              "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
              `media/${mediaData.fileName}`
            );
          });
          return xml(
            this.formatter.format(file.Comments.Relationships, {
              viewWrapper: {
                View: file.Comments,
                Relationships: file.Comments.Relationships
              },
              file,
              stack: []
            }),
            {
              indent: prettify,
              declaration: {
                encoding: "UTF-8"
              }
            }
          );
        })(),
        path: "word/_rels/comments.xml.rels"
      },
      FontTable: {
        data: xml(
          this.formatter.format(file.FontTable.View, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/fontTable.xml"
      },
      FontTableRelationships: {
        data: (() => xml(
          this.formatter.format(file.FontTable.Relationships, {
            viewWrapper: file.Document,
            file,
            stack: []
          }),
          {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ))(),
        path: "word/_rels/fontTable.xml.rels"
      }
    };
  }
};
var PrettifyType = {
  NONE: "",
  WITH_2_BLANKS: "  ",
  WITH_4_BLANKS: "    ",
  WITH_TAB: "	"
};
var convertPrettifyType = (prettify) => prettify === true ? PrettifyType.WITH_2_BLANKS : prettify === false ? void 0 : prettify;
var _Packer = class _Packer2 {
  // eslint-disable-next-line require-await
  static pack(_0, _12, _2) {
    return __async(this, arguments, function* (file, type2, prettify, overrides = []) {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);
      return zip.generateAsync({
        type: type2,
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toString(file, prettify, overrides = []) {
    return _Packer2.pack(file, "string", prettify, overrides);
  }
  static toBuffer(file, prettify, overrides = []) {
    return _Packer2.pack(file, "nodebuffer", prettify, overrides);
  }
  static toBase64String(file, prettify, overrides = []) {
    return _Packer2.pack(file, "base64", prettify, overrides);
  }
  static toBlob(file, prettify, overrides = []) {
    return _Packer2.pack(file, "blob", prettify, overrides);
  }
  static toArrayBuffer(file, prettify, overrides = []) {
    return _Packer2.pack(file, "arraybuffer", prettify, overrides);
  }
  static toStream(file, prettify, overrides = []) {
    const stream = new streamBrowserifyExports.Stream();
    const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);
    zip.generateAsync({
      type: "nodebuffer",
      mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      compression: "DEFLATE"
    }).then((z) => {
      stream.emit("data", z);
      stream.emit("end");
    });
    return stream;
  }
};
__publicField(_Packer, "compiler", new Compiler());
var Packer = _Packer;
var formatter$1 = new Formatter();
var formatter = new Formatter();
var imageReplacer = new ImageReplacer();
var UTF16LE = new Uint8Array([255, 254]);
var UTF16BE = new Uint8Array([254, 255]);

// src/doc-utils.ts
var import_pizzip = __toESM(require_js(), 1);
import * as fs from "fs";

// src/data/data.ts
var data = [
  {
    title: "[AUT:001] - Registrar usuario exitosamente con datos v\xE1lidos",
    description: "Feature: Registro de usuarios\nScenario: Registro exitoso con datos v\xE1lidos",
    test_case: "Given: El administrador tiene un usuario con nombres, apellidos, fecha_nacimiento, direccion, telefono, correo_electronico v\xE1lido y salario_base v\xE1lido\nWhen: Se env\xEDa la petici\xF3n POST al endpoint /api/v1/usuarios con dichos datos\nThen: El sistema guarda el usuario de forma transaccional en la base de datos\nAnd: Devuelve una respuesta con estado 201 y mensaje de \xE9xito",
    test_type: "Happy Path",
    isFirst: true
  },
  {
    title: "[AUT:001] - Error al registrar usuario con correo electr\xF3nico duplicado",
    description: "Feature: Registro de usuarios\nScenario: Intento de registro con correo electr\xF3nico ya existente",
    test_case: 'Given: Existe un usuario registrado previamente con el correo_electronico "test@correo.com"\nWhen: Se env\xEDa la petici\xF3n POST con un nuevo usuario que tiene el mismo correo_electronico\nThen: El sistema rechaza la operaci\xF3n\nAnd: Devuelve estado 400 con un mensaje indicando que el correo_electronico ya est\xE1 registrado',
    test_type: "Validaci\xF3n Negativa",
    isFirst: false
  }
];

// src/data/titles.ts
var titles = [{ text: "Backoffice - Steven" }];

// src/doc-utils.ts
function createTestCaseTable(testId, tc) {
  const headerCell = new TableCell({
    children: [
      new Paragraph({
        children: [
          new TextRun({
            text: `ID \u2013 ${testId}`,
            bold: true,
            color: "FFFFFF"
          })
        ],
        alignment: AlignmentType.CENTER
      })
    ],
    shading: {
      fill: "0E4CB2",
      type: ShadingType.CLEAR,
      color: "auto"
    },
    columnSpan: 2
  });
  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    rows: [
      new TableRow({ children: [headerCell] }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph("T\xEDtulo")] }),
          new TableCell({ children: [new Paragraph(tc.title)] })
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph("Descripci\xF3n")] }),
          new TableCell({ children: [new Paragraph(tc.description)] })
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph("Caso de prueba")] }),
          new TableCell({ children: [new Paragraph(tc.test_case)] })
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph("Tipo de test")] }),
          new TableCell({ children: [new Paragraph(tc.test_type)] })
        ]
      })
    ]
  });
}
async function generateNewTestCasesDoc() {
  const testCasesData = data;
  const titlesData = titles;
  let TEST_ID = 1228;
  let TITLE_IDX = 0;
  const newParagraphs = [];
  for (const tc of testCasesData) {
    if (tc.isFirst) {
      newParagraphs.push(
        new Paragraph({ children: [new TextRun({ break: 1 })] }),
        new Paragraph({
          text: titlesData[TITLE_IDX].text,
          heading: HeadingLevel.HEADING_1
        })
      );
      TITLE_IDX++;
    }
    const table = createTestCaseTable(TEST_ID, tc);
    newParagraphs.push(
      new Paragraph({ text: "" }),
      table,
      new Paragraph({ text: "" })
    );
    TEST_ID++;
  }
  const doc = new File({
    sections: [
      {
        children: newParagraphs
      }
    ]
  });
  return await Packer.toBuffer(doc);
}
async function mergeDocxFiles(originalPath, newContentBuffer, outputPath) {
  try {
    const originalContent = fs.readFileSync(originalPath);
    const originalZip = new import_pizzip.default(originalContent);
    const newZip = new import_pizzip.default(newContentBuffer);
    const originalDocXml = originalZip.file("word/document.xml")?.asText();
    const newDocXml = newZip.file("word/document.xml")?.asText();
    if (!originalDocXml || !newDocXml) {
      throw new Error("Could not extract document.xml from one of the files");
    }
    const bodyEndTag = "</w:body>";
    const bodyEndIndex = originalDocXml.lastIndexOf(bodyEndTag);
    if (bodyEndIndex === -1) {
      throw new Error("Could not find closing body tag in original document");
    }
    const newBodyStart = newDocXml.indexOf("<w:body>") + "<w:body>".length;
    const newBodyEnd = newDocXml.lastIndexOf("</w:body>");
    const newContent = newDocXml.substring(newBodyStart, newBodyEnd);
    const pageBreak = '<w:p><w:r><w:br w:type="page"/></w:r></w:p>';
    const mergedDocXml = originalDocXml.substring(0, bodyEndIndex) + pageBreak + newContent + originalDocXml.substring(bodyEndIndex);
    originalZip.file("word/document.xml", mergedDocXml);
    const newMediaFiles = Object.keys(newZip.files).filter(
      (filename) => filename.startsWith("word/media/")
    );
    for (const mediaFile of newMediaFiles) {
      const file = newZip.file(mediaFile);
      if (file) {
        originalZip.file(mediaFile, file.asNodeBuffer());
      }
    }
    const mergedBuffer = originalZip.generate({
      type: "nodebuffer",
      compression: "DEFLATE"
    });
    fs.writeFileSync(outputPath, mergedBuffer);
    console.log(`\u2705 Documents merged successfully: ${outputPath}`);
  } catch (error) {
    throw new Error(`\u274C Error merging documents: ${error}`);
  }
}
async function generateDocWithAppend() {
  const originalDocPath = "./original.docx";
  const outputPath = "./final_document.docx";
  try {
    console.log("\u{1F4DD} Generating new test cases...");
    const newContentBuffer = await generateNewTestCasesDoc();
    if (!fs.existsSync(originalDocPath)) {
      fs.writeFileSync(outputPath, newContentBuffer);
      console.log("\u2705 New document created (no original to merge)");
      return;
    }
    console.log("\u{1F517} Merging with original document...");
    await mergeDocxFiles(originalDocPath, newContentBuffer, outputPath);
  } catch (error) {
    console.error("\u274C Error:", error);
    throw error;
  }
}

// node_modules/node-fetch/src/index.js
import http2 from "node:http";
import https from "node:https";
import zlib from "node:zlib";
import Stream2, { PassThrough as PassThrough2, pipeline as pump } from "node:stream";
import { Buffer as Buffer3 } from "node:buffer";

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri2) {
  if (!/^data:/i.test(uri2)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri2 = uri2.replace(/\r?\n/g, "");
  const firstComma = uri2.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri2.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type2 = meta[0] || "text/plain";
  let typeFull = type2;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data2 = unescape(uri2.substring(firstComma + 1));
  const buffer2 = Buffer.from(data2, encoding);
  buffer2.type = type2;
  buffer2.typeFull = typeFull;
  buffer2.charset = charset;
  return buffer2;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
init_fetch_blob();
init_esm_min();
import Stream, { PassThrough } from "node:stream";
import { types as types2, deprecate, promisify } from "node:util";
import { Buffer as Buffer2 } from "node:buffer";

// node_modules/node-fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  constructor(message, type2) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type2;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// node_modules/node-fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} [type] -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type2, systemError) {
    super(message, type2);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
var isAbortSignal = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = promisify(Stream.pipeline);
var INTERNALS = Symbol("Body internals");
var Body2 = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer2.from(body.toString());
    } else if (isBlob(body)) {
    } else if (Buffer2.isBuffer(body)) {
    } else if (types2.isAnyArrayBuffer(body)) {
      body = Buffer2.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer2.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream) {
    } else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = Buffer2.from(String(body));
    }
    let stream = body;
    if (Buffer2.isBuffer(body)) {
      stream = Stream.Readable.from(body);
    } else if (isBlob(body)) {
      stream = Stream.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof Stream) {
      body.on("error", (error_) => {
        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  async arrayBuffer() {
    const { buffer: buffer2, byteOffset, byteLength } = await consumeBody(this);
    return buffer2.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData();
      const parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) {
        formData.append(name, value);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
    return toFormData2(this.body, ct);
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  async text() {
    const buffer2 = await consumeBody(this);
    return new TextDecoder().decode(buffer2);
  }
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody(this);
  }
};
Body2.prototype.buffer = deprecate(Body2.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body2.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: deprecate(
    () => {
    },
    "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
    "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
  ) }
});
async function consumeBody(data2) {
  if (data2[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data2.url}`);
  }
  data2[INTERNALS].disturbed = true;
  if (data2[INTERNALS].error) {
    throw data2[INTERNALS].error;
  }
  const { body } = data2;
  if (body === null) {
    return Buffer2.alloc(0);
  }
  if (!(body instanceof Stream)) {
    return Buffer2.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data2.size > 0 && accumBytes + chunk.length > data2.size) {
        const error = new FetchError(`content size at ${data2.url} over limit: ${data2.size}`, "max-size");
        body.destroy(error);
        throw error;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error) {
    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data2.url}: ${error.message}`, "system", error);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer2.from(accum.join(""));
      }
      return Buffer2.concat(accum, accumBytes);
    } catch (error) {
      throw new FetchError(`Could not create Buffer from response body for ${data2.url}: ${error.message}`, "system", error);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data2.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough({ highWaterMark });
    p2 = new PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = deprecate(
  (body) => body.getBoundary(),
  "form-data doesn't follow the spec and requires special treatment. Use alternative package",
  "https://github.com/node-fetch/node-fetch/issues/1167"
);
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer2.isBuffer(body) || types2.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof Stream) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer2.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/node-fetch/src/headers.js
import { types as types3 } from "node:util";
import http from "node:http";
var validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error;
  }
};
var validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const error = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
    throw error;
  }
};
var Headers = class _Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof _Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init == null) {
    } else if (typeof init === "object" && !types3.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init].map((pair) => {
          if (typeof pair !== "object" || types3.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(
                target,
                String(name).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback, thisArg = void 0) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  /**
   * @type {() => IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce((result, property) => {
    result[property] = { enumerable: true };
    return result;
  }, {})
);
function fromRawHeaders(headers2 = []) {
  return new Headers(
    headers2.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch {
        return false;
      }
    })
  );
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response = class _Response extends Body2 {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers2 = new Headers(options.headers);
    if (body !== null && !headers2.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers2.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers: headers2,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new _Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new _Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new _Response(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data2 = void 0, init = {}) {
    const body = JSON.stringify(data2);
    if (body === void 0) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers2 = new Headers(init && init.headers);
    if (!headers2.has("content-type")) {
      headers2.set("content-type", "application/json");
    }
    return new _Response(body, {
      ...init,
      headers: headers2
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
import { format as formatUrl } from "node:url";
import { deprecate as deprecate2 } from "node:util";

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
import { isIP } from "node:net";
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = /* @__PURE__ */ new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = isIP(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers2) {
  const policyTokens = (headers2.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var doBadDataWarn = deprecate2(
  () => {
  },
  ".data is not a valid RequestInit property, use .body instead",
  "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
);
var Request = class _Request extends Body2 {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && "data" in init) {
      doBadDataWarn();
    }
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers2 = new Headers(init.headers || input.headers || {});
    if (inputBody !== null && !headers2.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers2.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = void 0;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers: headers2,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  /** @returns {string} */
  get method() {
    return this[INTERNALS3].method;
  }
  /** @returns {string} */
  get url() {
    return formatUrl(this[INTERNALS3].parsedURL);
  }
  /** @returns {Headers} */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /** @returns {AbortSignal} */
  get signal() {
    return this[INTERNALS3].signal;
  }
  // https://fetch.spec.whatwg.org/#dom-request-referrer
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return void 0;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new _Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers2 = new Headers(request[INTERNALS3].headers);
  if (!headers2.has("Accept")) {
    headers2.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers2.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers2.set("Referer", request.referrer);
  }
  if (!headers2.has("User-Agent")) {
    headers2.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers2.has("Accept-Encoding")) {
    headers2.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  const search = getSearch(parsedURL);
  const options = {
    // Overwrite search to retain trailing ? (issue #776)
    path: parsedURL.pathname + search,
    // The following options are not expressed in the URL
    method: request.method,
    headers: headers2[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    /** @type {URL} */
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  constructor(message, type2 = "aborted") {
    super(message, type2);
  }
};

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data2 = dist_default(request.url);
      const response2 = new Response(data2, { headers: { "Content-Type": data2.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? https : http2).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error);
      if (request.body && request.body instanceof Stream2.Readable) {
        request.body.destroy(error);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error) => {
      if (response && response.body) {
        response.body.destroy(error);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers2 = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers2.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream2.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers2);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = pump(response_, new PassThrough2(), (error) => {
        if (error) {
          reject(error);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers: headers2,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers2.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pump(body, zlib.createGunzip(zlibOptions), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pump(response_, new PassThrough2(), (error) => {
          if (error) {
            reject(error);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pump(body, zlib.createInflate(), (error) => {
              if (error) {
                reject(error);
              }
            });
          } else {
            body = pump(body, zlib.createInflateRaw(), (error) => {
              if (error) {
                reject(error);
              }
            });
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = pump(body, zlib.createBrotliDecompress(), (error) => {
          if (error) {
            reject(error);
          }
        });
        response = new Response(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer3.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers: headers2 } = response;
    isChunkedTransfer = headers2["transfer-encoding"] === "chunked" && !headers2["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = Buffer3.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer3.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer3.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/data/testcases.ts
var testcases = [
  {
    title: "",
    content: ""
  },
  {
    title: "[AUT:001] - Registrar usuario exitosamente con datos v\xE1lidos",
    content: "Feature: Registro de usuarios\nScenario: Registro exitoso con datos v\xE1lidos\nGiven: El administrador tiene un usuario con nombres, apellidos, fecha_nacimiento, direccion, telefono, correo_electronico v\xE1lido y salario_base v\xE1lido\nWhen: Se env\xEDa la petici\xF3n POST al endpoint /api/v1/usuarios con dichos datos\nThen: El sistema guarda el usuario de forma transaccional en la base de datos\nAnd: Devuelve una respuesta con estado 201 y mensaje de \xE9xito\nTipo de test case: Happy Path"
  },
  {
    title: "[AUT:001] - Error al registrar usuario con correo electr\xF3nico duplicado",
    content: 'Feature: Registro de usuarios\nScenario: Intento de registro con correo electr\xF3nico ya existente\nGiven: Existe un usuario registrado previamente con el correo_electronico "test@correo.com"\nWhen: Se env\xEDa la petici\xF3n POST con un nuevo usuario que tiene el mismo correo_electronico\nThen: El sistema rechaza la operaci\xF3n\nAnd: Devuelve estado 400 con un mensaje indicando que el correo_electronico ya est\xE1 registrado\nTipo de test case: Validaci\xF3n Negativa'
  }
];

// src/import-test-cases.ts
var csrfmiddlewaretoken = "nZe50CazrEeFyfGgVNQVhn0imLctKK7IuoQ2Utp7Mcp3RaQouZWB0w3xk7O8SkyC";
var csrftoken = "hzM741pIvIlyt5kiJmgQTjdp8wMPiKB4";
var default_tester = "armando";
var product_id = "1";
var category_id = "1";
var headers = (title, content) => ({
  headers: {
    accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
    "accept-language": "en",
    "cache-control": "no-cache",
    "content-type": "application/x-www-form-urlencoded",
    pragma: "no-cache",
    "sec-fetch-dest": "document",
    "sec-fetch-mode": "navigate",
    "sec-fetch-site": "same-origin",
    "sec-fetch-user": "?1",
    "upgrade-insecure-requests": "1",
    cookie: `NEXT_LOCALE=es; _fbp=fb.0.1757619907010.549046907627441429; _ga=GA1.1.1097585688.1757619907; __stripe_mid=e6e228bc-bbd1-4fec-8e40-ac6089c2fd6f1ef505; _ga_WE7JYK3W5B=GS2.1.s1757619907$o1$g1$t1757622540$j60$l0$h0; csrftoken=${csrftoken}; sessionid=2aoll3oczzvbbpq6r9jokq59kcpp55iq; _dd_s=logs=1&id=6ad4b8c6-cb10-4c59-bcd0-666d90616351&created=1760546518282&expire=1760549321739`,
    Referer: "https://localhost/cases/new/"
  },
  body: `csrfmiddlewaretoken=${csrfmiddlewaretoken}&author=2&summary=Test2&default_tester=${default_tester}&product=${product_id}&category=${category_id}&case_status=2&priority=1&setup_duration=0&testing_duration=0&text=Test2&script=&arguments=&requirement=&extra_link=&notes=&email_settings-0-auto_to_case_author=on&email_settings-0-auto_to_run_manager=on&email_settings-0-auto_to_execution_assignee=on&email_settings-0-auto_to_case_tester=on&email_settings-0-auto_to_run_tester=on&email_settings-0-notify_on_case_update=on&email_settings-0-notify_on_case_delete=on&email_settings-0-cc_list=&email_settings-0-case=&email_settings-0-id=&email_settings-TOTAL_FORMS=1&email_settings-INITIAL_FORMS=0&email_settings-MIN_NUM_FORMS=0&email_settings-MAX_NUM_FORMS=1`,
  method: "POST"
});
var createTest = async (title, content) => {
  let response;
  try {
    response = await fetch(
      "https://localhost/cases/new/",
      headers(title, content)
    );
    if (response.ok) {
      const status = await response.status;
      console.log(status);
    }
  } catch (error) {
    throw new Error(`Error at creating test case: ${title}
Error: ${error}`);
  }
};
async function importTestCases() {
  for (const test of testcases) {
    await createTest(test.title, test.content);
  }
}

// src/index.ts
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
async function main() {
  await importTestCases();
  await generateDocWithAppend();
}
await main();
/*! Bundled license information:

pako/dist/pako.es5.min.js:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

web-streams-polyfill/dist/ponyfill.es2018.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

docx/dist/index.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
